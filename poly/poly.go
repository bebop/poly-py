/*
cgo stubs for package poly.
File is generated by gopy. Do not edit.
gopy pkg -vm=python3 github.com/bebop/poly
*/

package main

/*

#cgo CFLAGS: "-I/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/lib" "-lpython3.13" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"encoding/xml"
	"io"
	"regexp"
	"time"

	"github.com/bebop/poly/alphabet"
	"github.com/bebop/poly/checks"
	"github.com/bebop/poly/clone"
	"github.com/bebop/poly/fold"
	"github.com/bebop/poly/io/fasta"
	"github.com/bebop/poly/io/fastq"
	"github.com/bebop/poly/io/genbank"
	"github.com/bebop/poly/io/gff"
	"github.com/bebop/poly/io/pileup"
	"github.com/bebop/poly/io/polyjson"
	"github.com/bebop/poly/io/rebase"
	"github.com/bebop/poly/io/slow5"
	"github.com/bebop/poly/io/uniprot"
	"github.com/bebop/poly/primers"
	"github.com/bebop/poly/primers/pcr"
	"github.com/bebop/poly/random"
	"github.com/bebop/poly/search/align"
	"github.com/bebop/poly/search/align/matrix"
	"github.com/bebop/poly/search/bwt"
	"github.com/bebop/poly/search/mash"
	"github.com/bebop/poly/seqhash"
	"github.com/bebop/poly/synthesis/codon"
	"github.com/bebop/poly/synthesis/fix"
	"github.com/bebop/poly/synthesis/fragment"
	"github.com/bebop/poly/transform"
	"github.com/bebop/poly/transform/variants"
	"github.com/mroth/weightedrand"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: poly below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *xml.Decoder
func ptrFromHandle_Ptr_xml_Decoder(h CGoHandle) *xml.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*xml.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Decoder{})).(*xml.Decoder)
}
func handleFromPtr_Ptr_xml_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*xml.Decoder", p))
}

// Converters for pointer handles for type: *xml.StartElement
func ptrFromHandle_Ptr_xml_StartElement(h CGoHandle) *xml.StartElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*xml.StartElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.StartElement{})).(*xml.StartElement)
}
func handleFromPtr_Ptr_xml_StartElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*xml.StartElement", p))
}

// Converters for pointer handles for type: *regexp.Regexp
func ptrFromHandle_Ptr_regexp_Regexp(h CGoHandle) *regexp.Regexp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*regexp.Regexp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(regexp.Regexp{})).(*regexp.Regexp)
}
func handleFromPtr_Ptr_regexp_Regexp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*regexp.Regexp", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for non-pointer handles for type: xml.Attr
func ptrFromHandle_xml_Attr(h CGoHandle) *xml.Attr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Attr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Attr{})).(*xml.Attr)
}
func handleFromPtr_xml_Attr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Attr", p))
}

// Converters for non-pointer handles for type: xml.Decoder
func ptrFromHandle_xml_Decoder(h CGoHandle) *xml.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Decoder{})).(*xml.Decoder)
}
func handleFromPtr_xml_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Decoder", p))
}

// Converters for non-pointer handles for type: xml.EndElement
func ptrFromHandle_xml_EndElement(h CGoHandle) *xml.EndElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.EndElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.EndElement{})).(*xml.EndElement)
}
func handleFromPtr_xml_EndElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.EndElement", p))
}

// Converters for non-pointer handles for type: xml.Name
func ptrFromHandle_xml_Name(h CGoHandle) *xml.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Name{})).(*xml.Name)
}
func handleFromPtr_xml_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Name", p))
}

// Converters for non-pointer handles for type: xml.StartElement
func ptrFromHandle_xml_StartElement(h CGoHandle) *xml.StartElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.StartElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.StartElement{})).(*xml.StartElement)
}
func handleFromPtr_xml_StartElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.StartElement", p))
}

// Converters for pointer handles for type: xml.Token
func ptrFromHandle_xml_Token(h CGoHandle) xml.Token {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Token")
	if p == nil {
		return nil
	}
	return p.(xml.Token)
}
func handleFromPtr_xml_Token(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Token", p))
}

// Converters for non-pointer handles for type: weightedrand.Chooser
func ptrFromHandle_weightedrand_Chooser(h CGoHandle) *weightedrand.Chooser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "weightedrand.Chooser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(weightedrand.Chooser{})).(*weightedrand.Chooser)
}
func handleFromPtr_weightedrand_Chooser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("weightedrand.Chooser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.RuneReader
func ptrFromHandle_io_RuneReader(h CGoHandle) io.RuneReader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.RuneReader")
	if p == nil {
		return nil
	}
	return p.(io.RuneReader)
}
func handleFromPtr_io_RuneReader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.RuneReader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: regexp.Regexp
func ptrFromHandle_regexp_Regexp(h CGoHandle) *regexp.Regexp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "regexp.Regexp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(regexp.Regexp{})).(*regexp.Regexp)
}
func handleFromPtr_regexp_Regexp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("regexp.Regexp", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: alphabet ---

// ---- Types ---

// Converters for pointer handles for type: *alphabet.Alphabet
func ptrFromHandle_Ptr_alphabet_Alphabet(h CGoHandle) *alphabet.Alphabet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*alphabet.Alphabet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet)
}
func handleFromPtr_Ptr_alphabet_Alphabet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*alphabet.Alphabet", p))
}

// Converters for pointer handles for type: *alphabet.Error
func ptrFromHandle_Ptr_alphabet_Error(h CGoHandle) *alphabet.Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*alphabet.Error")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Error{})).(*alphabet.Error)
}
func handleFromPtr_Ptr_alphabet_Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*alphabet.Error", p))
}

// Converters for non-pointer handles for type: alphabet.Alphabet
func ptrFromHandle_alphabet_Alphabet(h CGoHandle) *alphabet.Alphabet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "alphabet.Alphabet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet)
}
func handleFromPtr_alphabet_Alphabet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("alphabet.Alphabet", p))
}

// Converters for non-pointer handles for type: alphabet.Error
func ptrFromHandle_alphabet_Error(h CGoHandle) *alphabet.Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "alphabet.Error")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Error{})).(*alphabet.Error)
}
func handleFromPtr_alphabet_Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("alphabet.Error", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export alphabet_DNA
func alphabet_DNA() CGoHandle {
	return handleFromPtr_Ptr_alphabet_Alphabet(alphabet.DNA)
}

//export alphabet_Set_DNA
func alphabet_Set_DNA(val CGoHandle) {
	alphabet.DNA = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export alphabet_Protein
func alphabet_Protein() CGoHandle {
	return handleFromPtr_Ptr_alphabet_Alphabet(alphabet.Protein)
}

//export alphabet_Set_Protein
func alphabet_Set_Protein(val CGoHandle) {
	alphabet.Protein = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export alphabet_RNA
func alphabet_RNA() CGoHandle {
	return handleFromPtr_Ptr_alphabet_Alphabet(alphabet.RNA)
}

//export alphabet_Set_RNA
func alphabet_Set_RNA(val CGoHandle) {
	alphabet.RNA = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: alphabet.Error ---
//
//export alphabet_Error_CTor
func alphabet_Error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_alphabet_Error(&alphabet.Error{}))
}

//export alphabet_Error_Error
func alphabet_Error_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*alphabet.Error")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(alphabet.Error{})).(*alphabet.Error).Error())

}

// --- wrapping struct: alphabet.Alphabet ---
//
//export alphabet_Alphabet_CTor
func alphabet_Alphabet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_alphabet_Alphabet(&alphabet.Alphabet{}))
}

//export alphabet_Alphabet_Encode
func alphabet_Alphabet_Encode(_handle CGoHandle, symbol *C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*alphabet.Alphabet")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet).Encode(C.GoString(symbol))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export alphabet_Alphabet_Decode
func alphabet_Alphabet_Decode(_handle CGoHandle, code *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*alphabet.Alphabet")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet).Decode(C.GoString(code))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export alphabet_Alphabet_Extend
func alphabet_Alphabet_Extend(_handle CGoHandle, symbols CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*alphabet.Alphabet")
	if __err != nil {
		return handleFromPtr_Ptr_alphabet_Alphabet(nil)
	}
	return handleFromPtr_Ptr_alphabet_Alphabet(gopyh.Embed(vifc, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet).Extend(deptrFromHandle_Slice_string(symbols)))

}

//export alphabet_Alphabet_Symbols
func alphabet_Alphabet_Symbols(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*alphabet.Alphabet")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet).Symbols()

	return handleFromPtr_Slice_string(&cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export alphabet_NewAlphabet
func alphabet_NewAlphabet(symbols CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_alphabet_Alphabet(alphabet.NewAlphabet(deptrFromHandle_Slice_string(symbols)))

}

// ---- Functions ---

// ---- Package: checks ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export checks_IsDNA
func checks_IsDNA(seq *C.char) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(checks.IsDNA(C.GoString(seq)))

}

//export checks_IsPalindromic
func checks_IsPalindromic(sequence *C.char) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(checks.IsPalindromic(C.GoString(sequence)))

}

//export checks_IsRNA
func checks_IsRNA(seq *C.char) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(checks.IsRNA(C.GoString(seq)))

}

//export checks_GcContent
func checks_GcContent(sequence *C.char) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.double(checks.GcContent(C.GoString(sequence)))

}

// ---- Package: clone ---

// ---- Types ---

// Converters for pointer handles for type: *clone.Enzyme
func ptrFromHandle_Ptr_clone_Enzyme(h CGoHandle) *clone.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clone.Enzyme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Enzyme{})).(*clone.Enzyme)
}
func handleFromPtr_Ptr_clone_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clone.Enzyme", p))
}

// Converters for pointer handles for type: *clone.EnzymeManager
func ptrFromHandle_Ptr_clone_EnzymeManager(h CGoHandle) *clone.EnzymeManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clone.EnzymeManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.EnzymeManager{})).(*clone.EnzymeManager)
}
func handleFromPtr_Ptr_clone_EnzymeManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clone.EnzymeManager", p))
}

// Converters for pointer handles for type: *clone.Fragment
func ptrFromHandle_Ptr_clone_Fragment(h CGoHandle) *clone.Fragment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clone.Fragment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Fragment{})).(*clone.Fragment)
}
func handleFromPtr_Ptr_clone_Fragment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clone.Fragment", p))
}

// Converters for pointer handles for type: *clone.Overhang
func ptrFromHandle_Ptr_clone_Overhang(h CGoHandle) *clone.Overhang {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clone.Overhang")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Overhang{})).(*clone.Overhang)
}
func handleFromPtr_Ptr_clone_Overhang(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clone.Overhang", p))
}

// Converters for pointer handles for type: *clone.Part
func ptrFromHandle_Ptr_clone_Part(h CGoHandle) *clone.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clone.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Part{})).(*clone.Part)
}
func handleFromPtr_Ptr_clone_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clone.Part", p))
}

// Converters for implicit pointer handles for type: [][][]byte
func ptrFromHandle_Slice_Slice_Slice_byte(h CGoHandle) *[][][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][][]byte)
}
func deptrFromHandle_Slice_Slice_Slice_byte(h CGoHandle) [][][]byte {
	p := ptrFromHandle_Slice_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][][]byte", p))
}

// --- wrapping slice: [][][]byte ---
//
//export Slice_Slice_Slice_byte_CTor
func Slice_Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Slice_byte(&[][][]byte{}))
}

//export Slice_Slice_Slice_byte_len
func Slice_Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Slice_byte(handle))
}

//export Slice_Slice_Slice_byte_elem
func Slice_Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_Slice_byte_subslice
func Slice_Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Slice_byte(&ss))
}

//export Slice_Slice_Slice_byte_set
func Slice_Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_Slice_byte(_vl)
}

//export Slice_Slice_Slice_byte_append
func Slice_Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: [][]int
func ptrFromHandle_Slice_Slice_int(h CGoHandle) *[][]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]int")
	if p == nil {
		return nil
	}
	return p.(*[][]int)
}
func deptrFromHandle_Slice_Slice_int(h CGoHandle) [][]int {
	p := ptrFromHandle_Slice_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]int", p))
}

// --- wrapping slice: [][]int ---
//
//export Slice_Slice_int_CTor
func Slice_Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_int(&[][]int{}))
}

//export Slice_Slice_int_len
func Slice_Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_int(handle))
}

//export Slice_Slice_int_elem
func Slice_Slice_int_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_int(handle)
	return handleFromPtr_Slice_int(&(s[_idx]))
}

//export Slice_Slice_int_subslice
func Slice_Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_int(&ss))
}

//export Slice_Slice_int_set
func Slice_Slice_int_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_int(handle)
	s[_idx] = deptrFromHandle_Slice_int(_vl)
}

//export Slice_Slice_int_append
func Slice_Slice_int_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_int(handle)
	*s = append(*s, deptrFromHandle_Slice_int(_vl))
}

// Converters for implicit pointer handles for type: [][]string
func ptrFromHandle_Slice_Slice_string(h CGoHandle) *[][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]string")
	if p == nil {
		return nil
	}
	return p.(*[][]string)
}
func deptrFromHandle_Slice_Slice_string(h CGoHandle) [][]string {
	p := ptrFromHandle_Slice_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]string", p))
}

// --- wrapping slice: [][]string ---
//
//export Slice_Slice_string_CTor
func Slice_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_string(&[][]string{}))
}

//export Slice_Slice_string_len
func Slice_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_string(handle))
}

//export Slice_Slice_string_elem
func Slice_Slice_string_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_string(handle)
	return handleFromPtr_Slice_string(&(s[_idx]))
}

//export Slice_Slice_string_subslice
func Slice_Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_string(&ss))
}

//export Slice_Slice_string_set
func Slice_Slice_string_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_string(handle)
	s[_idx] = deptrFromHandle_Slice_string(_vl)
}

//export Slice_Slice_string_append
func Slice_Slice_string_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_string(handle)
	*s = append(*s, deptrFromHandle_Slice_string(_vl))
}

// Converters for implicit pointer handles for type: []clone.Enzyme
func ptrFromHandle_Slice_clone_Enzyme(h CGoHandle) *[]clone.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]clone.Enzyme")
	if p == nil {
		return nil
	}
	return p.(*[]clone.Enzyme)
}
func deptrFromHandle_Slice_clone_Enzyme(h CGoHandle) []clone.Enzyme {
	p := ptrFromHandle_Slice_clone_Enzyme(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_clone_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]clone.Enzyme", p))
}

// --- wrapping slice: []clone.Enzyme ---
//
//export Slice_clone_Enzyme_CTor
func Slice_clone_Enzyme_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_clone_Enzyme(&[]clone.Enzyme{}))
}

//export Slice_clone_Enzyme_len
func Slice_clone_Enzyme_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_clone_Enzyme(handle))
}

//export Slice_clone_Enzyme_elem
func Slice_clone_Enzyme_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_clone_Enzyme(handle)
	return handleFromPtr_clone_Enzyme(&(s[_idx]))
}

//export Slice_clone_Enzyme_subslice
func Slice_clone_Enzyme_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_clone_Enzyme(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_clone_Enzyme(&ss))
}

//export Slice_clone_Enzyme_set
func Slice_clone_Enzyme_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_clone_Enzyme(handle)
	s[_idx] = *ptrFromHandle_clone_Enzyme(_vl)
}

//export Slice_clone_Enzyme_append
func Slice_clone_Enzyme_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_clone_Enzyme(handle)
	*s = append(*s, *ptrFromHandle_clone_Enzyme(_vl))
}

// Converters for implicit pointer handles for type: []clone.Fragment
func ptrFromHandle_Slice_clone_Fragment(h CGoHandle) *[]clone.Fragment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]clone.Fragment")
	if p == nil {
		return nil
	}
	return p.(*[]clone.Fragment)
}
func deptrFromHandle_Slice_clone_Fragment(h CGoHandle) []clone.Fragment {
	p := ptrFromHandle_Slice_clone_Fragment(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_clone_Fragment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]clone.Fragment", p))
}

// --- wrapping slice: []clone.Fragment ---
//
//export Slice_clone_Fragment_CTor
func Slice_clone_Fragment_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_clone_Fragment(&[]clone.Fragment{}))
}

//export Slice_clone_Fragment_len
func Slice_clone_Fragment_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_clone_Fragment(handle))
}

//export Slice_clone_Fragment_elem
func Slice_clone_Fragment_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_clone_Fragment(handle)
	return handleFromPtr_clone_Fragment(&(s[_idx]))
}

//export Slice_clone_Fragment_subslice
func Slice_clone_Fragment_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_clone_Fragment(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_clone_Fragment(&ss))
}

//export Slice_clone_Fragment_set
func Slice_clone_Fragment_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_clone_Fragment(handle)
	s[_idx] = *ptrFromHandle_clone_Fragment(_vl)
}

//export Slice_clone_Fragment_append
func Slice_clone_Fragment_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_clone_Fragment(handle)
	*s = append(*s, *ptrFromHandle_clone_Fragment(_vl))
}

// Converters for non-pointer handles for type: clone.Enzyme
func ptrFromHandle_clone_Enzyme(h CGoHandle) *clone.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clone.Enzyme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Enzyme{})).(*clone.Enzyme)
}
func handleFromPtr_clone_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clone.Enzyme", p))
}

// Converters for non-pointer handles for type: clone.EnzymeManager
func ptrFromHandle_clone_EnzymeManager(h CGoHandle) *clone.EnzymeManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clone.EnzymeManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.EnzymeManager{})).(*clone.EnzymeManager)
}
func handleFromPtr_clone_EnzymeManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clone.EnzymeManager", p))
}

// Converters for non-pointer handles for type: clone.Fragment
func ptrFromHandle_clone_Fragment(h CGoHandle) *clone.Fragment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clone.Fragment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Fragment{})).(*clone.Fragment)
}
func handleFromPtr_clone_Fragment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clone.Fragment", p))
}

// Converters for non-pointer handles for type: clone.Overhang
func ptrFromHandle_clone_Overhang(h CGoHandle) *clone.Overhang {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clone.Overhang")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Overhang{})).(*clone.Overhang)
}
func handleFromPtr_clone_Overhang(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clone.Overhang", p))
}

// Converters for non-pointer handles for type: clone.Part
func ptrFromHandle_clone_Part(h CGoHandle) *clone.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clone.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clone.Part{})).(*clone.Part)
}
func handleFromPtr_clone_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clone.Part", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: clone.Overhang ---
//
//export clone_Overhang_CTor
func clone_Overhang_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_clone_Overhang(&clone.Overhang{}))
}

//export clone_Overhang_Length_Get
func clone_Overhang_Length_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_clone_Overhang(handle)
	return C.longlong(op.Length)
}

//export clone_Overhang_Length_Set
func clone_Overhang_Length_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_clone_Overhang(handle)
	op.Length = int(val)
}

//export clone_Overhang_Position_Get
func clone_Overhang_Position_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_clone_Overhang(handle)
	return C.longlong(op.Position)
}

//export clone_Overhang_Position_Set
func clone_Overhang_Position_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_clone_Overhang(handle)
	op.Position = int(val)
}

//export clone_Overhang_Forward_Get
func clone_Overhang_Forward_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_clone_Overhang(handle)
	return boolGoToPy(op.Forward)
}

//export clone_Overhang_Forward_Set
func clone_Overhang_Forward_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_clone_Overhang(handle)
	op.Forward = boolPyToGo(val)
}

//export clone_Overhang_RecognitionSitePlusSkipLength_Get
func clone_Overhang_RecognitionSitePlusSkipLength_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_clone_Overhang(handle)
	return C.longlong(op.RecognitionSitePlusSkipLength)
}

//export clone_Overhang_RecognitionSitePlusSkipLength_Set
func clone_Overhang_RecognitionSitePlusSkipLength_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_clone_Overhang(handle)
	op.RecognitionSitePlusSkipLength = int(val)
}

// --- wrapping struct: clone.Part ---
//
//export clone_Part_CTor
func clone_Part_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_clone_Part(&clone.Part{}))
}

//export clone_Part_Sequence_Get
func clone_Part_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Part(handle)
	return C.CString(op.Sequence)
}

//export clone_Part_Sequence_Set
func clone_Part_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Part(handle)
	op.Sequence = C.GoString(val)
}

//export clone_Part_Circular_Get
func clone_Part_Circular_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_clone_Part(handle)
	return boolGoToPy(op.Circular)
}

//export clone_Part_Circular_Set
func clone_Part_Circular_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_clone_Part(handle)
	op.Circular = boolPyToGo(val)
}

// --- wrapping struct: clone.Enzyme ---
//
//export clone_Enzyme_CTor
func clone_Enzyme_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_clone_Enzyme(&clone.Enzyme{}))
}

//export clone_Enzyme_Name_Get
func clone_Enzyme_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Enzyme(handle)
	return C.CString(op.Name)
}

//export clone_Enzyme_Name_Set
func clone_Enzyme_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.Name = C.GoString(val)
}

//export clone_Enzyme_RegexpFor_Get
func clone_Enzyme_RegexpFor_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_clone_Enzyme(handle)
	return handleFromPtr_Ptr_regexp_Regexp(op.RegexpFor)
}

//export clone_Enzyme_RegexpFor_Set
func clone_Enzyme_RegexpFor_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.RegexpFor = ptrFromHandle_Ptr_regexp_Regexp(val)
}

//export clone_Enzyme_RegexpRev_Get
func clone_Enzyme_RegexpRev_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_clone_Enzyme(handle)
	return handleFromPtr_Ptr_regexp_Regexp(op.RegexpRev)
}

//export clone_Enzyme_RegexpRev_Set
func clone_Enzyme_RegexpRev_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.RegexpRev = ptrFromHandle_Ptr_regexp_Regexp(val)
}

//export clone_Enzyme_Skip_Get
func clone_Enzyme_Skip_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_clone_Enzyme(handle)
	return C.longlong(op.Skip)
}

//export clone_Enzyme_Skip_Set
func clone_Enzyme_Skip_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.Skip = int(val)
}

//export clone_Enzyme_OverheadLength_Get
func clone_Enzyme_OverheadLength_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_clone_Enzyme(handle)
	return C.longlong(op.OverheadLength)
}

//export clone_Enzyme_OverheadLength_Set
func clone_Enzyme_OverheadLength_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.OverheadLength = int(val)
}

//export clone_Enzyme_RecognitionSite_Get
func clone_Enzyme_RecognitionSite_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Enzyme(handle)
	return C.CString(op.RecognitionSite)
}

//export clone_Enzyme_RecognitionSite_Set
func clone_Enzyme_RecognitionSite_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Enzyme(handle)
	op.RecognitionSite = C.GoString(val)
}

// --- wrapping struct: clone.EnzymeManager ---
//
//export clone_EnzymeManager_CTor
func clone_EnzymeManager_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_clone_EnzymeManager(&clone.EnzymeManager{}))
}

//export clone_EnzymeManager_CutWithEnzymeByName
func clone_EnzymeManager_CutWithEnzymeByName(_handle CGoHandle, part CGoHandle, directional C.char, name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*clone.EnzymeManager")
	if __err != nil {
		return handleFromPtr_Slice_clone_Fragment(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(clone.EnzymeManager{})).(*clone.EnzymeManager).CutWithEnzymeByName(*ptrFromHandle_clone_Part(part), boolPyToGo(directional), C.GoString(name))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_clone_Fragment(nil)
	}
	return handleFromPtr_Slice_clone_Fragment(&cret)
}

//export clone_EnzymeManager_GetEnzymeByName
func clone_EnzymeManager_GetEnzymeByName(_handle CGoHandle, name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*clone.EnzymeManager")
	if __err != nil {
		return handleFromPtr_clone_Enzyme(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(clone.EnzymeManager{})).(*clone.EnzymeManager).GetEnzymeByName(C.GoString(name))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_clone_Enzyme(nil)
	}
	return handleFromPtr_clone_Enzyme(&cret)
}

// --- wrapping struct: clone.Fragment ---
//
//export clone_Fragment_CTor
func clone_Fragment_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_clone_Fragment(&clone.Fragment{}))
}

//export clone_Fragment_Sequence_Get
func clone_Fragment_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Fragment(handle)
	return C.CString(op.Sequence)
}

//export clone_Fragment_Sequence_Set
func clone_Fragment_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Fragment(handle)
	op.Sequence = C.GoString(val)
}

//export clone_Fragment_ForwardOverhang_Get
func clone_Fragment_ForwardOverhang_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Fragment(handle)
	return C.CString(op.ForwardOverhang)
}

//export clone_Fragment_ForwardOverhang_Set
func clone_Fragment_ForwardOverhang_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Fragment(handle)
	op.ForwardOverhang = C.GoString(val)
}

//export clone_Fragment_ReverseOverhang_Get
func clone_Fragment_ReverseOverhang_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_clone_Fragment(handle)
	return C.CString(op.ReverseOverhang)
}

//export clone_Fragment_ReverseOverhang_Set
func clone_Fragment_ReverseOverhang_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_clone_Fragment(handle)
	op.ReverseOverhang = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export clone_NewEnzymeManager
func clone_NewEnzymeManager(enzymes CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := clone.NewEnzymeManager(deptrFromHandle_Slice_clone_Enzyme(enzymes))

	return handleFromPtr_clone_EnzymeManager(&cret)
}

// ---- Functions ---

//export clone_CutWithEnzyme
func clone_CutWithEnzyme(part CGoHandle, directional C.char, enzyme CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := clone.CutWithEnzyme(*ptrFromHandle_clone_Part(part), boolPyToGo(directional), *ptrFromHandle_clone_Enzyme(enzyme))

	return handleFromPtr_Slice_clone_Fragment(&cret)
}

//export clone_GetBaseRestrictionEnzymes
func clone_GetBaseRestrictionEnzymes() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := clone.GetBaseRestrictionEnzymes()

	return handleFromPtr_Slice_clone_Enzyme(&cret)
}

// ---- Package: fold ---

// ---- Types ---

// Converters for pointer handles for type: *fold.Result
func ptrFromHandle_Ptr_fold_Result(h CGoHandle) *fold.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fold.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fold.Result{})).(*fold.Result)
}
func handleFromPtr_Ptr_fold_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fold.Result", p))
}

// Converters for non-pointer handles for type: fold.Result
func ptrFromHandle_fold_Result(h CGoHandle) *fold.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fold.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fold.Result{})).(*fold.Result)
}
func handleFromPtr_fold_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fold.Result", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fold.Result ---
//
//export fold_Result_CTor
func fold_Result_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fold_Result(&fold.Result{}))
}

//export fold_Result_DotBracket
func fold_Result_DotBracket(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fold.Result")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(fold.Result{})).(*fold.Result).DotBracket())

}

//export fold_Result_MinimumFreeEnergy
func fold_Result_MinimumFreeEnergy(_handle CGoHandle) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fold.Result")
	if __err != nil {
		return C.double(0)
	}
	return C.double(gopyh.Embed(vifc, reflect.TypeOf(fold.Result{})).(*fold.Result).MinimumFreeEnergy())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export fold_Zuker
func fold_Zuker(seq *C.char, temp C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fold.Zuker(C.GoString(seq), float64(temp))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_fold_Result(nil)
	}
	return handleFromPtr_fold_Result(&cret)
}

// ---- Functions ---

// ---- Package: io ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: fasta ---

// ---- Types ---

// Converters for pointer handles for type: *fasta.Fasta
func ptrFromHandle_Ptr_fasta_Fasta(h CGoHandle) *fasta.Fasta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fasta.Fasta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fasta.Fasta{})).(*fasta.Fasta)
}
func handleFromPtr_Ptr_fasta_Fasta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fasta.Fasta", p))
}

// Converters for pointer handles for type: *fasta.Parser
func ptrFromHandle_Ptr_fasta_Parser(h CGoHandle) *fasta.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fasta.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser)
}
func handleFromPtr_Ptr_fasta_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fasta.Parser", p))
}

// Converters for implicit pointer handles for type: []fasta.Fasta
func ptrFromHandle_Slice_fasta_Fasta(h CGoHandle) *[]fasta.Fasta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]fasta.Fasta")
	if p == nil {
		return nil
	}
	return p.(*[]fasta.Fasta)
}
func deptrFromHandle_Slice_fasta_Fasta(h CGoHandle) []fasta.Fasta {
	p := ptrFromHandle_Slice_fasta_Fasta(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_fasta_Fasta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]fasta.Fasta", p))
}

// --- wrapping slice: []fasta.Fasta ---
//
//export Slice_fasta_Fasta_CTor
func Slice_fasta_Fasta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_fasta_Fasta(&[]fasta.Fasta{}))
}

//export Slice_fasta_Fasta_len
func Slice_fasta_Fasta_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_fasta_Fasta(handle))
}

//export Slice_fasta_Fasta_elem
func Slice_fasta_Fasta_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_fasta_Fasta(handle)
	return handleFromPtr_fasta_Fasta(&(s[_idx]))
}

//export Slice_fasta_Fasta_subslice
func Slice_fasta_Fasta_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_fasta_Fasta(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_fasta_Fasta(&ss))
}

//export Slice_fasta_Fasta_set
func Slice_fasta_Fasta_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_fasta_Fasta(handle)
	s[_idx] = *ptrFromHandle_fasta_Fasta(_vl)
}

//export Slice_fasta_Fasta_append
func Slice_fasta_Fasta_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_fasta_Fasta(handle)
	*s = append(*s, *ptrFromHandle_fasta_Fasta(_vl))
}

// Converters for non-pointer handles for type: fasta.Fasta
func ptrFromHandle_fasta_Fasta(h CGoHandle) *fasta.Fasta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fasta.Fasta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fasta.Fasta{})).(*fasta.Fasta)
}
func handleFromPtr_fasta_Fasta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fasta.Fasta", p))
}

// Converters for non-pointer handles for type: fasta.Parser
func ptrFromHandle_fasta_Parser(h CGoHandle) *fasta.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fasta.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser)
}
func handleFromPtr_fasta_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fasta.Parser", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fasta.Fasta ---
//
//export fasta_Fasta_CTor
func fasta_Fasta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fasta_Fasta(&fasta.Fasta{}))
}

//export fasta_Fasta_Name_Get
func fasta_Fasta_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fasta_Fasta(handle)
	return C.CString(op.Name)
}

//export fasta_Fasta_Name_Set
func fasta_Fasta_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fasta_Fasta(handle)
	op.Name = C.GoString(val)
}

//export fasta_Fasta_Sequence_Get
func fasta_Fasta_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fasta_Fasta(handle)
	return C.CString(op.Sequence)
}

//export fasta_Fasta_Sequence_Set
func fasta_Fasta_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fasta_Fasta(handle)
	op.Sequence = C.GoString(val)
}

// --- wrapping struct: fasta.Parser ---
//
//export fasta_Parser_CTor
func fasta_Parser_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fasta_Parser(&fasta.Parser{}))
}

//export fasta_Parser_ParseAll
func fasta_Parser_ParseAll(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fasta.Parser")
	if __err != nil {
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser).ParseAll()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	return handleFromPtr_Slice_fasta_Fasta(&cret)
}

//export fasta_Parser_ParseN
func fasta_Parser_ParseN(_handle CGoHandle, maxSequences C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fasta.Parser")
	if __err != nil {
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser).ParseN(int(maxSequences))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	return handleFromPtr_Slice_fasta_Fasta(&cret)
}

//export fasta_Parser_Reset
func fasta_Parser_Reset(_handle CGoHandle, r CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fasta.Parser")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser).Reset(ptrFromHandle_io_Reader(r))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(fasta.Parser{})).(*fasta.Parser).Reset(ptrFromHandle_io_Reader(r))
	}
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export fasta_NewParser
func fasta_NewParser(r CGoHandle, maxLineSize C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_fasta_Parser(fasta.NewParser(ptrFromHandle_io_Reader(r), int(maxLineSize)))

}

// ---- Functions ---

//export fasta_Build
func fasta_Build(fastas CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fasta.Build(deptrFromHandle_Slice_fasta_Fasta(fastas))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export fasta_Parse
func fasta_Parse(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fasta.Parse(ptrFromHandle_io_Reader(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	return handleFromPtr_Slice_fasta_Fasta(&cret)
}

//export fasta_Read
func fasta_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fasta.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	return handleFromPtr_Slice_fasta_Fasta(&cret)
}

//export fasta_ReadGz
func fasta_ReadGz(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fasta.ReadGz(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fasta_Fasta(nil)
	}
	return handleFromPtr_Slice_fasta_Fasta(&cret)
}

//export fasta_Write
func fasta_Write(fastas CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = fasta.Write(deptrFromHandle_Slice_fasta_Fasta(fastas), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Package: fastq ---

// ---- Types ---

// Converters for pointer handles for type: *fastq.Fastq
func ptrFromHandle_Ptr_fastq_Fastq(h CGoHandle) *fastq.Fastq {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fastq.Fastq")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fastq.Fastq{})).(*fastq.Fastq)
}
func handleFromPtr_Ptr_fastq_Fastq(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fastq.Fastq", p))
}

// Converters for pointer handles for type: *fastq.Parser
func ptrFromHandle_Ptr_fastq_Parser(h CGoHandle) *fastq.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fastq.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser)
}
func handleFromPtr_Ptr_fastq_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fastq.Parser", p))
}

// Converters for implicit pointer handles for type: []fastq.Fastq
func ptrFromHandle_Slice_fastq_Fastq(h CGoHandle) *[]fastq.Fastq {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]fastq.Fastq")
	if p == nil {
		return nil
	}
	return p.(*[]fastq.Fastq)
}
func deptrFromHandle_Slice_fastq_Fastq(h CGoHandle) []fastq.Fastq {
	p := ptrFromHandle_Slice_fastq_Fastq(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_fastq_Fastq(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]fastq.Fastq", p))
}

// --- wrapping slice: []fastq.Fastq ---
//
//export Slice_fastq_Fastq_CTor
func Slice_fastq_Fastq_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_fastq_Fastq(&[]fastq.Fastq{}))
}

//export Slice_fastq_Fastq_len
func Slice_fastq_Fastq_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_fastq_Fastq(handle))
}

//export Slice_fastq_Fastq_elem
func Slice_fastq_Fastq_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_fastq_Fastq(handle)
	return handleFromPtr_fastq_Fastq(&(s[_idx]))
}

//export Slice_fastq_Fastq_subslice
func Slice_fastq_Fastq_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_fastq_Fastq(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_fastq_Fastq(&ss))
}

//export Slice_fastq_Fastq_set
func Slice_fastq_Fastq_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_fastq_Fastq(handle)
	s[_idx] = *ptrFromHandle_fastq_Fastq(_vl)
}

//export Slice_fastq_Fastq_append
func Slice_fastq_Fastq_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_fastq_Fastq(handle)
	*s = append(*s, *ptrFromHandle_fastq_Fastq(_vl))
}

// Converters for non-pointer handles for type: fastq.Fastq
func ptrFromHandle_fastq_Fastq(h CGoHandle) *fastq.Fastq {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fastq.Fastq")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fastq.Fastq{})).(*fastq.Fastq)
}
func handleFromPtr_fastq_Fastq(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fastq.Fastq", p))
}

// Converters for non-pointer handles for type: fastq.Parser
func ptrFromHandle_fastq_Parser(h CGoHandle) *fastq.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fastq.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser)
}
func handleFromPtr_fastq_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fastq.Parser", p))
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fastq.Fastq ---
//
//export fastq_Fastq_CTor
func fastq_Fastq_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fastq_Fastq(&fastq.Fastq{}))
}

//export fastq_Fastq_Identifier_Get
func fastq_Fastq_Identifier_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fastq_Fastq(handle)
	return C.CString(op.Identifier)
}

//export fastq_Fastq_Identifier_Set
func fastq_Fastq_Identifier_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fastq_Fastq(handle)
	op.Identifier = C.GoString(val)
}

//export fastq_Fastq_Optionals_Get
func fastq_Fastq_Optionals_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fastq_Fastq(handle)
	return handleFromPtr_Map_string_string(&op.Optionals)
}

//export fastq_Fastq_Optionals_Set
func fastq_Fastq_Optionals_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fastq_Fastq(handle)
	op.Optionals = deptrFromHandle_Map_string_string(val)
}

//export fastq_Fastq_Sequence_Get
func fastq_Fastq_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fastq_Fastq(handle)
	return C.CString(op.Sequence)
}

//export fastq_Fastq_Sequence_Set
func fastq_Fastq_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fastq_Fastq(handle)
	op.Sequence = C.GoString(val)
}

//export fastq_Fastq_Quality_Get
func fastq_Fastq_Quality_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fastq_Fastq(handle)
	return C.CString(op.Quality)
}

//export fastq_Fastq_Quality_Set
func fastq_Fastq_Quality_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fastq_Fastq(handle)
	op.Quality = C.GoString(val)
}

// --- wrapping struct: fastq.Parser ---
//
//export fastq_Parser_CTor
func fastq_Parser_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fastq_Parser(&fastq.Parser{}))
}

//export fastq_Parser_ParseAll
func fastq_Parser_ParseAll(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fastq.Parser")
	if __err != nil {
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser).ParseAll()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	return handleFromPtr_Slice_fastq_Fastq(&cret)
}

//export fastq_Parser_ParseN
func fastq_Parser_ParseN(_handle CGoHandle, maxSequences C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fastq.Parser")
	if __err != nil {
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser).ParseN(int(maxSequences))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	return handleFromPtr_Slice_fastq_Fastq(&cret)
}

//export fastq_Parser_Reset
func fastq_Parser_Reset(_handle CGoHandle, r CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fastq.Parser")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser).Reset(ptrFromHandle_io_Reader(r))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(fastq.Parser{})).(*fastq.Parser).Reset(ptrFromHandle_io_Reader(r))
	}
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export fastq_NewParser
func fastq_NewParser(r CGoHandle, maxLineSize C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_fastq_Parser(fastq.NewParser(ptrFromHandle_io_Reader(r), int(maxLineSize)))

}

// ---- Functions ---

//export fastq_Parse
func fastq_Parse(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fastq.Parse(ptrFromHandle_io_Reader(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	return handleFromPtr_Slice_fastq_Fastq(&cret)
}

//export fastq_Read
func fastq_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fastq.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	return handleFromPtr_Slice_fastq_Fastq(&cret)
}

//export fastq_ReadGz
func fastq_ReadGz(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fastq.ReadGz(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_fastq_Fastq(nil)
	}
	return handleFromPtr_Slice_fastq_Fastq(&cret)
}

//export fastq_Write
func fastq_Write(fastqs CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = fastq.Write(deptrFromHandle_Slice_fastq_Fastq(fastqs), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export fastq_Build
func fastq_Build(fastqs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := fastq.Build(deptrFromHandle_Slice_fastq_Fastq(fastqs))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

// ---- Package: genbank ---

// ---- Types ---

// Converters for pointer handles for type: *genbank.BaseCount
func ptrFromHandle_Ptr_genbank_BaseCount(h CGoHandle) *genbank.BaseCount {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.BaseCount")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.BaseCount{})).(*genbank.BaseCount)
}
func handleFromPtr_Ptr_genbank_BaseCount(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.BaseCount", p))
}

// Converters for pointer handles for type: *genbank.Feature
func ptrFromHandle_Ptr_genbank_Feature(h CGoHandle) *genbank.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Feature{})).(*genbank.Feature)
}
func handleFromPtr_Ptr_genbank_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Feature", p))
}

// Converters for pointer handles for type: *genbank.Genbank
func ptrFromHandle_Ptr_genbank_Genbank(h CGoHandle) *genbank.Genbank {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Genbank")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Genbank{})).(*genbank.Genbank)
}
func handleFromPtr_Ptr_genbank_Genbank(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Genbank", p))
}

// Converters for pointer handles for type: *genbank.Location
func ptrFromHandle_Ptr_genbank_Location(h CGoHandle) *genbank.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Location{})).(*genbank.Location)
}
func handleFromPtr_Ptr_genbank_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Location", p))
}

// Converters for pointer handles for type: *genbank.Locus
func ptrFromHandle_Ptr_genbank_Locus(h CGoHandle) *genbank.Locus {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Locus")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Locus{})).(*genbank.Locus)
}
func handleFromPtr_Ptr_genbank_Locus(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Locus", p))
}

// Converters for pointer handles for type: *genbank.Meta
func ptrFromHandle_Ptr_genbank_Meta(h CGoHandle) *genbank.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Meta{})).(*genbank.Meta)
}
func handleFromPtr_Ptr_genbank_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Meta", p))
}

// Converters for pointer handles for type: *genbank.Reference
func ptrFromHandle_Ptr_genbank_Reference(h CGoHandle) *genbank.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*genbank.Reference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Reference{})).(*genbank.Reference)
}
func handleFromPtr_Ptr_genbank_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*genbank.Reference", p))
}

// Converters for implicit pointer handles for type: []genbank.BaseCount
func ptrFromHandle_Slice_genbank_BaseCount(h CGoHandle) *[]genbank.BaseCount {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]genbank.BaseCount")
	if p == nil {
		return nil
	}
	return p.(*[]genbank.BaseCount)
}
func deptrFromHandle_Slice_genbank_BaseCount(h CGoHandle) []genbank.BaseCount {
	p := ptrFromHandle_Slice_genbank_BaseCount(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_genbank_BaseCount(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]genbank.BaseCount", p))
}

// --- wrapping slice: []genbank.BaseCount ---
//
//export Slice_genbank_BaseCount_CTor
func Slice_genbank_BaseCount_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_genbank_BaseCount(&[]genbank.BaseCount{}))
}

//export Slice_genbank_BaseCount_len
func Slice_genbank_BaseCount_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_genbank_BaseCount(handle))
}

//export Slice_genbank_BaseCount_elem
func Slice_genbank_BaseCount_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_BaseCount(handle)
	return handleFromPtr_genbank_BaseCount(&(s[_idx]))
}

//export Slice_genbank_BaseCount_subslice
func Slice_genbank_BaseCount_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_BaseCount(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_genbank_BaseCount(&ss))
}

//export Slice_genbank_BaseCount_set
func Slice_genbank_BaseCount_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_genbank_BaseCount(handle)
	s[_idx] = *ptrFromHandle_genbank_BaseCount(_vl)
}

//export Slice_genbank_BaseCount_append
func Slice_genbank_BaseCount_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_genbank_BaseCount(handle)
	*s = append(*s, *ptrFromHandle_genbank_BaseCount(_vl))
}

// Converters for implicit pointer handles for type: []genbank.Feature
func ptrFromHandle_Slice_genbank_Feature(h CGoHandle) *[]genbank.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]genbank.Feature")
	if p == nil {
		return nil
	}
	return p.(*[]genbank.Feature)
}
func deptrFromHandle_Slice_genbank_Feature(h CGoHandle) []genbank.Feature {
	p := ptrFromHandle_Slice_genbank_Feature(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_genbank_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]genbank.Feature", p))
}

// --- wrapping slice: []genbank.Feature ---
//
//export Slice_genbank_Feature_CTor
func Slice_genbank_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_genbank_Feature(&[]genbank.Feature{}))
}

//export Slice_genbank_Feature_len
func Slice_genbank_Feature_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_genbank_Feature(handle))
}

//export Slice_genbank_Feature_elem
func Slice_genbank_Feature_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Feature(handle)
	return handleFromPtr_genbank_Feature(&(s[_idx]))
}

//export Slice_genbank_Feature_subslice
func Slice_genbank_Feature_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Feature(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_genbank_Feature(&ss))
}

//export Slice_genbank_Feature_set
func Slice_genbank_Feature_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_genbank_Feature(handle)
	s[_idx] = *ptrFromHandle_genbank_Feature(_vl)
}

//export Slice_genbank_Feature_append
func Slice_genbank_Feature_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_genbank_Feature(handle)
	*s = append(*s, *ptrFromHandle_genbank_Feature(_vl))
}

// Converters for implicit pointer handles for type: []genbank.Genbank
func ptrFromHandle_Slice_genbank_Genbank(h CGoHandle) *[]genbank.Genbank {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]genbank.Genbank")
	if p == nil {
		return nil
	}
	return p.(*[]genbank.Genbank)
}
func deptrFromHandle_Slice_genbank_Genbank(h CGoHandle) []genbank.Genbank {
	p := ptrFromHandle_Slice_genbank_Genbank(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_genbank_Genbank(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]genbank.Genbank", p))
}

// --- wrapping slice: []genbank.Genbank ---
//
//export Slice_genbank_Genbank_CTor
func Slice_genbank_Genbank_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_genbank_Genbank(&[]genbank.Genbank{}))
}

//export Slice_genbank_Genbank_len
func Slice_genbank_Genbank_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_genbank_Genbank(handle))
}

//export Slice_genbank_Genbank_elem
func Slice_genbank_Genbank_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Genbank(handle)
	return handleFromPtr_genbank_Genbank(&(s[_idx]))
}

//export Slice_genbank_Genbank_subslice
func Slice_genbank_Genbank_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Genbank(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_genbank_Genbank(&ss))
}

//export Slice_genbank_Genbank_set
func Slice_genbank_Genbank_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_genbank_Genbank(handle)
	s[_idx] = *ptrFromHandle_genbank_Genbank(_vl)
}

//export Slice_genbank_Genbank_append
func Slice_genbank_Genbank_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_genbank_Genbank(handle)
	*s = append(*s, *ptrFromHandle_genbank_Genbank(_vl))
}

// Converters for implicit pointer handles for type: []genbank.Location
func ptrFromHandle_Slice_genbank_Location(h CGoHandle) *[]genbank.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]genbank.Location")
	if p == nil {
		return nil
	}
	return p.(*[]genbank.Location)
}
func deptrFromHandle_Slice_genbank_Location(h CGoHandle) []genbank.Location {
	p := ptrFromHandle_Slice_genbank_Location(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_genbank_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]genbank.Location", p))
}

// --- wrapping slice: []genbank.Location ---
//
//export Slice_genbank_Location_CTor
func Slice_genbank_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_genbank_Location(&[]genbank.Location{}))
}

//export Slice_genbank_Location_len
func Slice_genbank_Location_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_genbank_Location(handle))
}

//export Slice_genbank_Location_elem
func Slice_genbank_Location_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Location(handle)
	return handleFromPtr_genbank_Location(&(s[_idx]))
}

//export Slice_genbank_Location_subslice
func Slice_genbank_Location_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Location(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_genbank_Location(&ss))
}

//export Slice_genbank_Location_set
func Slice_genbank_Location_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_genbank_Location(handle)
	s[_idx] = *ptrFromHandle_genbank_Location(_vl)
}

//export Slice_genbank_Location_append
func Slice_genbank_Location_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_genbank_Location(handle)
	*s = append(*s, *ptrFromHandle_genbank_Location(_vl))
}

// Converters for implicit pointer handles for type: []genbank.Reference
func ptrFromHandle_Slice_genbank_Reference(h CGoHandle) *[]genbank.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]genbank.Reference")
	if p == nil {
		return nil
	}
	return p.(*[]genbank.Reference)
}
func deptrFromHandle_Slice_genbank_Reference(h CGoHandle) []genbank.Reference {
	p := ptrFromHandle_Slice_genbank_Reference(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_genbank_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]genbank.Reference", p))
}

// --- wrapping slice: []genbank.Reference ---
//
//export Slice_genbank_Reference_CTor
func Slice_genbank_Reference_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_genbank_Reference(&[]genbank.Reference{}))
}

//export Slice_genbank_Reference_len
func Slice_genbank_Reference_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_genbank_Reference(handle))
}

//export Slice_genbank_Reference_elem
func Slice_genbank_Reference_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Reference(handle)
	return handleFromPtr_genbank_Reference(&(s[_idx]))
}

//export Slice_genbank_Reference_subslice
func Slice_genbank_Reference_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_genbank_Reference(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_genbank_Reference(&ss))
}

//export Slice_genbank_Reference_set
func Slice_genbank_Reference_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_genbank_Reference(handle)
	s[_idx] = *ptrFromHandle_genbank_Reference(_vl)
}

//export Slice_genbank_Reference_append
func Slice_genbank_Reference_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_genbank_Reference(handle)
	*s = append(*s, *ptrFromHandle_genbank_Reference(_vl))
}

// Converters for non-pointer handles for type: genbank.BaseCount
func ptrFromHandle_genbank_BaseCount(h CGoHandle) *genbank.BaseCount {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.BaseCount")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.BaseCount{})).(*genbank.BaseCount)
}
func handleFromPtr_genbank_BaseCount(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.BaseCount", p))
}

// Converters for non-pointer handles for type: genbank.Feature
func ptrFromHandle_genbank_Feature(h CGoHandle) *genbank.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Feature{})).(*genbank.Feature)
}
func handleFromPtr_genbank_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Feature", p))
}

// Converters for non-pointer handles for type: genbank.Genbank
func ptrFromHandle_genbank_Genbank(h CGoHandle) *genbank.Genbank {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Genbank")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Genbank{})).(*genbank.Genbank)
}
func handleFromPtr_genbank_Genbank(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Genbank", p))
}

// Converters for non-pointer handles for type: genbank.Location
func ptrFromHandle_genbank_Location(h CGoHandle) *genbank.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Location{})).(*genbank.Location)
}
func handleFromPtr_genbank_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Location", p))
}

// Converters for non-pointer handles for type: genbank.Locus
func ptrFromHandle_genbank_Locus(h CGoHandle) *genbank.Locus {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Locus")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Locus{})).(*genbank.Locus)
}
func handleFromPtr_genbank_Locus(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Locus", p))
}

// Converters for non-pointer handles for type: genbank.Meta
func ptrFromHandle_genbank_Meta(h CGoHandle) *genbank.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Meta{})).(*genbank.Meta)
}
func handleFromPtr_genbank_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Meta", p))
}

// Converters for non-pointer handles for type: genbank.Reference
func ptrFromHandle_genbank_Reference(h CGoHandle) *genbank.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "genbank.Reference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(genbank.Reference{})).(*genbank.Reference)
}
func handleFromPtr_genbank_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("genbank.Reference", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: genbank.Meta ---
//
//export genbank_Meta_CTor
func genbank_Meta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Meta(&genbank.Meta{}))
}

//export genbank_Meta_Date_Get
func genbank_Meta_Date_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Date)
}

//export genbank_Meta_Date_Set
func genbank_Meta_Date_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Date = C.GoString(val)
}

//export genbank_Meta_Definition_Get
func genbank_Meta_Definition_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Definition)
}

//export genbank_Meta_Definition_Set
func genbank_Meta_Definition_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Definition = C.GoString(val)
}

//export genbank_Meta_Accession_Get
func genbank_Meta_Accession_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Accession)
}

//export genbank_Meta_Accession_Set
func genbank_Meta_Accession_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Accession = C.GoString(val)
}

//export genbank_Meta_Version_Get
func genbank_Meta_Version_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Version)
}

//export genbank_Meta_Version_Set
func genbank_Meta_Version_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Version = C.GoString(val)
}

//export genbank_Meta_Keywords_Get
func genbank_Meta_Keywords_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Keywords)
}

//export genbank_Meta_Keywords_Set
func genbank_Meta_Keywords_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Keywords = C.GoString(val)
}

//export genbank_Meta_Organism_Get
func genbank_Meta_Organism_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Organism)
}

//export genbank_Meta_Organism_Set
func genbank_Meta_Organism_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Organism = C.GoString(val)
}

//export genbank_Meta_Source_Get
func genbank_Meta_Source_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Source)
}

//export genbank_Meta_Source_Set
func genbank_Meta_Source_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Source = C.GoString(val)
}

//export genbank_Meta_Taxonomy_Get
func genbank_Meta_Taxonomy_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Meta(handle)
	return handleFromPtr_Slice_string(&op.Taxonomy)
}

//export genbank_Meta_Taxonomy_Set
func genbank_Meta_Taxonomy_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Taxonomy = deptrFromHandle_Slice_string(val)
}

//export genbank_Meta_Origin_Get
func genbank_Meta_Origin_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Origin)
}

//export genbank_Meta_Origin_Set
func genbank_Meta_Origin_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Origin = C.GoString(val)
}

//export genbank_Meta_Locus_Get
func genbank_Meta_Locus_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Meta(handle)
	return handleFromPtr_genbank_Locus(&op.Locus)
}

//export genbank_Meta_Locus_Set
func genbank_Meta_Locus_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Locus = *ptrFromHandle_genbank_Locus(val)
}

//export genbank_Meta_References_Get
func genbank_Meta_References_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Meta(handle)
	return handleFromPtr_Slice_genbank_Reference(&op.References)
}

//export genbank_Meta_References_Set
func genbank_Meta_References_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.References = deptrFromHandle_Slice_genbank_Reference(val)
}

//export genbank_Meta_BaseCount_Get
func genbank_Meta_BaseCount_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Meta(handle)
	return handleFromPtr_Slice_genbank_BaseCount(&op.BaseCount)
}

//export genbank_Meta_BaseCount_Set
func genbank_Meta_BaseCount_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.BaseCount = deptrFromHandle_Slice_genbank_BaseCount(val)
}

//export genbank_Meta_Other_Get
func genbank_Meta_Other_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Meta(handle)
	return handleFromPtr_Map_string_string(&op.Other)
}

//export genbank_Meta_Other_Set
func genbank_Meta_Other_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Other = deptrFromHandle_Map_string_string(val)
}

//export genbank_Meta_Name_Get
func genbank_Meta_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.Name)
}

//export genbank_Meta_Name_Set
func genbank_Meta_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.Name = C.GoString(val)
}

//export genbank_Meta_SequenceHash_Get
func genbank_Meta_SequenceHash_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.SequenceHash)
}

//export genbank_Meta_SequenceHash_Set
func genbank_Meta_SequenceHash_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.SequenceHash = C.GoString(val)
}

//export genbank_Meta_SequenceHashFunction_Get
func genbank_Meta_SequenceHashFunction_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Meta(handle)
	return C.CString(op.SequenceHashFunction)
}

//export genbank_Meta_SequenceHashFunction_Set
func genbank_Meta_SequenceHashFunction_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Meta(handle)
	op.SequenceHashFunction = C.GoString(val)
}

// --- wrapping struct: genbank.Reference ---
//
//export genbank_Reference_CTor
func genbank_Reference_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Reference(&genbank.Reference{}))
}

//export genbank_Reference_Authors_Get
func genbank_Reference_Authors_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Authors)
}

//export genbank_Reference_Authors_Set
func genbank_Reference_Authors_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Authors = C.GoString(val)
}

//export genbank_Reference_Title_Get
func genbank_Reference_Title_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Title)
}

//export genbank_Reference_Title_Set
func genbank_Reference_Title_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Title = C.GoString(val)
}

//export genbank_Reference_Journal_Get
func genbank_Reference_Journal_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Journal)
}

//export genbank_Reference_Journal_Set
func genbank_Reference_Journal_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Journal = C.GoString(val)
}

//export genbank_Reference_PubMed_Get
func genbank_Reference_PubMed_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.PubMed)
}

//export genbank_Reference_PubMed_Set
func genbank_Reference_PubMed_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.PubMed = C.GoString(val)
}

//export genbank_Reference_Remark_Get
func genbank_Reference_Remark_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Remark)
}

//export genbank_Reference_Remark_Set
func genbank_Reference_Remark_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Remark = C.GoString(val)
}

//export genbank_Reference_Range_Get
func genbank_Reference_Range_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Range)
}

//export genbank_Reference_Range_Set
func genbank_Reference_Range_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Range = C.GoString(val)
}

//export genbank_Reference_Consortium_Get
func genbank_Reference_Consortium_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Reference(handle)
	return C.CString(op.Consortium)
}

//export genbank_Reference_Consortium_Set
func genbank_Reference_Consortium_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Reference(handle)
	op.Consortium = C.GoString(val)
}

// --- wrapping struct: genbank.BaseCount ---
//
//export genbank_BaseCount_CTor
func genbank_BaseCount_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_BaseCount(&genbank.BaseCount{}))
}

//export genbank_BaseCount_Base_Get
func genbank_BaseCount_Base_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_BaseCount(handle)
	return C.CString(op.Base)
}

//export genbank_BaseCount_Base_Set
func genbank_BaseCount_Base_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_BaseCount(handle)
	op.Base = C.GoString(val)
}

//export genbank_BaseCount_Count_Get
func genbank_BaseCount_Count_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_genbank_BaseCount(handle)
	return C.longlong(op.Count)
}

//export genbank_BaseCount_Count_Set
func genbank_BaseCount_Count_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_genbank_BaseCount(handle)
	op.Count = int(val)
}

// --- wrapping struct: genbank.Feature ---
//
//export genbank_Feature_CTor
func genbank_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Feature(&genbank.Feature{}))
}

//export genbank_Feature_Type_Get
func genbank_Feature_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Feature(handle)
	return C.CString(op.Type)
}

//export genbank_Feature_Type_Set
func genbank_Feature_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.Type = C.GoString(val)
}

//export genbank_Feature_Description_Get
func genbank_Feature_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Feature(handle)
	return C.CString(op.Description)
}

//export genbank_Feature_Description_Set
func genbank_Feature_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.Description = C.GoString(val)
}

//export genbank_Feature_Attributes_Get
func genbank_Feature_Attributes_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Feature(handle)
	return handleFromPtr_Map_string_string(&op.Attributes)
}

//export genbank_Feature_Attributes_Set
func genbank_Feature_Attributes_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.Attributes = deptrFromHandle_Map_string_string(val)
}

//export genbank_Feature_SequenceHash_Get
func genbank_Feature_SequenceHash_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Feature(handle)
	return C.CString(op.SequenceHash)
}

//export genbank_Feature_SequenceHash_Set
func genbank_Feature_SequenceHash_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.SequenceHash = C.GoString(val)
}

//export genbank_Feature_SequenceHashFunction_Get
func genbank_Feature_SequenceHashFunction_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Feature(handle)
	return C.CString(op.SequenceHashFunction)
}

//export genbank_Feature_SequenceHashFunction_Set
func genbank_Feature_SequenceHashFunction_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.SequenceHashFunction = C.GoString(val)
}

//export genbank_Feature_Sequence_Get
func genbank_Feature_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Feature(handle)
	return C.CString(op.Sequence)
}

//export genbank_Feature_Sequence_Set
func genbank_Feature_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.Sequence = C.GoString(val)
}

//export genbank_Feature_Location_Get
func genbank_Feature_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Feature(handle)
	return handleFromPtr_genbank_Location(&op.Location)
}

//export genbank_Feature_Location_Set
func genbank_Feature_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.Location = *ptrFromHandle_genbank_Location(val)
}

//export genbank_Feature_ParentSequence_Get
func genbank_Feature_ParentSequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Feature(handle)
	return handleFromPtr_Ptr_genbank_Genbank(op.ParentSequence)
}

//export genbank_Feature_ParentSequence_Set
func genbank_Feature_ParentSequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Feature(handle)
	op.ParentSequence = ptrFromHandle_Ptr_genbank_Genbank(val)
}

//export genbank_Feature_GetSequence
func genbank_Feature_GetSequence(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*genbank.Feature")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(genbank.Feature{})).(*genbank.Feature).GetSequence()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// --- wrapping struct: genbank.Genbank ---
//
//export genbank_Genbank_CTor
func genbank_Genbank_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Genbank(&genbank.Genbank{}))
}

//export genbank_Genbank_Meta_Get
func genbank_Genbank_Meta_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Genbank(handle)
	return handleFromPtr_genbank_Meta(&op.Meta)
}

//export genbank_Genbank_Meta_Set
func genbank_Genbank_Meta_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Genbank(handle)
	op.Meta = *ptrFromHandle_genbank_Meta(val)
}

//export genbank_Genbank_Features_Get
func genbank_Genbank_Features_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Genbank(handle)
	return handleFromPtr_Slice_genbank_Feature(&op.Features)
}

//export genbank_Genbank_Features_Set
func genbank_Genbank_Features_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Genbank(handle)
	op.Features = deptrFromHandle_Slice_genbank_Feature(val)
}

//export genbank_Genbank_Sequence_Get
func genbank_Genbank_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Genbank(handle)
	return C.CString(op.Sequence)
}

//export genbank_Genbank_Sequence_Set
func genbank_Genbank_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Genbank(handle)
	op.Sequence = C.GoString(val)
}

//export genbank_Genbank_AddFeature
func genbank_Genbank_AddFeature(_handle CGoHandle, feature CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*genbank.Genbank")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(genbank.Genbank{})).(*genbank.Genbank).AddFeature(ptrFromHandle_Ptr_genbank_Feature(feature))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: genbank.Location ---
//
//export genbank_Location_CTor
func genbank_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Location(&genbank.Location{}))
}

//export genbank_Location_Start_Get
func genbank_Location_Start_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_genbank_Location(handle)
	return C.longlong(op.Start)
}

//export genbank_Location_Start_Set
func genbank_Location_Start_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_genbank_Location(handle)
	op.Start = int(val)
}

//export genbank_Location_End_Get
func genbank_Location_End_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_genbank_Location(handle)
	return C.longlong(op.End)
}

//export genbank_Location_End_Set
func genbank_Location_End_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_genbank_Location(handle)
	op.End = int(val)
}

//export genbank_Location_Complement_Get
func genbank_Location_Complement_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_genbank_Location(handle)
	return boolGoToPy(op.Complement)
}

//export genbank_Location_Complement_Set
func genbank_Location_Complement_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_genbank_Location(handle)
	op.Complement = boolPyToGo(val)
}

//export genbank_Location_Join_Get
func genbank_Location_Join_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_genbank_Location(handle)
	return boolGoToPy(op.Join)
}

//export genbank_Location_Join_Set
func genbank_Location_Join_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_genbank_Location(handle)
	op.Join = boolPyToGo(val)
}

//export genbank_Location_FivePrimePartial_Get
func genbank_Location_FivePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_genbank_Location(handle)
	return boolGoToPy(op.FivePrimePartial)
}

//export genbank_Location_FivePrimePartial_Set
func genbank_Location_FivePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_genbank_Location(handle)
	op.FivePrimePartial = boolPyToGo(val)
}

//export genbank_Location_ThreePrimePartial_Get
func genbank_Location_ThreePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_genbank_Location(handle)
	return boolGoToPy(op.ThreePrimePartial)
}

//export genbank_Location_ThreePrimePartial_Set
func genbank_Location_ThreePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_genbank_Location(handle)
	op.ThreePrimePartial = boolPyToGo(val)
}

//export genbank_Location_GbkLocationString_Get
func genbank_Location_GbkLocationString_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Location(handle)
	return C.CString(op.GbkLocationString)
}

//export genbank_Location_GbkLocationString_Set
func genbank_Location_GbkLocationString_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Location(handle)
	op.GbkLocationString = C.GoString(val)
}

//export genbank_Location_SubLocations_Get
func genbank_Location_SubLocations_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_genbank_Location(handle)
	return handleFromPtr_Slice_genbank_Location(&op.SubLocations)
}

//export genbank_Location_SubLocations_Set
func genbank_Location_SubLocations_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_genbank_Location(handle)
	op.SubLocations = deptrFromHandle_Slice_genbank_Location(val)
}

// --- wrapping struct: genbank.Locus ---
//
//export genbank_Locus_CTor
func genbank_Locus_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_genbank_Locus(&genbank.Locus{}))
}

//export genbank_Locus_Name_Get
func genbank_Locus_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.Name)
}

//export genbank_Locus_Name_Set
func genbank_Locus_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.Name = C.GoString(val)
}

//export genbank_Locus_SequenceLength_Get
func genbank_Locus_SequenceLength_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.SequenceLength)
}

//export genbank_Locus_SequenceLength_Set
func genbank_Locus_SequenceLength_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.SequenceLength = C.GoString(val)
}

//export genbank_Locus_MoleculeType_Get
func genbank_Locus_MoleculeType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.MoleculeType)
}

//export genbank_Locus_MoleculeType_Set
func genbank_Locus_MoleculeType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.MoleculeType = C.GoString(val)
}

//export genbank_Locus_GenbankDivision_Get
func genbank_Locus_GenbankDivision_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.GenbankDivision)
}

//export genbank_Locus_GenbankDivision_Set
func genbank_Locus_GenbankDivision_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.GenbankDivision = C.GoString(val)
}

//export genbank_Locus_ModificationDate_Get
func genbank_Locus_ModificationDate_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.ModificationDate)
}

//export genbank_Locus_ModificationDate_Set
func genbank_Locus_ModificationDate_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.ModificationDate = C.GoString(val)
}

//export genbank_Locus_SequenceCoding_Get
func genbank_Locus_SequenceCoding_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return C.CString(op.SequenceCoding)
}

//export genbank_Locus_SequenceCoding_Set
func genbank_Locus_SequenceCoding_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.SequenceCoding = C.GoString(val)
}

//export genbank_Locus_Circular_Get
func genbank_Locus_Circular_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_genbank_Locus(handle)
	return boolGoToPy(op.Circular)
}

//export genbank_Locus_Circular_Set
func genbank_Locus_Circular_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_genbank_Locus(handle)
	op.Circular = boolPyToGo(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export genbank_Parse
func genbank_Parse(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.Parse(ptrFromHandle_io_Reader(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_genbank_Genbank(nil)
	}
	return handleFromPtr_genbank_Genbank(&cret)
}

//export genbank_Read
func genbank_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_genbank_Genbank(nil)
	}
	return handleFromPtr_genbank_Genbank(&cret)
}

// ---- Functions ---

//export genbank_BuildFeatureString
func genbank_BuildFeatureString(feature CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(genbank.BuildFeatureString(*ptrFromHandle_genbank_Feature(feature)))

}

//export genbank_BuildLocationString
func genbank_BuildLocationString(location CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(genbank.BuildLocationString(*ptrFromHandle_genbank_Location(location)))

}

//export genbank_BuildMulti
func genbank_BuildMulti(sequences CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.BuildMulti(deptrFromHandle_Slice_genbank_Genbank(sequences))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export genbank_ReadMultiNth
func genbank_ReadMultiNth(path *C.char, count C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.ReadMultiNth(C.GoString(path), int(count))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_genbank_Genbank(nil)
	}
	return handleFromPtr_Slice_genbank_Genbank(&cret)
}

//export genbank_Write
func genbank_Write(sequences CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = genbank.Write(*ptrFromHandle_genbank_Genbank(sequences), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export genbank_WriteMulti
func genbank_WriteMulti(sequences CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = genbank.WriteMulti(deptrFromHandle_Slice_genbank_Genbank(sequences), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export genbank_Build
func genbank_Build(gbk CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.Build(*ptrFromHandle_genbank_Genbank(gbk))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export genbank_ParseMulti
func genbank_ParseMulti(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.ParseMulti(ptrFromHandle_io_Reader(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_genbank_Genbank(nil)
	}
	return handleFromPtr_Slice_genbank_Genbank(&cret)
}

//export genbank_ParseMultiNth
func genbank_ParseMultiNth(r CGoHandle, count C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.ParseMultiNth(ptrFromHandle_io_Reader(r), int(count))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_genbank_Genbank(nil)
	}
	return handleFromPtr_Slice_genbank_Genbank(&cret)
}

//export genbank_ReadMulti
func genbank_ReadMulti(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := genbank.ReadMulti(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_genbank_Genbank(nil)
	}
	return handleFromPtr_Slice_genbank_Genbank(&cret)
}

// ---- Package: gff ---

// ---- Types ---

// Converters for pointer handles for type: *gff.Feature
func ptrFromHandle_Ptr_gff_Feature(h CGoHandle) *gff.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gff.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Feature{})).(*gff.Feature)
}
func handleFromPtr_Ptr_gff_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gff.Feature", p))
}

// Converters for pointer handles for type: *gff.Gff
func ptrFromHandle_Ptr_gff_Gff(h CGoHandle) *gff.Gff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gff.Gff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Gff{})).(*gff.Gff)
}
func handleFromPtr_Ptr_gff_Gff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gff.Gff", p))
}

// Converters for pointer handles for type: *gff.Location
func ptrFromHandle_Ptr_gff_Location(h CGoHandle) *gff.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gff.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Location{})).(*gff.Location)
}
func handleFromPtr_Ptr_gff_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gff.Location", p))
}

// Converters for pointer handles for type: *gff.Meta
func ptrFromHandle_Ptr_gff_Meta(h CGoHandle) *gff.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gff.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Meta{})).(*gff.Meta)
}
func handleFromPtr_Ptr_gff_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gff.Meta", p))
}

// Converters for implicit pointer handles for type: [32]byte
func ptrFromHandle_Array_32_byte(h CGoHandle) *[32]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[32]byte")
	if p == nil {
		return nil
	}
	return p.(*[32]byte)
}
func deptrFromHandle_Array_32_byte(h CGoHandle) [32]byte {
	p := ptrFromHandle_Array_32_byte(h)
	return *p
}
func handleFromPtr_Array_32_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[32]byte", p))
}

// --- wrapping slice: [32]byte ---
//
//export Array_32_byte_CTor
func Array_32_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_32_byte(&[32]byte{}))
}

//export Array_32_byte_len
func Array_32_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_32_byte(handle))
}

//export Array_32_byte_elem
func Array_32_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Array_32_byte(handle)
	return C.char(s[_idx])
}

//export Array_32_byte_set
func Array_32_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Array_32_byte(handle)
	s[_idx] = byte(_vl)
}

// Converters for implicit pointer handles for type: []gff.Feature
func ptrFromHandle_Slice_gff_Feature(h CGoHandle) *[]gff.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]gff.Feature")
	if p == nil {
		return nil
	}
	return p.(*[]gff.Feature)
}
func deptrFromHandle_Slice_gff_Feature(h CGoHandle) []gff.Feature {
	p := ptrFromHandle_Slice_gff_Feature(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_gff_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]gff.Feature", p))
}

// --- wrapping slice: []gff.Feature ---
//
//export Slice_gff_Feature_CTor
func Slice_gff_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_gff_Feature(&[]gff.Feature{}))
}

//export Slice_gff_Feature_len
func Slice_gff_Feature_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_gff_Feature(handle))
}

//export Slice_gff_Feature_elem
func Slice_gff_Feature_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_gff_Feature(handle)
	return handleFromPtr_gff_Feature(&(s[_idx]))
}

//export Slice_gff_Feature_subslice
func Slice_gff_Feature_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_gff_Feature(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_gff_Feature(&ss))
}

//export Slice_gff_Feature_set
func Slice_gff_Feature_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_gff_Feature(handle)
	s[_idx] = *ptrFromHandle_gff_Feature(_vl)
}

//export Slice_gff_Feature_append
func Slice_gff_Feature_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_gff_Feature(handle)
	*s = append(*s, *ptrFromHandle_gff_Feature(_vl))
}

// Converters for implicit pointer handles for type: []gff.Location
func ptrFromHandle_Slice_gff_Location(h CGoHandle) *[]gff.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]gff.Location")
	if p == nil {
		return nil
	}
	return p.(*[]gff.Location)
}
func deptrFromHandle_Slice_gff_Location(h CGoHandle) []gff.Location {
	p := ptrFromHandle_Slice_gff_Location(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_gff_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]gff.Location", p))
}

// --- wrapping slice: []gff.Location ---
//
//export Slice_gff_Location_CTor
func Slice_gff_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_gff_Location(&[]gff.Location{}))
}

//export Slice_gff_Location_len
func Slice_gff_Location_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_gff_Location(handle))
}

//export Slice_gff_Location_elem
func Slice_gff_Location_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_gff_Location(handle)
	return handleFromPtr_gff_Location(&(s[_idx]))
}

//export Slice_gff_Location_subslice
func Slice_gff_Location_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_gff_Location(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_gff_Location(&ss))
}

//export Slice_gff_Location_set
func Slice_gff_Location_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_gff_Location(handle)
	s[_idx] = *ptrFromHandle_gff_Location(_vl)
}

//export Slice_gff_Location_append
func Slice_gff_Location_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_gff_Location(handle)
	*s = append(*s, *ptrFromHandle_gff_Location(_vl))
}

// Converters for non-pointer handles for type: gff.Feature
func ptrFromHandle_gff_Feature(h CGoHandle) *gff.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gff.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Feature{})).(*gff.Feature)
}
func handleFromPtr_gff_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gff.Feature", p))
}

// Converters for non-pointer handles for type: gff.Gff
func ptrFromHandle_gff_Gff(h CGoHandle) *gff.Gff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gff.Gff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Gff{})).(*gff.Gff)
}
func handleFromPtr_gff_Gff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gff.Gff", p))
}

// Converters for non-pointer handles for type: gff.Location
func ptrFromHandle_gff_Location(h CGoHandle) *gff.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gff.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Location{})).(*gff.Location)
}
func handleFromPtr_gff_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gff.Location", p))
}

// Converters for non-pointer handles for type: gff.Meta
func ptrFromHandle_gff_Meta(h CGoHandle) *gff.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gff.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gff.Meta{})).(*gff.Meta)
}
func handleFromPtr_gff_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gff.Meta", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: gff.Feature ---
//
//export gff_Feature_CTor
func gff_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gff_Feature(&gff.Feature{}))
}

//export gff_Feature_Name_Get
func gff_Feature_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Name)
}

//export gff_Feature_Name_Set
func gff_Feature_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Name = C.GoString(val)
}

//export gff_Feature_Source_Get
func gff_Feature_Source_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Source)
}

//export gff_Feature_Source_Set
func gff_Feature_Source_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Source = C.GoString(val)
}

//export gff_Feature_Type_Get
func gff_Feature_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Type)
}

//export gff_Feature_Type_Set
func gff_Feature_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Type = C.GoString(val)
}

//export gff_Feature_Score_Get
func gff_Feature_Score_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Score)
}

//export gff_Feature_Score_Set
func gff_Feature_Score_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Score = C.GoString(val)
}

//export gff_Feature_Strand_Get
func gff_Feature_Strand_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Strand)
}

//export gff_Feature_Strand_Set
func gff_Feature_Strand_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Strand = C.GoString(val)
}

//export gff_Feature_Phase_Get
func gff_Feature_Phase_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Feature(handle)
	return C.CString(op.Phase)
}

//export gff_Feature_Phase_Set
func gff_Feature_Phase_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Phase = C.GoString(val)
}

//export gff_Feature_Attributes_Get
func gff_Feature_Attributes_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Feature(handle)
	return handleFromPtr_Map_string_string(&op.Attributes)
}

//export gff_Feature_Attributes_Set
func gff_Feature_Attributes_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Attributes = deptrFromHandle_Map_string_string(val)
}

//export gff_Feature_Location_Get
func gff_Feature_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Feature(handle)
	return handleFromPtr_gff_Location(&op.Location)
}

//export gff_Feature_Location_Set
func gff_Feature_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Feature(handle)
	op.Location = *ptrFromHandle_gff_Location(val)
}

//export gff_Feature_ParentSequence_Get
func gff_Feature_ParentSequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Feature(handle)
	return handleFromPtr_Ptr_gff_Gff(op.ParentSequence)
}

//export gff_Feature_ParentSequence_Set
func gff_Feature_ParentSequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Feature(handle)
	op.ParentSequence = ptrFromHandle_Ptr_gff_Gff(val)
}

//export gff_Feature_GetSequence
func gff_Feature_GetSequence(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gff.Feature")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gff.Feature{})).(*gff.Feature).GetSequence()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// --- wrapping struct: gff.Gff ---
//
//export gff_Gff_CTor
func gff_Gff_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gff_Gff(&gff.Gff{}))
}

//export gff_Gff_Meta_Get
func gff_Gff_Meta_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Gff(handle)
	return handleFromPtr_gff_Meta(&op.Meta)
}

//export gff_Gff_Meta_Set
func gff_Gff_Meta_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Gff(handle)
	op.Meta = *ptrFromHandle_gff_Meta(val)
}

//export gff_Gff_Features_Get
func gff_Gff_Features_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Gff(handle)
	return handleFromPtr_Slice_gff_Feature(&op.Features)
}

//export gff_Gff_Features_Set
func gff_Gff_Features_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Gff(handle)
	op.Features = deptrFromHandle_Slice_gff_Feature(val)
}

//export gff_Gff_Sequence_Get
func gff_Gff_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Gff(handle)
	return C.CString(op.Sequence)
}

//export gff_Gff_Sequence_Set
func gff_Gff_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Gff(handle)
	op.Sequence = C.GoString(val)
}

//export gff_Gff_AddFeature
func gff_Gff_AddFeature(_handle CGoHandle, feature CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gff.Gff")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gff.Gff{})).(*gff.Gff).AddFeature(ptrFromHandle_Ptr_gff_Feature(feature))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gff.Location ---
//
//export gff_Location_CTor
func gff_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gff_Location(&gff.Location{}))
}

//export gff_Location_Start_Get
func gff_Location_Start_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gff_Location(handle)
	return C.longlong(op.Start)
}

//export gff_Location_Start_Set
func gff_Location_Start_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gff_Location(handle)
	op.Start = int(val)
}

//export gff_Location_End_Get
func gff_Location_End_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gff_Location(handle)
	return C.longlong(op.End)
}

//export gff_Location_End_Set
func gff_Location_End_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gff_Location(handle)
	op.End = int(val)
}

//export gff_Location_Complement_Get
func gff_Location_Complement_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gff_Location(handle)
	return boolGoToPy(op.Complement)
}

//export gff_Location_Complement_Set
func gff_Location_Complement_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gff_Location(handle)
	op.Complement = boolPyToGo(val)
}

//export gff_Location_Join_Get
func gff_Location_Join_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gff_Location(handle)
	return boolGoToPy(op.Join)
}

//export gff_Location_Join_Set
func gff_Location_Join_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gff_Location(handle)
	op.Join = boolPyToGo(val)
}

//export gff_Location_FivePrimePartial_Get
func gff_Location_FivePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gff_Location(handle)
	return boolGoToPy(op.FivePrimePartial)
}

//export gff_Location_FivePrimePartial_Set
func gff_Location_FivePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gff_Location(handle)
	op.FivePrimePartial = boolPyToGo(val)
}

//export gff_Location_ThreePrimePartial_Get
func gff_Location_ThreePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gff_Location(handle)
	return boolGoToPy(op.ThreePrimePartial)
}

//export gff_Location_ThreePrimePartial_Set
func gff_Location_ThreePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gff_Location(handle)
	op.ThreePrimePartial = boolPyToGo(val)
}

//export gff_Location_SubLocations_Get
func gff_Location_SubLocations_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Location(handle)
	return handleFromPtr_Slice_gff_Location(&op.SubLocations)
}

//export gff_Location_SubLocations_Set
func gff_Location_SubLocations_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gff_Location(handle)
	op.SubLocations = deptrFromHandle_Slice_gff_Location(val)
}

// --- wrapping struct: gff.Meta ---
//
//export gff_Meta_CTor
func gff_Meta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gff_Meta(&gff.Meta{}))
}

//export gff_Meta_Name_Get
func gff_Meta_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Meta(handle)
	return C.CString(op.Name)
}

//export gff_Meta_Name_Set
func gff_Meta_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Meta(handle)
	op.Name = C.GoString(val)
}

//export gff_Meta_Description_Get
func gff_Meta_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Meta(handle)
	return C.CString(op.Description)
}

//export gff_Meta_Description_Set
func gff_Meta_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Meta(handle)
	op.Description = C.GoString(val)
}

//export gff_Meta_Version_Get
func gff_Meta_Version_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Meta(handle)
	return C.CString(op.Version)
}

//export gff_Meta_Version_Set
func gff_Meta_Version_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Meta(handle)
	op.Version = C.GoString(val)
}

//export gff_Meta_RegionStart_Get
func gff_Meta_RegionStart_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gff_Meta(handle)
	return C.longlong(op.RegionStart)
}

//export gff_Meta_RegionStart_Set
func gff_Meta_RegionStart_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gff_Meta(handle)
	op.RegionStart = int(val)
}

//export gff_Meta_RegionEnd_Get
func gff_Meta_RegionEnd_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gff_Meta(handle)
	return C.longlong(op.RegionEnd)
}

//export gff_Meta_RegionEnd_Set
func gff_Meta_RegionEnd_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gff_Meta(handle)
	op.RegionEnd = int(val)
}

//export gff_Meta_Size_Get
func gff_Meta_Size_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gff_Meta(handle)
	return C.longlong(op.Size)
}

//export gff_Meta_Size_Set
func gff_Meta_Size_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gff_Meta(handle)
	op.Size = int(val)
}

//export gff_Meta_SequenceHash_Get
func gff_Meta_SequenceHash_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Meta(handle)
	return C.CString(op.SequenceHash)
}

//export gff_Meta_SequenceHash_Set
func gff_Meta_SequenceHash_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Meta(handle)
	op.SequenceHash = C.GoString(val)
}

//export gff_Meta_SequenceHashFunction_Get
func gff_Meta_SequenceHashFunction_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gff_Meta(handle)
	return C.CString(op.SequenceHashFunction)
}

//export gff_Meta_SequenceHashFunction_Set
func gff_Meta_SequenceHashFunction_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gff_Meta(handle)
	op.SequenceHashFunction = C.GoString(val)
}

//export gff_Meta_CheckSum_Get
func gff_Meta_CheckSum_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gff_Meta(handle)
	return handleFromPtr_Array_32_byte(&op.CheckSum)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export gff_Parse
func gff_Parse(file CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gff.Parse(ptrFromHandle_io_Reader(file))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_gff_Gff(nil)
	}
	return handleFromPtr_gff_Gff(&cret)
}

//export gff_Read
func gff_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gff.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_gff_Gff(nil)
	}
	return handleFromPtr_gff_Gff(&cret)
}

// ---- Functions ---

//export gff_Build
func gff_Build(sequence CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gff.Build(*ptrFromHandle_gff_Gff(sequence))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export gff_Write
func gff_Write(sequence CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gff.Write(*ptrFromHandle_gff_Gff(sequence), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Package: pileup ---

// ---- Types ---

// Converters for pointer handles for type: *pileup.Parser
func ptrFromHandle_Ptr_pileup_Parser(h CGoHandle) *pileup.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pileup.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser)
}
func handleFromPtr_Ptr_pileup_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pileup.Parser", p))
}

// Converters for pointer handles for type: *pileup.Pileup
func ptrFromHandle_Ptr_pileup_Pileup(h CGoHandle) *pileup.Pileup {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pileup.Pileup")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pileup.Pileup{})).(*pileup.Pileup)
}
func handleFromPtr_Ptr_pileup_Pileup(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pileup.Pileup", p))
}

// Converters for implicit pointer handles for type: []pileup.Pileup
func ptrFromHandle_Slice_pileup_Pileup(h CGoHandle) *[]pileup.Pileup {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pileup.Pileup")
	if p == nil {
		return nil
	}
	return p.(*[]pileup.Pileup)
}
func deptrFromHandle_Slice_pileup_Pileup(h CGoHandle) []pileup.Pileup {
	p := ptrFromHandle_Slice_pileup_Pileup(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pileup_Pileup(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pileup.Pileup", p))
}

// --- wrapping slice: []pileup.Pileup ---
//
//export Slice_pileup_Pileup_CTor
func Slice_pileup_Pileup_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pileup_Pileup(&[]pileup.Pileup{}))
}

//export Slice_pileup_Pileup_len
func Slice_pileup_Pileup_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pileup_Pileup(handle))
}

//export Slice_pileup_Pileup_elem
func Slice_pileup_Pileup_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pileup_Pileup(handle)
	return handleFromPtr_pileup_Pileup(&(s[_idx]))
}

//export Slice_pileup_Pileup_subslice
func Slice_pileup_Pileup_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pileup_Pileup(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pileup_Pileup(&ss))
}

//export Slice_pileup_Pileup_set
func Slice_pileup_Pileup_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pileup_Pileup(handle)
	s[_idx] = *ptrFromHandle_pileup_Pileup(_vl)
}

//export Slice_pileup_Pileup_append
func Slice_pileup_Pileup_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pileup_Pileup(handle)
	*s = append(*s, *ptrFromHandle_pileup_Pileup(_vl))
}

// Converters for non-pointer handles for type: pileup.Parser
func ptrFromHandle_pileup_Parser(h CGoHandle) *pileup.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pileup.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser)
}
func handleFromPtr_pileup_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pileup.Parser", p))
}

// Converters for non-pointer handles for type: pileup.Pileup
func ptrFromHandle_pileup_Pileup(h CGoHandle) *pileup.Pileup {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pileup.Pileup")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pileup.Pileup{})).(*pileup.Pileup)
}
func handleFromPtr_pileup_Pileup(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pileup.Pileup", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: pileup.Parser ---
//
//export pileup_Parser_CTor
func pileup_Parser_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pileup_Parser(&pileup.Parser{}))
}

//export pileup_Parser_ParseAll
func pileup_Parser_ParseAll(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*pileup.Parser")
	if __err != nil {
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser).ParseAll()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	return handleFromPtr_Slice_pileup_Pileup(&cret)
}

//export pileup_Parser_ParseN
func pileup_Parser_ParseN(_handle CGoHandle, maxRows C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*pileup.Parser")
	if __err != nil {
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser).ParseN(int(maxRows))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	return handleFromPtr_Slice_pileup_Pileup(&cret)
}

//export pileup_Parser_ParseNext
func pileup_Parser_ParseNext(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*pileup.Parser")
	if __err != nil {
		return handleFromPtr_pileup_Pileup(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser).ParseNext()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_pileup_Pileup(nil)
	}
	return handleFromPtr_pileup_Pileup(&cret)
}

//export pileup_Parser_Reset
func pileup_Parser_Reset(_handle CGoHandle, r CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*pileup.Parser")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser).Reset(ptrFromHandle_io_Reader(r))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(pileup.Parser{})).(*pileup.Parser).Reset(ptrFromHandle_io_Reader(r))
	}
}

// --- wrapping struct: pileup.Pileup ---
//
//export pileup_Pileup_CTor
func pileup_Pileup_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pileup_Pileup(&pileup.Pileup{}))
}

//export pileup_Pileup_Sequence_Get
func pileup_Pileup_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pileup_Pileup(handle)
	return C.CString(op.Sequence)
}

//export pileup_Pileup_Sequence_Set
func pileup_Pileup_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.Sequence = C.GoString(val)
}

//export pileup_Pileup_Position_Get
func pileup_Pileup_Position_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_pileup_Pileup(handle)
	return C.ulonglong(op.Position)
}

//export pileup_Pileup_Position_Set
func pileup_Pileup_Position_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.Position = uint(val)
}

//export pileup_Pileup_ReferenceBase_Get
func pileup_Pileup_ReferenceBase_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pileup_Pileup(handle)
	return C.CString(op.ReferenceBase)
}

//export pileup_Pileup_ReferenceBase_Set
func pileup_Pileup_ReferenceBase_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.ReferenceBase = C.GoString(val)
}

//export pileup_Pileup_ReadCount_Get
func pileup_Pileup_ReadCount_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_pileup_Pileup(handle)
	return C.ulonglong(op.ReadCount)
}

//export pileup_Pileup_ReadCount_Set
func pileup_Pileup_ReadCount_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.ReadCount = uint(val)
}

//export pileup_Pileup_ReadResults_Get
func pileup_Pileup_ReadResults_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pileup_Pileup(handle)
	return handleFromPtr_Slice_string(&op.ReadResults)
}

//export pileup_Pileup_ReadResults_Set
func pileup_Pileup_ReadResults_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.ReadResults = deptrFromHandle_Slice_string(val)
}

//export pileup_Pileup_Quality_Get
func pileup_Pileup_Quality_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pileup_Pileup(handle)
	return C.CString(op.Quality)
}

//export pileup_Pileup_Quality_Set
func pileup_Pileup_Quality_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pileup_Pileup(handle)
	op.Quality = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export pileup_NewParser
func pileup_NewParser(r CGoHandle, maxLineSize C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_pileup_Parser(pileup.NewParser(ptrFromHandle_io_Reader(r), int(maxLineSize)))

}

// ---- Functions ---

//export pileup_Read
func pileup_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := pileup.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	return handleFromPtr_Slice_pileup_Pileup(&cret)
}

//export pileup_Write
func pileup_Write(pileups CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = pileup.Write(deptrFromHandle_Slice_pileup_Pileup(pileups), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export pileup_WritePileups
func pileup_WritePileups(pileups CGoHandle, w CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = pileup.WritePileups(deptrFromHandle_Slice_pileup_Pileup(pileups), ptrFromHandle_io_Writer(w))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export pileup_Parse
func pileup_Parse(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := pileup.Parse(ptrFromHandle_io_Reader(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_pileup_Pileup(nil)
	}
	return handleFromPtr_Slice_pileup_Pileup(&cret)
}

// ---- Package: polyjson ---

// ---- Types ---

// Converters for pointer handles for type: *polyjson.Feature
func ptrFromHandle_Ptr_polyjson_Feature(h CGoHandle) *polyjson.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*polyjson.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Feature{})).(*polyjson.Feature)
}
func handleFromPtr_Ptr_polyjson_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*polyjson.Feature", p))
}

// Converters for pointer handles for type: *polyjson.Location
func ptrFromHandle_Ptr_polyjson_Location(h CGoHandle) *polyjson.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*polyjson.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Location{})).(*polyjson.Location)
}
func handleFromPtr_Ptr_polyjson_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*polyjson.Location", p))
}

// Converters for pointer handles for type: *polyjson.Meta
func ptrFromHandle_Ptr_polyjson_Meta(h CGoHandle) *polyjson.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*polyjson.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Meta{})).(*polyjson.Meta)
}
func handleFromPtr_Ptr_polyjson_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*polyjson.Meta", p))
}

// Converters for pointer handles for type: *polyjson.Poly
func ptrFromHandle_Ptr_polyjson_Poly(h CGoHandle) *polyjson.Poly {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*polyjson.Poly")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Poly{})).(*polyjson.Poly)
}
func handleFromPtr_Ptr_polyjson_Poly(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*polyjson.Poly", p))
}

// Converters for implicit pointer handles for type: []polyjson.Feature
func ptrFromHandle_Slice_polyjson_Feature(h CGoHandle) *[]polyjson.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]polyjson.Feature")
	if p == nil {
		return nil
	}
	return p.(*[]polyjson.Feature)
}
func deptrFromHandle_Slice_polyjson_Feature(h CGoHandle) []polyjson.Feature {
	p := ptrFromHandle_Slice_polyjson_Feature(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_polyjson_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]polyjson.Feature", p))
}

// --- wrapping slice: []polyjson.Feature ---
//
//export Slice_polyjson_Feature_CTor
func Slice_polyjson_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_polyjson_Feature(&[]polyjson.Feature{}))
}

//export Slice_polyjson_Feature_len
func Slice_polyjson_Feature_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_polyjson_Feature(handle))
}

//export Slice_polyjson_Feature_elem
func Slice_polyjson_Feature_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_polyjson_Feature(handle)
	return handleFromPtr_polyjson_Feature(&(s[_idx]))
}

//export Slice_polyjson_Feature_subslice
func Slice_polyjson_Feature_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_polyjson_Feature(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_polyjson_Feature(&ss))
}

//export Slice_polyjson_Feature_set
func Slice_polyjson_Feature_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_polyjson_Feature(handle)
	s[_idx] = *ptrFromHandle_polyjson_Feature(_vl)
}

//export Slice_polyjson_Feature_append
func Slice_polyjson_Feature_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_polyjson_Feature(handle)
	*s = append(*s, *ptrFromHandle_polyjson_Feature(_vl))
}

// Converters for implicit pointer handles for type: []polyjson.Location
func ptrFromHandle_Slice_polyjson_Location(h CGoHandle) *[]polyjson.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]polyjson.Location")
	if p == nil {
		return nil
	}
	return p.(*[]polyjson.Location)
}
func deptrFromHandle_Slice_polyjson_Location(h CGoHandle) []polyjson.Location {
	p := ptrFromHandle_Slice_polyjson_Location(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_polyjson_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]polyjson.Location", p))
}

// --- wrapping slice: []polyjson.Location ---
//
//export Slice_polyjson_Location_CTor
func Slice_polyjson_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_polyjson_Location(&[]polyjson.Location{}))
}

//export Slice_polyjson_Location_len
func Slice_polyjson_Location_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_polyjson_Location(handle))
}

//export Slice_polyjson_Location_elem
func Slice_polyjson_Location_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_polyjson_Location(handle)
	return handleFromPtr_polyjson_Location(&(s[_idx]))
}

//export Slice_polyjson_Location_subslice
func Slice_polyjson_Location_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_polyjson_Location(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_polyjson_Location(&ss))
}

//export Slice_polyjson_Location_set
func Slice_polyjson_Location_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_polyjson_Location(handle)
	s[_idx] = *ptrFromHandle_polyjson_Location(_vl)
}

//export Slice_polyjson_Location_append
func Slice_polyjson_Location_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_polyjson_Location(handle)
	*s = append(*s, *ptrFromHandle_polyjson_Location(_vl))
}

// Converters for non-pointer handles for type: polyjson.Feature
func ptrFromHandle_polyjson_Feature(h CGoHandle) *polyjson.Feature {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "polyjson.Feature")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Feature{})).(*polyjson.Feature)
}
func handleFromPtr_polyjson_Feature(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("polyjson.Feature", p))
}

// Converters for non-pointer handles for type: polyjson.Location
func ptrFromHandle_polyjson_Location(h CGoHandle) *polyjson.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "polyjson.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Location{})).(*polyjson.Location)
}
func handleFromPtr_polyjson_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("polyjson.Location", p))
}

// Converters for non-pointer handles for type: polyjson.Meta
func ptrFromHandle_polyjson_Meta(h CGoHandle) *polyjson.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "polyjson.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Meta{})).(*polyjson.Meta)
}
func handleFromPtr_polyjson_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("polyjson.Meta", p))
}

// Converters for non-pointer handles for type: polyjson.Poly
func ptrFromHandle_polyjson_Poly(h CGoHandle) *polyjson.Poly {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "polyjson.Poly")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(polyjson.Poly{})).(*polyjson.Poly)
}
func handleFromPtr_polyjson_Poly(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("polyjson.Poly", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: polyjson.Feature ---
//
//export polyjson_Feature_CTor
func polyjson_Feature_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_polyjson_Feature(&polyjson.Feature{}))
}

//export polyjson_Feature_Name_Get
func polyjson_Feature_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Feature(handle)
	return C.CString(op.Name)
}

//export polyjson_Feature_Name_Set
func polyjson_Feature_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Name = C.GoString(val)
}

//export polyjson_Feature_Hash_Get
func polyjson_Feature_Hash_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Feature(handle)
	return C.CString(op.Hash)
}

//export polyjson_Feature_Hash_Set
func polyjson_Feature_Hash_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Hash = C.GoString(val)
}

//export polyjson_Feature_Type_Get
func polyjson_Feature_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Feature(handle)
	return C.CString(op.Type)
}

//export polyjson_Feature_Type_Set
func polyjson_Feature_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Type = C.GoString(val)
}

//export polyjson_Feature_Description_Get
func polyjson_Feature_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Feature(handle)
	return C.CString(op.Description)
}

//export polyjson_Feature_Description_Set
func polyjson_Feature_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Description = C.GoString(val)
}

//export polyjson_Feature_Location_Get
func polyjson_Feature_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Feature(handle)
	return handleFromPtr_polyjson_Location(&op.Location)
}

//export polyjson_Feature_Location_Set
func polyjson_Feature_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Location = *ptrFromHandle_polyjson_Location(val)
}

//export polyjson_Feature_Tags_Get
func polyjson_Feature_Tags_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Feature(handle)
	return handleFromPtr_Map_string_string(&op.Tags)
}

//export polyjson_Feature_Tags_Set
func polyjson_Feature_Tags_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Tags = deptrFromHandle_Map_string_string(val)
}

//export polyjson_Feature_Sequence_Get
func polyjson_Feature_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Feature(handle)
	return C.CString(op.Sequence)
}

//export polyjson_Feature_Sequence_Set
func polyjson_Feature_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.Sequence = C.GoString(val)
}

//export polyjson_Feature_ParentSequence_Get
func polyjson_Feature_ParentSequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Feature(handle)
	return handleFromPtr_Ptr_polyjson_Poly(op.ParentSequence)
}

//export polyjson_Feature_ParentSequence_Set
func polyjson_Feature_ParentSequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Feature(handle)
	op.ParentSequence = ptrFromHandle_Ptr_polyjson_Poly(val)
}

//export polyjson_Feature_GetSequence
func polyjson_Feature_GetSequence(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*polyjson.Feature")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(polyjson.Feature{})).(*polyjson.Feature).GetSequence()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// --- wrapping struct: polyjson.Location ---
//
//export polyjson_Location_CTor
func polyjson_Location_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_polyjson_Location(&polyjson.Location{}))
}

//export polyjson_Location_Start_Get
func polyjson_Location_Start_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_polyjson_Location(handle)
	return C.longlong(op.Start)
}

//export polyjson_Location_Start_Set
func polyjson_Location_Start_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.Start = int(val)
}

//export polyjson_Location_End_Get
func polyjson_Location_End_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_polyjson_Location(handle)
	return C.longlong(op.End)
}

//export polyjson_Location_End_Set
func polyjson_Location_End_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.End = int(val)
}

//export polyjson_Location_Complement_Get
func polyjson_Location_Complement_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_polyjson_Location(handle)
	return boolGoToPy(op.Complement)
}

//export polyjson_Location_Complement_Set
func polyjson_Location_Complement_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.Complement = boolPyToGo(val)
}

//export polyjson_Location_Join_Get
func polyjson_Location_Join_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_polyjson_Location(handle)
	return boolGoToPy(op.Join)
}

//export polyjson_Location_Join_Set
func polyjson_Location_Join_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.Join = boolPyToGo(val)
}

//export polyjson_Location_FivePrimePartial_Get
func polyjson_Location_FivePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_polyjson_Location(handle)
	return boolGoToPy(op.FivePrimePartial)
}

//export polyjson_Location_FivePrimePartial_Set
func polyjson_Location_FivePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.FivePrimePartial = boolPyToGo(val)
}

//export polyjson_Location_ThreePrimePartial_Get
func polyjson_Location_ThreePrimePartial_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_polyjson_Location(handle)
	return boolGoToPy(op.ThreePrimePartial)
}

//export polyjson_Location_ThreePrimePartial_Set
func polyjson_Location_ThreePrimePartial_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.ThreePrimePartial = boolPyToGo(val)
}

//export polyjson_Location_SubLocations_Get
func polyjson_Location_SubLocations_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Location(handle)
	return handleFromPtr_Slice_polyjson_Location(&op.SubLocations)
}

//export polyjson_Location_SubLocations_Set
func polyjson_Location_SubLocations_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Location(handle)
	op.SubLocations = deptrFromHandle_Slice_polyjson_Location(val)
}

// --- wrapping struct: polyjson.Meta ---
//
//export polyjson_Meta_CTor
func polyjson_Meta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_polyjson_Meta(&polyjson.Meta{}))
}

//export polyjson_Meta_Name_Get
func polyjson_Meta_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.Name)
}

//export polyjson_Meta_Name_Set
func polyjson_Meta_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.Name = C.GoString(val)
}

//export polyjson_Meta_Hash_Get
func polyjson_Meta_Hash_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.Hash)
}

//export polyjson_Meta_Hash_Set
func polyjson_Meta_Hash_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.Hash = C.GoString(val)
}

//export polyjson_Meta_Description_Get
func polyjson_Meta_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.Description)
}

//export polyjson_Meta_Description_Set
func polyjson_Meta_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.Description = C.GoString(val)
}

//export polyjson_Meta_URL_Get
func polyjson_Meta_URL_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.URL)
}

//export polyjson_Meta_URL_Set
func polyjson_Meta_URL_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.URL = C.GoString(val)
}

//export polyjson_Meta_CreatedBy_Get
func polyjson_Meta_CreatedBy_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.CreatedBy)
}

//export polyjson_Meta_CreatedBy_Set
func polyjson_Meta_CreatedBy_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.CreatedBy = C.GoString(val)
}

//export polyjson_Meta_CreatedWith_Get
func polyjson_Meta_CreatedWith_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.CreatedWith)
}

//export polyjson_Meta_CreatedWith_Set
func polyjson_Meta_CreatedWith_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.CreatedWith = C.GoString(val)
}

//export polyjson_Meta_CreatedOn_Get
func polyjson_Meta_CreatedOn_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Meta(handle)
	return handleFromPtr_time_Time(&op.CreatedOn)
}

//export polyjson_Meta_CreatedOn_Set
func polyjson_Meta_CreatedOn_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.CreatedOn = *ptrFromHandle_time_Time(val)
}

//export polyjson_Meta_Schema_Get
func polyjson_Meta_Schema_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Meta(handle)
	return C.CString(op.Schema)
}

//export polyjson_Meta_Schema_Set
func polyjson_Meta_Schema_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Meta(handle)
	op.Schema = C.GoString(val)
}

// --- wrapping struct: polyjson.Poly ---
//
//export polyjson_Poly_CTor
func polyjson_Poly_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_polyjson_Poly(&polyjson.Poly{}))
}

//export polyjson_Poly_Meta_Get
func polyjson_Poly_Meta_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Poly(handle)
	return handleFromPtr_polyjson_Meta(&op.Meta)
}

//export polyjson_Poly_Meta_Set
func polyjson_Poly_Meta_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Poly(handle)
	op.Meta = *ptrFromHandle_polyjson_Meta(val)
}

//export polyjson_Poly_Features_Get
func polyjson_Poly_Features_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_polyjson_Poly(handle)
	return handleFromPtr_Slice_polyjson_Feature(&op.Features)
}

//export polyjson_Poly_Features_Set
func polyjson_Poly_Features_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_polyjson_Poly(handle)
	op.Features = deptrFromHandle_Slice_polyjson_Feature(val)
}

//export polyjson_Poly_Sequence_Get
func polyjson_Poly_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_polyjson_Poly(handle)
	return C.CString(op.Sequence)
}

//export polyjson_Poly_Sequence_Set
func polyjson_Poly_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_polyjson_Poly(handle)
	op.Sequence = C.GoString(val)
}

//export polyjson_Poly_AddFeature
func polyjson_Poly_AddFeature(_handle CGoHandle, feature CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*polyjson.Poly")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(polyjson.Poly{})).(*polyjson.Poly).AddFeature(ptrFromHandle_Ptr_polyjson_Feature(feature))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export polyjson_Read
func polyjson_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := polyjson.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_polyjson_Poly(nil)
	}
	return handleFromPtr_polyjson_Poly(&cret)
}

//export polyjson_Parse
func polyjson_Parse(file CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := polyjson.Parse(ptrFromHandle_io_Reader(file))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_polyjson_Poly(nil)
	}
	return handleFromPtr_polyjson_Poly(&cret)
}

// ---- Functions ---

//export polyjson_Write
func polyjson_Write(sequence CGoHandle, path *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = polyjson.Write(*ptrFromHandle_polyjson_Poly(sequence), C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Package: rebase ---

// ---- Types ---

// Converters for pointer handles for type: *rebase.Enzyme
func ptrFromHandle_Ptr_rebase_Enzyme(h CGoHandle) *rebase.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rebase.Enzyme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rebase.Enzyme{})).(*rebase.Enzyme)
}
func handleFromPtr_Ptr_rebase_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rebase.Enzyme", p))
}

// Converters for non-pointer handles for type: rebase.Enzyme
func ptrFromHandle_rebase_Enzyme(h CGoHandle) *rebase.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rebase.Enzyme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rebase.Enzyme{})).(*rebase.Enzyme)
}
func handleFromPtr_rebase_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rebase.Enzyme", p))
}

// Converters for implicit pointer handles for type: map[string]rebase.Enzyme
func ptrFromHandle_Map_string_rebase_Enzyme(h CGoHandle) *map[string]rebase.Enzyme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]rebase.Enzyme")
	if p == nil {
		return nil
	}
	return p.(*map[string]rebase.Enzyme)
}
func deptrFromHandle_Map_string_rebase_Enzyme(h CGoHandle) map[string]rebase.Enzyme {
	p := ptrFromHandle_Map_string_rebase_Enzyme(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_rebase_Enzyme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]rebase.Enzyme", p))
}

// --- wrapping map: map[string]rebase.Enzyme ---
//
//export Map_string_rebase_Enzyme_CTor
func Map_string_rebase_Enzyme_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_rebase_Enzyme(&map[string]rebase.Enzyme{}))
}

//export Map_string_rebase_Enzyme_len
func Map_string_rebase_Enzyme_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_rebase_Enzyme(handle))
}

//export Map_string_rebase_Enzyme_elem
func Map_string_rebase_Enzyme_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_rebase_Enzyme(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_rebase_Enzyme(&v)
}

//export Map_string_rebase_Enzyme_contains
func Map_string_rebase_Enzyme_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_rebase_Enzyme(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_rebase_Enzyme_set
func Map_string_rebase_Enzyme_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_rebase_Enzyme(handle)
	s[C.GoString(_ky)] = *ptrFromHandle_rebase_Enzyme(_vl)
}

//export Map_string_rebase_Enzyme_delete
func Map_string_rebase_Enzyme_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_rebase_Enzyme(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_rebase_Enzyme_keys
func Map_string_rebase_Enzyme_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_rebase_Enzyme(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: rebase.Enzyme ---
//
//export rebase_Enzyme_CTor
func rebase_Enzyme_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rebase_Enzyme(&rebase.Enzyme{}))
}

//export rebase_Enzyme_Name_Get
func rebase_Enzyme_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.Name)
}

//export rebase_Enzyme_Name_Set
func rebase_Enzyme_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.Name = C.GoString(val)
}

//export rebase_Enzyme_Isoschizomers_Get
func rebase_Enzyme_Isoschizomers_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return handleFromPtr_Slice_string(&op.Isoschizomers)
}

//export rebase_Enzyme_Isoschizomers_Set
func rebase_Enzyme_Isoschizomers_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.Isoschizomers = deptrFromHandle_Slice_string(val)
}

//export rebase_Enzyme_RecognitionSequence_Get
func rebase_Enzyme_RecognitionSequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.RecognitionSequence)
}

//export rebase_Enzyme_RecognitionSequence_Set
func rebase_Enzyme_RecognitionSequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.RecognitionSequence = C.GoString(val)
}

//export rebase_Enzyme_MethylationSite_Get
func rebase_Enzyme_MethylationSite_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.MethylationSite)
}

//export rebase_Enzyme_MethylationSite_Set
func rebase_Enzyme_MethylationSite_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.MethylationSite = C.GoString(val)
}

//export rebase_Enzyme_MicroOrganism_Get
func rebase_Enzyme_MicroOrganism_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.MicroOrganism)
}

//export rebase_Enzyme_MicroOrganism_Set
func rebase_Enzyme_MicroOrganism_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.MicroOrganism = C.GoString(val)
}

//export rebase_Enzyme_Source_Get
func rebase_Enzyme_Source_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.Source)
}

//export rebase_Enzyme_Source_Set
func rebase_Enzyme_Source_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.Source = C.GoString(val)
}

//export rebase_Enzyme_CommercialAvailability_Get
func rebase_Enzyme_CommercialAvailability_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return handleFromPtr_Slice_string(&op.CommercialAvailability)
}

//export rebase_Enzyme_CommercialAvailability_Set
func rebase_Enzyme_CommercialAvailability_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.CommercialAvailability = deptrFromHandle_Slice_string(val)
}

//export rebase_Enzyme_References_Get
func rebase_Enzyme_References_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rebase_Enzyme(handle)
	return C.CString(op.References)
}

//export rebase_Enzyme_References_Set
func rebase_Enzyme_References_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rebase_Enzyme(handle)
	op.References = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export rebase_Read
func rebase_Read(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rebase.Read(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_rebase_Enzyme(nil)
	}
	return handleFromPtr_Map_string_rebase_Enzyme(&cret)
}

//export rebase_Export
func rebase_Export(enzymeMap CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rebase.Export(deptrFromHandle_Map_string_rebase_Enzyme(enzymeMap))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export rebase_Parse
func rebase_Parse(file CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rebase.Parse(ptrFromHandle_io_Reader(file))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_rebase_Enzyme(nil)
	}
	return handleFromPtr_Map_string_rebase_Enzyme(&cret)
}

// ---- Package: slow5 ---

// ---- Types ---

// Converters for pointer handles for type: *slow5.Header
func ptrFromHandle_Ptr_slow5_Header(h CGoHandle) *slow5.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*slow5.Header")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Header{})).(*slow5.Header)
}
func handleFromPtr_Ptr_slow5_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*slow5.Header", p))
}

// Converters for pointer handles for type: *slow5.Parser
func ptrFromHandle_Ptr_slow5_Parser(h CGoHandle) *slow5.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*slow5.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Parser{})).(*slow5.Parser)
}
func handleFromPtr_Ptr_slow5_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*slow5.Parser", p))
}

// Converters for pointer handles for type: *slow5.Read
func ptrFromHandle_Ptr_slow5_Read(h CGoHandle) *slow5.Read {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*slow5.Read")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Read{})).(*slow5.Read)
}
func handleFromPtr_Ptr_slow5_Read(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*slow5.Read", p))
}

// Converters for non-pointer handles for type: slow5.Header
func ptrFromHandle_slow5_Header(h CGoHandle) *slow5.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "slow5.Header")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Header{})).(*slow5.Header)
}
func handleFromPtr_slow5_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("slow5.Header", p))
}

// Converters for non-pointer handles for type: slow5.Parser
func ptrFromHandle_slow5_Parser(h CGoHandle) *slow5.Parser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "slow5.Parser")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Parser{})).(*slow5.Parser)
}
func handleFromPtr_slow5_Parser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("slow5.Parser", p))
}

// Converters for non-pointer handles for type: slow5.Read
func ptrFromHandle_slow5_Read(h CGoHandle) *slow5.Read {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "slow5.Read")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(slow5.Read{})).(*slow5.Read)
}
func handleFromPtr_slow5_Read(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("slow5.Read", p))
}

// Converters for implicit pointer handles for type: map[string]int
func ptrFromHandle_Map_string_int(h CGoHandle) *map[string]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]int")
	if p == nil {
		return nil
	}
	return p.(*map[string]int)
}
func deptrFromHandle_Map_string_int(h CGoHandle) map[string]int {
	p := ptrFromHandle_Map_string_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]int", p))
}

// --- wrapping map: map[string]int ---
//
//export Map_string_int_CTor
func Map_string_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_int(&map[string]int{}))
}

//export Map_string_int_len
func Map_string_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_int(handle))
}

//export Map_string_int_elem
func Map_string_int_elem(handle CGoHandle, _ky *C.char) C.longlong {
	s := deptrFromHandle_Map_string_int(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.longlong(v)
}

//export Map_string_int_contains
func Map_string_int_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_int(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_int_set
func Map_string_int_set(handle CGoHandle, _ky *C.char, _vl C.longlong) {
	s := deptrFromHandle_Map_string_int(handle)
	s[C.GoString(_ky)] = int(_vl)
}

//export Map_string_int_delete
func Map_string_int_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_int(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_int_keys
func Map_string_int_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_int(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: slow5.Header ---
//
//export slow5_Header_CTor
func slow5_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_slow5_Header(&slow5.Header{}))
}

//export slow5_Header_ReadGroupID_Get
func slow5_Header_ReadGroupID_Get(handle CGoHandle) C.ulong {
	op := ptrFromHandle_slow5_Header(handle)
	return C.ulong(op.ReadGroupID)
}

//export slow5_Header_ReadGroupID_Set
func slow5_Header_ReadGroupID_Set(handle CGoHandle, val C.ulong) {
	op := ptrFromHandle_slow5_Header(handle)
	op.ReadGroupID = uint32(val)
}

//export slow5_Header_Slow5Version_Get
func slow5_Header_Slow5Version_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_slow5_Header(handle)
	return C.CString(op.Slow5Version)
}

//export slow5_Header_Slow5Version_Set
func slow5_Header_Slow5Version_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_slow5_Header(handle)
	op.Slow5Version = C.GoString(val)
}

//export slow5_Header_Attributes_Get
func slow5_Header_Attributes_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_slow5_Header(handle)
	return handleFromPtr_Map_string_string(&op.Attributes)
}

//export slow5_Header_Attributes_Set
func slow5_Header_Attributes_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_slow5_Header(handle)
	op.Attributes = deptrFromHandle_Map_string_string(val)
}

//export slow5_Header_EndReasonHeaderMap_Get
func slow5_Header_EndReasonHeaderMap_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_slow5_Header(handle)
	return handleFromPtr_Map_string_int(&op.EndReasonHeaderMap)
}

//export slow5_Header_EndReasonHeaderMap_Set
func slow5_Header_EndReasonHeaderMap_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_slow5_Header(handle)
	op.EndReasonHeaderMap = deptrFromHandle_Map_string_int(val)
}

// --- wrapping struct: slow5.Parser ---
//
//export slow5_Parser_CTor
func slow5_Parser_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_slow5_Parser(&slow5.Parser{}))
}

//export slow5_Parser_ParseNext
func slow5_Parser_ParseNext(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*slow5.Parser")
	if __err != nil {
		return handleFromPtr_slow5_Read(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(slow5.Parser{})).(*slow5.Parser).ParseNext()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_slow5_Read(nil)
	}
	return handleFromPtr_slow5_Read(&cret)
}

// --- wrapping struct: slow5.Read ---
//
//export slow5_Read_CTor
func slow5_Read_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_slow5_Read(&slow5.Read{}))
}

//export slow5_Read_ReadID_Get
func slow5_Read_ReadID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_slow5_Read(handle)
	return C.CString(op.ReadID)
}

//export slow5_Read_ReadID_Set
func slow5_Read_ReadID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_slow5_Read(handle)
	op.ReadID = C.GoString(val)
}

//export slow5_Read_ReadGroupID_Get
func slow5_Read_ReadGroupID_Get(handle CGoHandle) C.ulong {
	op := ptrFromHandle_slow5_Read(handle)
	return C.ulong(op.ReadGroupID)
}

//export slow5_Read_ReadGroupID_Set
func slow5_Read_ReadGroupID_Set(handle CGoHandle, val C.ulong) {
	op := ptrFromHandle_slow5_Read(handle)
	op.ReadGroupID = uint32(val)
}

//export slow5_Read_Digitisation_Get
func slow5_Read_Digitisation_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_slow5_Read(handle)
	return C.double(op.Digitisation)
}

//export slow5_Read_Digitisation_Set
func slow5_Read_Digitisation_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_slow5_Read(handle)
	op.Digitisation = float64(val)
}

//export slow5_Read_Offset_Get
func slow5_Read_Offset_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_slow5_Read(handle)
	return C.double(op.Offset)
}

//export slow5_Read_Offset_Set
func slow5_Read_Offset_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_slow5_Read(handle)
	op.Offset = float64(val)
}

//export slow5_Read_Range_Get
func slow5_Read_Range_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_slow5_Read(handle)
	return C.double(op.Range)
}

//export slow5_Read_Range_Set
func slow5_Read_Range_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_slow5_Read(handle)
	op.Range = float64(val)
}

//export slow5_Read_SamplingRate_Get
func slow5_Read_SamplingRate_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_slow5_Read(handle)
	return C.double(op.SamplingRate)
}

//export slow5_Read_SamplingRate_Set
func slow5_Read_SamplingRate_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_slow5_Read(handle)
	op.SamplingRate = float64(val)
}

//export slow5_Read_LenRawSignal_Get
func slow5_Read_LenRawSignal_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_slow5_Read(handle)
	return C.ulonglong(op.LenRawSignal)
}

//export slow5_Read_LenRawSignal_Set
func slow5_Read_LenRawSignal_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_slow5_Read(handle)
	op.LenRawSignal = uint64(val)
}

//export slow5_Read_RawSignal_Get
func slow5_Read_RawSignal_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_slow5_Read(handle)
	return handleFromPtr_Slice_int16(&op.RawSignal)
}

//export slow5_Read_RawSignal_Set
func slow5_Read_RawSignal_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_slow5_Read(handle)
	op.RawSignal = deptrFromHandle_Slice_int16(val)
}

//export slow5_Read_ChannelNumber_Get
func slow5_Read_ChannelNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_slow5_Read(handle)
	return C.CString(op.ChannelNumber)
}

//export slow5_Read_ChannelNumber_Set
func slow5_Read_ChannelNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_slow5_Read(handle)
	op.ChannelNumber = C.GoString(val)
}

//export slow5_Read_MedianBefore_Get
func slow5_Read_MedianBefore_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_slow5_Read(handle)
	return C.double(op.MedianBefore)
}

//export slow5_Read_MedianBefore_Set
func slow5_Read_MedianBefore_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_slow5_Read(handle)
	op.MedianBefore = float64(val)
}

//export slow5_Read_ReadNumber_Get
func slow5_Read_ReadNumber_Get(handle CGoHandle) C.long {
	op := ptrFromHandle_slow5_Read(handle)
	return C.long(op.ReadNumber)
}

//export slow5_Read_ReadNumber_Set
func slow5_Read_ReadNumber_Set(handle CGoHandle, val C.long) {
	op := ptrFromHandle_slow5_Read(handle)
	op.ReadNumber = int32(val)
}

//export slow5_Read_StartMux_Get
func slow5_Read_StartMux_Get(handle CGoHandle) C.uchar {
	op := ptrFromHandle_slow5_Read(handle)
	return C.uchar(op.StartMux)
}

//export slow5_Read_StartMux_Set
func slow5_Read_StartMux_Set(handle CGoHandle, val C.uchar) {
	op := ptrFromHandle_slow5_Read(handle)
	op.StartMux = uint8(val)
}

//export slow5_Read_StartTime_Get
func slow5_Read_StartTime_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_slow5_Read(handle)
	return C.ulonglong(op.StartTime)
}

//export slow5_Read_StartTime_Set
func slow5_Read_StartTime_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_slow5_Read(handle)
	op.StartTime = uint64(val)
}

//export slow5_Read_EndReason_Get
func slow5_Read_EndReason_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_slow5_Read(handle)
	return C.CString(op.EndReason)
}

//export slow5_Read_EndReason_Set
func slow5_Read_EndReason_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_slow5_Read(handle)
	op.EndReason = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: uniprot ---

// ---- Types ---

// Converters for pointer handles for type: *uniprot.Absorption
func ptrFromHandle_Ptr_uniprot_Absorption(h CGoHandle) *uniprot.Absorption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Absorption")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Absorption{})).(*uniprot.Absorption)
}
func handleFromPtr_Ptr_uniprot_Absorption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Absorption", p))
}

// Converters for pointer handles for type: *uniprot.AlternativeName
func ptrFromHandle_Ptr_uniprot_AlternativeName(h CGoHandle) *uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.AlternativeName{})).(*uniprot.AlternativeName)
}
func handleFromPtr_Ptr_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.AlternativeName", p))
}

// Converters for pointer handles for type: *uniprot.Anon6
func ptrFromHandle_Ptr_uniprot_Anon6(h CGoHandle) *uniprot.Anon6 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Anon6")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Anon6{})).(*uniprot.Anon6)
}
func handleFromPtr_Ptr_uniprot_Anon6(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Anon6", p))
}

// Converters for pointer handles for type: *uniprot.CitationType
func ptrFromHandle_Ptr_uniprot_CitationType(h CGoHandle) *uniprot.CitationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CitationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CitationType{})).(*uniprot.CitationType)
}
func handleFromPtr_Ptr_uniprot_CitationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CitationType", p))
}

// Converters for pointer handles for type: *uniprot.CofactorType
func ptrFromHandle_Ptr_uniprot_CofactorType(h CGoHandle) *uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CofactorType{})).(*uniprot.CofactorType)
}
func handleFromPtr_Ptr_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CofactorType", p))
}

// Converters for pointer handles for type: *uniprot.CommentType
func ptrFromHandle_Ptr_uniprot_CommentType(h CGoHandle) *uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CommentType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType)
}
func handleFromPtr_Ptr_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CommentType", p))
}

// Converters for pointer handles for type: *uniprot.Component
func ptrFromHandle_Ptr_uniprot_Component(h CGoHandle) *uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Component")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Component{})).(*uniprot.Component)
}
func handleFromPtr_Ptr_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Component", p))
}

// Converters for pointer handles for type: *uniprot.Conflict
func ptrFromHandle_Ptr_uniprot_Conflict(h CGoHandle) *uniprot.Conflict {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Conflict")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Conflict{})).(*uniprot.Conflict)
}
func handleFromPtr_Ptr_uniprot_Conflict(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Conflict", p))
}

// Converters for pointer handles for type: *uniprot.ConsortiumType
func ptrFromHandle_Ptr_uniprot_ConsortiumType(h CGoHandle) *uniprot.ConsortiumType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ConsortiumType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ConsortiumType{})).(*uniprot.ConsortiumType)
}
func handleFromPtr_Ptr_uniprot_ConsortiumType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ConsortiumType", p))
}

// Converters for pointer handles for type: *uniprot.DbReferenceType
func ptrFromHandle_Ptr_uniprot_DbReferenceType(h CGoHandle) *uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.DbReferenceType{})).(*uniprot.DbReferenceType)
}
func handleFromPtr_Ptr_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.DbReferenceType", p))
}

// Converters for pointer handles for type: *uniprot.Disease
func ptrFromHandle_Ptr_uniprot_Disease(h CGoHandle) *uniprot.Disease {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Disease")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Disease{})).(*uniprot.Disease)
}
func handleFromPtr_Ptr_uniprot_Disease(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Disease", p))
}

// Converters for pointer handles for type: *uniprot.Domain
func ptrFromHandle_Ptr_uniprot_Domain(h CGoHandle) *uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Domain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Domain{})).(*uniprot.Domain)
}
func handleFromPtr_Ptr_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Domain", p))
}

// Converters for pointer handles for type: *uniprot.Entry
func ptrFromHandle_Ptr_uniprot_Entry(h CGoHandle) *uniprot.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry)
}
func handleFromPtr_Ptr_uniprot_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Entry", p))
}

// Converters for pointer handles for type: *uniprot.EventType
func ptrFromHandle_Ptr_uniprot_EventType(h CGoHandle) *uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EventType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EventType{})).(*uniprot.EventType)
}
func handleFromPtr_Ptr_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EventType", p))
}

// Converters for pointer handles for type: *uniprot.EvidenceType
func ptrFromHandle_Ptr_uniprot_EvidenceType(h CGoHandle) *uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidenceType{})).(*uniprot.EvidenceType)
}
func handleFromPtr_Ptr_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EvidenceType", p))
}

// Converters for pointer handles for type: *uniprot.EvidencedStringType
func ptrFromHandle_Ptr_uniprot_EvidencedStringType(h CGoHandle) *uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidencedStringType{})).(*uniprot.EvidencedStringType)
}
func handleFromPtr_Ptr_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EvidencedStringType", p))
}

// Converters for pointer handles for type: *uniprot.FeatureType
func ptrFromHandle_Ptr_uniprot_FeatureType(h CGoHandle) *uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.FeatureType{})).(*uniprot.FeatureType)
}
func handleFromPtr_Ptr_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.FeatureType", p))
}

// Converters for pointer handles for type: *uniprot.GeneLocationType
func ptrFromHandle_Ptr_uniprot_GeneLocationType(h CGoHandle) *uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneLocationType{})).(*uniprot.GeneLocationType)
}
func handleFromPtr_Ptr_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneLocationType", p))
}

// Converters for pointer handles for type: *uniprot.GeneNameType
func ptrFromHandle_Ptr_uniprot_GeneNameType(h CGoHandle) *uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneNameType{})).(*uniprot.GeneNameType)
}
func handleFromPtr_Ptr_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneNameType", p))
}

// Converters for pointer handles for type: *uniprot.GeneType
func ptrFromHandle_Ptr_uniprot_GeneType(h CGoHandle) *uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneType{})).(*uniprot.GeneType)
}
func handleFromPtr_Ptr_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneType", p))
}

// Converters for pointer handles for type: *uniprot.ImportedFromType
func ptrFromHandle_Ptr_uniprot_ImportedFromType(h CGoHandle) *uniprot.ImportedFromType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ImportedFromType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ImportedFromType{})).(*uniprot.ImportedFromType)
}
func handleFromPtr_Ptr_uniprot_ImportedFromType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ImportedFromType", p))
}

// Converters for pointer handles for type: *uniprot.IntListType
func ptrFromHandle_Ptr_uniprot_IntListType(h CGoHandle) *uniprot.IntListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.IntListType")
	if p == nil {
		return nil
	}
	return p.(*uniprot.IntListType)
}
func handleFromPtr_Ptr_uniprot_IntListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.IntListType", p))
}

// Converters for pointer handles for type: *uniprot.InteractantType
func ptrFromHandle_Ptr_uniprot_InteractantType(h CGoHandle) *uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.InteractantType{})).(*uniprot.InteractantType)
}
func handleFromPtr_Ptr_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.InteractantType", p))
}

// Converters for pointer handles for type: *uniprot.IsoformType
func ptrFromHandle_Ptr_uniprot_IsoformType(h CGoHandle) *uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.IsoformType{})).(*uniprot.IsoformType)
}
func handleFromPtr_Ptr_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.IsoformType", p))
}

// Converters for pointer handles for type: *uniprot.KeywordType
func ptrFromHandle_Ptr_uniprot_KeywordType(h CGoHandle) *uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.KeywordType{})).(*uniprot.KeywordType)
}
func handleFromPtr_Ptr_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.KeywordType", p))
}

// Converters for pointer handles for type: *uniprot.Kinetics
func ptrFromHandle_Ptr_uniprot_Kinetics(h CGoHandle) *uniprot.Kinetics {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Kinetics")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Kinetics{})).(*uniprot.Kinetics)
}
func handleFromPtr_Ptr_uniprot_Kinetics(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Kinetics", p))
}

// Converters for pointer handles for type: *uniprot.Lineage
func ptrFromHandle_Ptr_uniprot_Lineage(h CGoHandle) *uniprot.Lineage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Lineage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Lineage{})).(*uniprot.Lineage)
}
func handleFromPtr_Ptr_uniprot_Lineage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Lineage", p))
}

// Converters for pointer handles for type: *uniprot.Link
func ptrFromHandle_Ptr_uniprot_Link(h CGoHandle) *uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Link")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Link{})).(*uniprot.Link)
}
func handleFromPtr_Ptr_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Link", p))
}

// Converters for pointer handles for type: *uniprot.LocationType
func ptrFromHandle_Ptr_uniprot_LocationType(h CGoHandle) *uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.LocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.LocationType{})).(*uniprot.LocationType)
}
func handleFromPtr_Ptr_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.LocationType", p))
}

// Converters for pointer handles for type: *uniprot.Name
func ptrFromHandle_Ptr_uniprot_Name(h CGoHandle) *uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Name{})).(*uniprot.Name)
}
func handleFromPtr_Ptr_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Name", p))
}

// Converters for pointer handles for type: *uniprot.NameListType
func ptrFromHandle_Ptr_uniprot_NameListType(h CGoHandle) *uniprot.NameListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.NameListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.NameListType{})).(*uniprot.NameListType)
}
func handleFromPtr_Ptr_uniprot_NameListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.NameListType", p))
}

// Converters for pointer handles for type: *uniprot.OrganismNameType
func ptrFromHandle_Ptr_uniprot_OrganismNameType(h CGoHandle) *uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismNameType{})).(*uniprot.OrganismNameType)
}
func handleFromPtr_Ptr_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.OrganismNameType", p))
}

// Converters for pointer handles for type: *uniprot.OrganismType
func ptrFromHandle_Ptr_uniprot_OrganismType(h CGoHandle) *uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismType{})).(*uniprot.OrganismType)
}
func handleFromPtr_Ptr_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.OrganismType", p))
}

// Converters for pointer handles for type: *uniprot.PersonType
func ptrFromHandle_Ptr_uniprot_PersonType(h CGoHandle) *uniprot.PersonType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PersonType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PersonType{})).(*uniprot.PersonType)
}
func handleFromPtr_Ptr_uniprot_PersonType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PersonType", p))
}

// Converters for pointer handles for type: *uniprot.PhDependence
func ptrFromHandle_Ptr_uniprot_PhDependence(h CGoHandle) *uniprot.PhDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PhDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhDependence{})).(*uniprot.PhDependence)
}
func handleFromPtr_Ptr_uniprot_PhDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PhDependence", p))
}

// Converters for pointer handles for type: *uniprot.PhysiologicalReactionType
func ptrFromHandle_Ptr_uniprot_PhysiologicalReactionType(h CGoHandle) *uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhysiologicalReactionType{})).(*uniprot.PhysiologicalReactionType)
}
func handleFromPtr_Ptr_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PhysiologicalReactionType", p))
}

// Converters for pointer handles for type: *uniprot.Plasmid
func ptrFromHandle_Ptr_uniprot_Plasmid(h CGoHandle) *uniprot.Plasmid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Plasmid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Plasmid{})).(*uniprot.Plasmid)
}
func handleFromPtr_Ptr_uniprot_Plasmid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Plasmid", p))
}

// Converters for pointer handles for type: *uniprot.PositionType
func ptrFromHandle_Ptr_uniprot_PositionType(h CGoHandle) *uniprot.PositionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PositionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType)
}
func handleFromPtr_Ptr_uniprot_PositionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PositionType", p))
}

// Converters for pointer handles for type: *uniprot.PropertyType
func ptrFromHandle_Ptr_uniprot_PropertyType(h CGoHandle) *uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PropertyType{})).(*uniprot.PropertyType)
}
func handleFromPtr_Ptr_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PropertyType", p))
}

// Converters for pointer handles for type: *uniprot.ProteinExistenceType
func ptrFromHandle_Ptr_uniprot_ProteinExistenceType(h CGoHandle) *uniprot.ProteinExistenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ProteinExistenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinExistenceType{})).(*uniprot.ProteinExistenceType)
}
func handleFromPtr_Ptr_uniprot_ProteinExistenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ProteinExistenceType", p))
}

// Converters for pointer handles for type: *uniprot.ProteinType
func ptrFromHandle_Ptr_uniprot_ProteinType(h CGoHandle) *uniprot.ProteinType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ProteinType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinType{})).(*uniprot.ProteinType)
}
func handleFromPtr_Ptr_uniprot_ProteinType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ProteinType", p))
}

// Converters for pointer handles for type: *uniprot.ReactionType
func ptrFromHandle_Ptr_uniprot_ReactionType(h CGoHandle) *uniprot.ReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReactionType{})).(*uniprot.ReactionType)
}
func handleFromPtr_Ptr_uniprot_ReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ReactionType", p))
}

// Converters for pointer handles for type: *uniprot.RecommendedName
func ptrFromHandle_Ptr_uniprot_RecommendedName(h CGoHandle) *uniprot.RecommendedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.RecommendedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RecommendedName{})).(*uniprot.RecommendedName)
}
func handleFromPtr_Ptr_uniprot_RecommendedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.RecommendedName", p))
}

// Converters for pointer handles for type: *uniprot.RedoxPotential
func ptrFromHandle_Ptr_uniprot_RedoxPotential(h CGoHandle) *uniprot.RedoxPotential {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.RedoxPotential")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RedoxPotential{})).(*uniprot.RedoxPotential)
}
func handleFromPtr_Ptr_uniprot_RedoxPotential(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.RedoxPotential", p))
}

// Converters for pointer handles for type: *uniprot.ReferenceType
func ptrFromHandle_Ptr_uniprot_ReferenceType(h CGoHandle) *uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReferenceType{})).(*uniprot.ReferenceType)
}
func handleFromPtr_Ptr_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ReferenceType", p))
}

// Converters for pointer handles for type: *uniprot.Sequence
func ptrFromHandle_Ptr_uniprot_Sequence(h CGoHandle) *uniprot.Sequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Sequence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Sequence{})).(*uniprot.Sequence)
}
func handleFromPtr_Ptr_uniprot_Sequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Sequence", p))
}

// Converters for pointer handles for type: *uniprot.SequenceType
func ptrFromHandle_Ptr_uniprot_SequenceType(h CGoHandle) *uniprot.SequenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SequenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType)
}
func handleFromPtr_Ptr_uniprot_SequenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SequenceType", p))
}

// Converters for pointer handles for type: *uniprot.SourceDataType
func ptrFromHandle_Ptr_uniprot_SourceDataType(h CGoHandle) *uniprot.SourceDataType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SourceDataType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceDataType{})).(*uniprot.SourceDataType)
}
func handleFromPtr_Ptr_uniprot_SourceDataType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SourceDataType", p))
}

// Converters for pointer handles for type: *uniprot.SourceType
func ptrFromHandle_Ptr_uniprot_SourceType(h CGoHandle) *uniprot.SourceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SourceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceType{})).(*uniprot.SourceType)
}
func handleFromPtr_Ptr_uniprot_SourceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SourceType", p))
}

// Converters for pointer handles for type: *uniprot.StatusType
func ptrFromHandle_Ptr_uniprot_StatusType(h CGoHandle) *uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.StatusType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.StatusType{})).(*uniprot.StatusType)
}
func handleFromPtr_Ptr_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.StatusType", p))
}

// Converters for pointer handles for type: *uniprot.Strain
func ptrFromHandle_Ptr_uniprot_Strain(h CGoHandle) *uniprot.Strain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Strain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Strain{})).(*uniprot.Strain)
}
func handleFromPtr_Ptr_uniprot_Strain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Strain", p))
}

// Converters for pointer handles for type: *uniprot.SubcellularLocationType
func ptrFromHandle_Ptr_uniprot_SubcellularLocationType(h CGoHandle) *uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubcellularLocationType{})).(*uniprot.SubcellularLocationType)
}
func handleFromPtr_Ptr_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SubcellularLocationType", p))
}

// Converters for pointer handles for type: *uniprot.SubmittedName
func ptrFromHandle_Ptr_uniprot_SubmittedName(h CGoHandle) *uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubmittedName{})).(*uniprot.SubmittedName)
}
func handleFromPtr_Ptr_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SubmittedName", p))
}

// Converters for pointer handles for type: *uniprot.TemperatureDependence
func ptrFromHandle_Ptr_uniprot_TemperatureDependence(h CGoHandle) *uniprot.TemperatureDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.TemperatureDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.TemperatureDependence{})).(*uniprot.TemperatureDependence)
}
func handleFromPtr_Ptr_uniprot_TemperatureDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.TemperatureDependence", p))
}

// Converters for pointer handles for type: *uniprot.Tissue
func ptrFromHandle_Ptr_uniprot_Tissue(h CGoHandle) *uniprot.Tissue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Tissue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Tissue{})).(*uniprot.Tissue)
}
func handleFromPtr_Ptr_uniprot_Tissue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Tissue", p))
}

// Converters for pointer handles for type: *uniprot.Transposon
func ptrFromHandle_Ptr_uniprot_Transposon(h CGoHandle) *uniprot.Transposon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Transposon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Transposon{})).(*uniprot.Transposon)
}
func handleFromPtr_Ptr_uniprot_Transposon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Transposon", p))
}

// Converters for pointer handles for type: *uniprot.Uniprot
func ptrFromHandle_Ptr_uniprot_Uniprot(h CGoHandle) *uniprot.Uniprot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Uniprot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Uniprot{})).(*uniprot.Uniprot)
}
func handleFromPtr_Ptr_uniprot_Uniprot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Uniprot", p))
}

// Converters for implicit pointer handles for type: []xml.Attr
func ptrFromHandle_Slice_xml_Attr(h CGoHandle) *[]xml.Attr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]xml.Attr")
	if p == nil {
		return nil
	}
	return p.(*[]xml.Attr)
}
func deptrFromHandle_Slice_xml_Attr(h CGoHandle) []xml.Attr {
	p := ptrFromHandle_Slice_xml_Attr(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_xml_Attr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]xml.Attr", p))
}

// --- wrapping slice: []xml.Attr ---
//
//export Slice_xml_Attr_CTor
func Slice_xml_Attr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_xml_Attr(&[]xml.Attr{}))
}

//export Slice_xml_Attr_len
func Slice_xml_Attr_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_xml_Attr(handle))
}

//export Slice_xml_Attr_elem
func Slice_xml_Attr_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	return handleFromPtr_xml_Attr(&(s[_idx]))
}

//export Slice_xml_Attr_subslice
func Slice_xml_Attr_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_xml_Attr(&ss))
}

//export Slice_xml_Attr_set
func Slice_xml_Attr_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	s[_idx] = *ptrFromHandle_xml_Attr(_vl)
}

//export Slice_xml_Attr_append
func Slice_xml_Attr_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_xml_Attr(handle)
	*s = append(*s, *ptrFromHandle_xml_Attr(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.AlternativeName
func ptrFromHandle_Slice_uniprot_AlternativeName(h CGoHandle) *[]uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.AlternativeName)
}
func deptrFromHandle_Slice_uniprot_AlternativeName(h CGoHandle) []uniprot.AlternativeName {
	p := ptrFromHandle_Slice_uniprot_AlternativeName(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.AlternativeName", p))
}

// --- wrapping slice: []uniprot.AlternativeName ---
//
//export Slice_uniprot_AlternativeName_CTor
func Slice_uniprot_AlternativeName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_AlternativeName(&[]uniprot.AlternativeName{}))
}

//export Slice_uniprot_AlternativeName_len
func Slice_uniprot_AlternativeName_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_AlternativeName(handle))
}

//export Slice_uniprot_AlternativeName_elem
func Slice_uniprot_AlternativeName_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	return handleFromPtr_uniprot_AlternativeName(&(s[_idx]))
}

//export Slice_uniprot_AlternativeName_subslice
func Slice_uniprot_AlternativeName_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_AlternativeName(&ss))
}

//export Slice_uniprot_AlternativeName_set
func Slice_uniprot_AlternativeName_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	s[_idx] = *ptrFromHandle_uniprot_AlternativeName(_vl)
}

//export Slice_uniprot_AlternativeName_append
func Slice_uniprot_AlternativeName_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_AlternativeName(handle)
	*s = append(*s, *ptrFromHandle_uniprot_AlternativeName(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.CofactorType
func ptrFromHandle_Slice_uniprot_CofactorType(h CGoHandle) *[]uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.CofactorType)
}
func deptrFromHandle_Slice_uniprot_CofactorType(h CGoHandle) []uniprot.CofactorType {
	p := ptrFromHandle_Slice_uniprot_CofactorType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.CofactorType", p))
}

// --- wrapping slice: []uniprot.CofactorType ---
//
//export Slice_uniprot_CofactorType_CTor
func Slice_uniprot_CofactorType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_CofactorType(&[]uniprot.CofactorType{}))
}

//export Slice_uniprot_CofactorType_len
func Slice_uniprot_CofactorType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_CofactorType(handle))
}

//export Slice_uniprot_CofactorType_elem
func Slice_uniprot_CofactorType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_CofactorType(&(s[_idx]))
}

//export Slice_uniprot_CofactorType_subslice
func Slice_uniprot_CofactorType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_CofactorType(&ss))
}

//export Slice_uniprot_CofactorType_set
func Slice_uniprot_CofactorType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	s[_idx] = *ptrFromHandle_uniprot_CofactorType(_vl)
}

//export Slice_uniprot_CofactorType_append
func Slice_uniprot_CofactorType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_CofactorType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_CofactorType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.CommentType
func ptrFromHandle_Slice_uniprot_CommentType(h CGoHandle) *[]uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.CommentType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.CommentType)
}
func deptrFromHandle_Slice_uniprot_CommentType(h CGoHandle) []uniprot.CommentType {
	p := ptrFromHandle_Slice_uniprot_CommentType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.CommentType", p))
}

// --- wrapping slice: []uniprot.CommentType ---
//
//export Slice_uniprot_CommentType_CTor
func Slice_uniprot_CommentType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_CommentType(&[]uniprot.CommentType{}))
}

//export Slice_uniprot_CommentType_len
func Slice_uniprot_CommentType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_CommentType(handle))
}

//export Slice_uniprot_CommentType_elem
func Slice_uniprot_CommentType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_CommentType(&(s[_idx]))
}

//export Slice_uniprot_CommentType_subslice
func Slice_uniprot_CommentType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_CommentType(&ss))
}

//export Slice_uniprot_CommentType_set
func Slice_uniprot_CommentType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	s[_idx] = *ptrFromHandle_uniprot_CommentType(_vl)
}

//export Slice_uniprot_CommentType_append
func Slice_uniprot_CommentType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_CommentType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_CommentType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Component
func ptrFromHandle_Slice_uniprot_Component(h CGoHandle) *[]uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Component")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Component)
}
func deptrFromHandle_Slice_uniprot_Component(h CGoHandle) []uniprot.Component {
	p := ptrFromHandle_Slice_uniprot_Component(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Component", p))
}

// --- wrapping slice: []uniprot.Component ---
//
//export Slice_uniprot_Component_CTor
func Slice_uniprot_Component_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Component(&[]uniprot.Component{}))
}

//export Slice_uniprot_Component_len
func Slice_uniprot_Component_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Component(handle))
}

//export Slice_uniprot_Component_elem
func Slice_uniprot_Component_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	return handleFromPtr_uniprot_Component(&(s[_idx]))
}

//export Slice_uniprot_Component_subslice
func Slice_uniprot_Component_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Component(&ss))
}

//export Slice_uniprot_Component_set
func Slice_uniprot_Component_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	s[_idx] = *ptrFromHandle_uniprot_Component(_vl)
}

//export Slice_uniprot_Component_append
func Slice_uniprot_Component_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Component(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Component(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.DbReferenceType
func ptrFromHandle_Slice_uniprot_DbReferenceType(h CGoHandle) *[]uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.DbReferenceType)
}
func deptrFromHandle_Slice_uniprot_DbReferenceType(h CGoHandle) []uniprot.DbReferenceType {
	p := ptrFromHandle_Slice_uniprot_DbReferenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.DbReferenceType", p))
}

// --- wrapping slice: []uniprot.DbReferenceType ---
//
//export Slice_uniprot_DbReferenceType_CTor
func Slice_uniprot_DbReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_DbReferenceType(&[]uniprot.DbReferenceType{}))
}

//export Slice_uniprot_DbReferenceType_len
func Slice_uniprot_DbReferenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_DbReferenceType(handle))
}

//export Slice_uniprot_DbReferenceType_elem
func Slice_uniprot_DbReferenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&(s[_idx]))
}

//export Slice_uniprot_DbReferenceType_subslice
func Slice_uniprot_DbReferenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_DbReferenceType(&ss))
}

//export Slice_uniprot_DbReferenceType_set
func Slice_uniprot_DbReferenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_DbReferenceType(_vl)
}

//export Slice_uniprot_DbReferenceType_append
func Slice_uniprot_DbReferenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_DbReferenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Domain
func ptrFromHandle_Slice_uniprot_Domain(h CGoHandle) *[]uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Domain")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Domain)
}
func deptrFromHandle_Slice_uniprot_Domain(h CGoHandle) []uniprot.Domain {
	p := ptrFromHandle_Slice_uniprot_Domain(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Domain", p))
}

// --- wrapping slice: []uniprot.Domain ---
//
//export Slice_uniprot_Domain_CTor
func Slice_uniprot_Domain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Domain(&[]uniprot.Domain{}))
}

//export Slice_uniprot_Domain_len
func Slice_uniprot_Domain_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Domain(handle))
}

//export Slice_uniprot_Domain_elem
func Slice_uniprot_Domain_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	return handleFromPtr_uniprot_Domain(&(s[_idx]))
}

//export Slice_uniprot_Domain_subslice
func Slice_uniprot_Domain_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Domain(&ss))
}

//export Slice_uniprot_Domain_set
func Slice_uniprot_Domain_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	s[_idx] = *ptrFromHandle_uniprot_Domain(_vl)
}

//export Slice_uniprot_Domain_append
func Slice_uniprot_Domain_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Domain(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Domain(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EventType
func ptrFromHandle_Slice_uniprot_EventType(h CGoHandle) *[]uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EventType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EventType)
}
func deptrFromHandle_Slice_uniprot_EventType(h CGoHandle) []uniprot.EventType {
	p := ptrFromHandle_Slice_uniprot_EventType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EventType", p))
}

// --- wrapping slice: []uniprot.EventType ---
//
//export Slice_uniprot_EventType_CTor
func Slice_uniprot_EventType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EventType(&[]uniprot.EventType{}))
}

//export Slice_uniprot_EventType_len
func Slice_uniprot_EventType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EventType(handle))
}

//export Slice_uniprot_EventType_elem
func Slice_uniprot_EventType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	return handleFromPtr_uniprot_EventType(&(s[_idx]))
}

//export Slice_uniprot_EventType_subslice
func Slice_uniprot_EventType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EventType(&ss))
}

//export Slice_uniprot_EventType_set
func Slice_uniprot_EventType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EventType(_vl)
}

//export Slice_uniprot_EventType_append
func Slice_uniprot_EventType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EventType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EventType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EvidenceType
func ptrFromHandle_Slice_uniprot_EvidenceType(h CGoHandle) *[]uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EvidenceType)
}
func deptrFromHandle_Slice_uniprot_EvidenceType(h CGoHandle) []uniprot.EvidenceType {
	p := ptrFromHandle_Slice_uniprot_EvidenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EvidenceType", p))
}

// --- wrapping slice: []uniprot.EvidenceType ---
//
//export Slice_uniprot_EvidenceType_CTor
func Slice_uniprot_EvidenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidenceType(&[]uniprot.EvidenceType{}))
}

//export Slice_uniprot_EvidenceType_len
func Slice_uniprot_EvidenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EvidenceType(handle))
}

//export Slice_uniprot_EvidenceType_elem
func Slice_uniprot_EvidenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_EvidenceType(&(s[_idx]))
}

//export Slice_uniprot_EvidenceType_subslice
func Slice_uniprot_EvidenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidenceType(&ss))
}

//export Slice_uniprot_EvidenceType_set
func Slice_uniprot_EvidenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EvidenceType(_vl)
}

//export Slice_uniprot_EvidenceType_append
func Slice_uniprot_EvidenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EvidenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EvidenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EvidencedStringType
func ptrFromHandle_Slice_uniprot_EvidencedStringType(h CGoHandle) *[]uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EvidencedStringType)
}
func deptrFromHandle_Slice_uniprot_EvidencedStringType(h CGoHandle) []uniprot.EvidencedStringType {
	p := ptrFromHandle_Slice_uniprot_EvidencedStringType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EvidencedStringType", p))
}

// --- wrapping slice: []uniprot.EvidencedStringType ---
//
//export Slice_uniprot_EvidencedStringType_CTor
func Slice_uniprot_EvidencedStringType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidencedStringType(&[]uniprot.EvidencedStringType{}))
}

//export Slice_uniprot_EvidencedStringType_len
func Slice_uniprot_EvidencedStringType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EvidencedStringType(handle))
}

//export Slice_uniprot_EvidencedStringType_elem
func Slice_uniprot_EvidencedStringType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&(s[_idx]))
}

//export Slice_uniprot_EvidencedStringType_subslice
func Slice_uniprot_EvidencedStringType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidencedStringType(&ss))
}

//export Slice_uniprot_EvidencedStringType_set
func Slice_uniprot_EvidencedStringType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EvidencedStringType(_vl)
}

//export Slice_uniprot_EvidencedStringType_append
func Slice_uniprot_EvidencedStringType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EvidencedStringType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.FeatureType
func ptrFromHandle_Slice_uniprot_FeatureType(h CGoHandle) *[]uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.FeatureType)
}
func deptrFromHandle_Slice_uniprot_FeatureType(h CGoHandle) []uniprot.FeatureType {
	p := ptrFromHandle_Slice_uniprot_FeatureType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.FeatureType", p))
}

// --- wrapping slice: []uniprot.FeatureType ---
//
//export Slice_uniprot_FeatureType_CTor
func Slice_uniprot_FeatureType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_FeatureType(&[]uniprot.FeatureType{}))
}

//export Slice_uniprot_FeatureType_len
func Slice_uniprot_FeatureType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_FeatureType(handle))
}

//export Slice_uniprot_FeatureType_elem
func Slice_uniprot_FeatureType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_FeatureType(&(s[_idx]))
}

//export Slice_uniprot_FeatureType_subslice
func Slice_uniprot_FeatureType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_FeatureType(&ss))
}

//export Slice_uniprot_FeatureType_set
func Slice_uniprot_FeatureType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	s[_idx] = *ptrFromHandle_uniprot_FeatureType(_vl)
}

//export Slice_uniprot_FeatureType_append
func Slice_uniprot_FeatureType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_FeatureType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_FeatureType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneLocationType
func ptrFromHandle_Slice_uniprot_GeneLocationType(h CGoHandle) *[]uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneLocationType)
}
func deptrFromHandle_Slice_uniprot_GeneLocationType(h CGoHandle) []uniprot.GeneLocationType {
	p := ptrFromHandle_Slice_uniprot_GeneLocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneLocationType", p))
}

// --- wrapping slice: []uniprot.GeneLocationType ---
//
//export Slice_uniprot_GeneLocationType_CTor
func Slice_uniprot_GeneLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneLocationType(&[]uniprot.GeneLocationType{}))
}

//export Slice_uniprot_GeneLocationType_len
func Slice_uniprot_GeneLocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneLocationType(handle))
}

//export Slice_uniprot_GeneLocationType_elem
func Slice_uniprot_GeneLocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	return handleFromPtr_uniprot_GeneLocationType(&(s[_idx]))
}

//export Slice_uniprot_GeneLocationType_subslice
func Slice_uniprot_GeneLocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneLocationType(&ss))
}

//export Slice_uniprot_GeneLocationType_set
func Slice_uniprot_GeneLocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneLocationType(_vl)
}

//export Slice_uniprot_GeneLocationType_append
func Slice_uniprot_GeneLocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneLocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneNameType
func ptrFromHandle_Slice_uniprot_GeneNameType(h CGoHandle) *[]uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneNameType)
}
func deptrFromHandle_Slice_uniprot_GeneNameType(h CGoHandle) []uniprot.GeneNameType {
	p := ptrFromHandle_Slice_uniprot_GeneNameType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneNameType", p))
}

// --- wrapping slice: []uniprot.GeneNameType ---
//
//export Slice_uniprot_GeneNameType_CTor
func Slice_uniprot_GeneNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneNameType(&[]uniprot.GeneNameType{}))
}

//export Slice_uniprot_GeneNameType_len
func Slice_uniprot_GeneNameType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneNameType(handle))
}

//export Slice_uniprot_GeneNameType_elem
func Slice_uniprot_GeneNameType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	return handleFromPtr_uniprot_GeneNameType(&(s[_idx]))
}

//export Slice_uniprot_GeneNameType_subslice
func Slice_uniprot_GeneNameType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneNameType(&ss))
}

//export Slice_uniprot_GeneNameType_set
func Slice_uniprot_GeneNameType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneNameType(_vl)
}

//export Slice_uniprot_GeneNameType_append
func Slice_uniprot_GeneNameType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneNameType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneNameType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneType
func ptrFromHandle_Slice_uniprot_GeneType(h CGoHandle) *[]uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneType)
}
func deptrFromHandle_Slice_uniprot_GeneType(h CGoHandle) []uniprot.GeneType {
	p := ptrFromHandle_Slice_uniprot_GeneType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneType", p))
}

// --- wrapping slice: []uniprot.GeneType ---
//
//export Slice_uniprot_GeneType_CTor
func Slice_uniprot_GeneType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneType(&[]uniprot.GeneType{}))
}

//export Slice_uniprot_GeneType_len
func Slice_uniprot_GeneType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneType(handle))
}

//export Slice_uniprot_GeneType_elem
func Slice_uniprot_GeneType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	return handleFromPtr_uniprot_GeneType(&(s[_idx]))
}

//export Slice_uniprot_GeneType_subslice
func Slice_uniprot_GeneType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneType(&ss))
}

//export Slice_uniprot_GeneType_set
func Slice_uniprot_GeneType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneType(_vl)
}

//export Slice_uniprot_GeneType_append
func Slice_uniprot_GeneType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.InteractantType
func ptrFromHandle_Slice_uniprot_InteractantType(h CGoHandle) *[]uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.InteractantType)
}
func deptrFromHandle_Slice_uniprot_InteractantType(h CGoHandle) []uniprot.InteractantType {
	p := ptrFromHandle_Slice_uniprot_InteractantType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.InteractantType", p))
}

// --- wrapping slice: []uniprot.InteractantType ---
//
//export Slice_uniprot_InteractantType_CTor
func Slice_uniprot_InteractantType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_InteractantType(&[]uniprot.InteractantType{}))
}

//export Slice_uniprot_InteractantType_len
func Slice_uniprot_InteractantType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_InteractantType(handle))
}

//export Slice_uniprot_InteractantType_elem
func Slice_uniprot_InteractantType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	return handleFromPtr_uniprot_InteractantType(&(s[_idx]))
}

//export Slice_uniprot_InteractantType_subslice
func Slice_uniprot_InteractantType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_InteractantType(&ss))
}

//export Slice_uniprot_InteractantType_set
func Slice_uniprot_InteractantType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	s[_idx] = *ptrFromHandle_uniprot_InteractantType(_vl)
}

//export Slice_uniprot_InteractantType_append
func Slice_uniprot_InteractantType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_InteractantType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_InteractantType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.IsoformType
func ptrFromHandle_Slice_uniprot_IsoformType(h CGoHandle) *[]uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.IsoformType)
}
func deptrFromHandle_Slice_uniprot_IsoformType(h CGoHandle) []uniprot.IsoformType {
	p := ptrFromHandle_Slice_uniprot_IsoformType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.IsoformType", p))
}

// --- wrapping slice: []uniprot.IsoformType ---
//
//export Slice_uniprot_IsoformType_CTor
func Slice_uniprot_IsoformType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_IsoformType(&[]uniprot.IsoformType{}))
}

//export Slice_uniprot_IsoformType_len
func Slice_uniprot_IsoformType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_IsoformType(handle))
}

//export Slice_uniprot_IsoformType_elem
func Slice_uniprot_IsoformType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	return handleFromPtr_uniprot_IsoformType(&(s[_idx]))
}

//export Slice_uniprot_IsoformType_subslice
func Slice_uniprot_IsoformType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_IsoformType(&ss))
}

//export Slice_uniprot_IsoformType_set
func Slice_uniprot_IsoformType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	s[_idx] = *ptrFromHandle_uniprot_IsoformType(_vl)
}

//export Slice_uniprot_IsoformType_append
func Slice_uniprot_IsoformType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_IsoformType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_IsoformType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.KeywordType
func ptrFromHandle_Slice_uniprot_KeywordType(h CGoHandle) *[]uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.KeywordType)
}
func deptrFromHandle_Slice_uniprot_KeywordType(h CGoHandle) []uniprot.KeywordType {
	p := ptrFromHandle_Slice_uniprot_KeywordType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.KeywordType", p))
}

// --- wrapping slice: []uniprot.KeywordType ---
//
//export Slice_uniprot_KeywordType_CTor
func Slice_uniprot_KeywordType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_KeywordType(&[]uniprot.KeywordType{}))
}

//export Slice_uniprot_KeywordType_len
func Slice_uniprot_KeywordType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_KeywordType(handle))
}

//export Slice_uniprot_KeywordType_elem
func Slice_uniprot_KeywordType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	return handleFromPtr_uniprot_KeywordType(&(s[_idx]))
}

//export Slice_uniprot_KeywordType_subslice
func Slice_uniprot_KeywordType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_KeywordType(&ss))
}

//export Slice_uniprot_KeywordType_set
func Slice_uniprot_KeywordType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	s[_idx] = *ptrFromHandle_uniprot_KeywordType(_vl)
}

//export Slice_uniprot_KeywordType_append
func Slice_uniprot_KeywordType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_KeywordType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_KeywordType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Link
func ptrFromHandle_Slice_uniprot_Link(h CGoHandle) *[]uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Link")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Link)
}
func deptrFromHandle_Slice_uniprot_Link(h CGoHandle) []uniprot.Link {
	p := ptrFromHandle_Slice_uniprot_Link(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Link", p))
}

// --- wrapping slice: []uniprot.Link ---
//
//export Slice_uniprot_Link_CTor
func Slice_uniprot_Link_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Link(&[]uniprot.Link{}))
}

//export Slice_uniprot_Link_len
func Slice_uniprot_Link_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Link(handle))
}

//export Slice_uniprot_Link_elem
func Slice_uniprot_Link_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	return handleFromPtr_uniprot_Link(&(s[_idx]))
}

//export Slice_uniprot_Link_subslice
func Slice_uniprot_Link_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Link(&ss))
}

//export Slice_uniprot_Link_set
func Slice_uniprot_Link_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	s[_idx] = *ptrFromHandle_uniprot_Link(_vl)
}

//export Slice_uniprot_Link_append
func Slice_uniprot_Link_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Link(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Link(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.LocationType
func ptrFromHandle_Slice_uniprot_LocationType(h CGoHandle) *[]uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.LocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.LocationType)
}
func deptrFromHandle_Slice_uniprot_LocationType(h CGoHandle) []uniprot.LocationType {
	p := ptrFromHandle_Slice_uniprot_LocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.LocationType", p))
}

// --- wrapping slice: []uniprot.LocationType ---
//
//export Slice_uniprot_LocationType_CTor
func Slice_uniprot_LocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_LocationType(&[]uniprot.LocationType{}))
}

//export Slice_uniprot_LocationType_len
func Slice_uniprot_LocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_LocationType(handle))
}

//export Slice_uniprot_LocationType_elem
func Slice_uniprot_LocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_LocationType(&(s[_idx]))
}

//export Slice_uniprot_LocationType_subslice
func Slice_uniprot_LocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_LocationType(&ss))
}

//export Slice_uniprot_LocationType_set
func Slice_uniprot_LocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_LocationType(_vl)
}

//export Slice_uniprot_LocationType_append
func Slice_uniprot_LocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_LocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_LocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Name
func ptrFromHandle_Slice_uniprot_Name(h CGoHandle) *[]uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Name")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Name)
}
func deptrFromHandle_Slice_uniprot_Name(h CGoHandle) []uniprot.Name {
	p := ptrFromHandle_Slice_uniprot_Name(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Name", p))
}

// --- wrapping slice: []uniprot.Name ---
//
//export Slice_uniprot_Name_CTor
func Slice_uniprot_Name_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Name(&[]uniprot.Name{}))
}

//export Slice_uniprot_Name_len
func Slice_uniprot_Name_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Name(handle))
}

//export Slice_uniprot_Name_elem
func Slice_uniprot_Name_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	return handleFromPtr_uniprot_Name(&(s[_idx]))
}

//export Slice_uniprot_Name_subslice
func Slice_uniprot_Name_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Name(&ss))
}

//export Slice_uniprot_Name_set
func Slice_uniprot_Name_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	s[_idx] = *ptrFromHandle_uniprot_Name(_vl)
}

//export Slice_uniprot_Name_append
func Slice_uniprot_Name_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Name(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Name(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.OrganismNameType
func ptrFromHandle_Slice_uniprot_OrganismNameType(h CGoHandle) *[]uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.OrganismNameType)
}
func deptrFromHandle_Slice_uniprot_OrganismNameType(h CGoHandle) []uniprot.OrganismNameType {
	p := ptrFromHandle_Slice_uniprot_OrganismNameType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.OrganismNameType", p))
}

// --- wrapping slice: []uniprot.OrganismNameType ---
//
//export Slice_uniprot_OrganismNameType_CTor
func Slice_uniprot_OrganismNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismNameType(&[]uniprot.OrganismNameType{}))
}

//export Slice_uniprot_OrganismNameType_len
func Slice_uniprot_OrganismNameType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_OrganismNameType(handle))
}

//export Slice_uniprot_OrganismNameType_elem
func Slice_uniprot_OrganismNameType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	return handleFromPtr_uniprot_OrganismNameType(&(s[_idx]))
}

//export Slice_uniprot_OrganismNameType_subslice
func Slice_uniprot_OrganismNameType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismNameType(&ss))
}

//export Slice_uniprot_OrganismNameType_set
func Slice_uniprot_OrganismNameType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	s[_idx] = *ptrFromHandle_uniprot_OrganismNameType(_vl)
}

//export Slice_uniprot_OrganismNameType_append
func Slice_uniprot_OrganismNameType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_OrganismNameType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.OrganismType
func ptrFromHandle_Slice_uniprot_OrganismType(h CGoHandle) *[]uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.OrganismType)
}
func deptrFromHandle_Slice_uniprot_OrganismType(h CGoHandle) []uniprot.OrganismType {
	p := ptrFromHandle_Slice_uniprot_OrganismType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.OrganismType", p))
}

// --- wrapping slice: []uniprot.OrganismType ---
//
//export Slice_uniprot_OrganismType_CTor
func Slice_uniprot_OrganismType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismType(&[]uniprot.OrganismType{}))
}

//export Slice_uniprot_OrganismType_len
func Slice_uniprot_OrganismType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_OrganismType(handle))
}

//export Slice_uniprot_OrganismType_elem
func Slice_uniprot_OrganismType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_OrganismType(&(s[_idx]))
}

//export Slice_uniprot_OrganismType_subslice
func Slice_uniprot_OrganismType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismType(&ss))
}

//export Slice_uniprot_OrganismType_set
func Slice_uniprot_OrganismType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	s[_idx] = *ptrFromHandle_uniprot_OrganismType(_vl)
}

//export Slice_uniprot_OrganismType_append
func Slice_uniprot_OrganismType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_OrganismType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_OrganismType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.PhysiologicalReactionType
func ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h CGoHandle) *[]uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.PhysiologicalReactionType)
}
func deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h CGoHandle) []uniprot.PhysiologicalReactionType {
	p := ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.PhysiologicalReactionType", p))
}

// --- wrapping slice: []uniprot.PhysiologicalReactionType ---
//
//export Slice_uniprot_PhysiologicalReactionType_CTor
func Slice_uniprot_PhysiologicalReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&[]uniprot.PhysiologicalReactionType{}))
}

//export Slice_uniprot_PhysiologicalReactionType_len
func Slice_uniprot_PhysiologicalReactionType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle))
}

//export Slice_uniprot_PhysiologicalReactionType_elem
func Slice_uniprot_PhysiologicalReactionType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_PhysiologicalReactionType(&(s[_idx]))
}

//export Slice_uniprot_PhysiologicalReactionType_subslice
func Slice_uniprot_PhysiologicalReactionType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&ss))
}

//export Slice_uniprot_PhysiologicalReactionType_set
func Slice_uniprot_PhysiologicalReactionType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	s[_idx] = *ptrFromHandle_uniprot_PhysiologicalReactionType(_vl)
}

//export Slice_uniprot_PhysiologicalReactionType_append
func Slice_uniprot_PhysiologicalReactionType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_PhysiologicalReactionType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.PropertyType
func ptrFromHandle_Slice_uniprot_PropertyType(h CGoHandle) *[]uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.PropertyType)
}
func deptrFromHandle_Slice_uniprot_PropertyType(h CGoHandle) []uniprot.PropertyType {
	p := ptrFromHandle_Slice_uniprot_PropertyType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.PropertyType", p))
}

// --- wrapping slice: []uniprot.PropertyType ---
//
//export Slice_uniprot_PropertyType_CTor
func Slice_uniprot_PropertyType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_PropertyType(&[]uniprot.PropertyType{}))
}

//export Slice_uniprot_PropertyType_len
func Slice_uniprot_PropertyType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_PropertyType(handle))
}

//export Slice_uniprot_PropertyType_elem
func Slice_uniprot_PropertyType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	return handleFromPtr_uniprot_PropertyType(&(s[_idx]))
}

//export Slice_uniprot_PropertyType_subslice
func Slice_uniprot_PropertyType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_PropertyType(&ss))
}

//export Slice_uniprot_PropertyType_set
func Slice_uniprot_PropertyType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	s[_idx] = *ptrFromHandle_uniprot_PropertyType(_vl)
}

//export Slice_uniprot_PropertyType_append
func Slice_uniprot_PropertyType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_PropertyType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_PropertyType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.ReferenceType
func ptrFromHandle_Slice_uniprot_ReferenceType(h CGoHandle) *[]uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.ReferenceType)
}
func deptrFromHandle_Slice_uniprot_ReferenceType(h CGoHandle) []uniprot.ReferenceType {
	p := ptrFromHandle_Slice_uniprot_ReferenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.ReferenceType", p))
}

// --- wrapping slice: []uniprot.ReferenceType ---
//
//export Slice_uniprot_ReferenceType_CTor
func Slice_uniprot_ReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_ReferenceType(&[]uniprot.ReferenceType{}))
}

//export Slice_uniprot_ReferenceType_len
func Slice_uniprot_ReferenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_ReferenceType(handle))
}

//export Slice_uniprot_ReferenceType_elem
func Slice_uniprot_ReferenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_ReferenceType(&(s[_idx]))
}

//export Slice_uniprot_ReferenceType_subslice
func Slice_uniprot_ReferenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_ReferenceType(&ss))
}

//export Slice_uniprot_ReferenceType_set
func Slice_uniprot_ReferenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_ReferenceType(_vl)
}

//export Slice_uniprot_ReferenceType_append
func Slice_uniprot_ReferenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_ReferenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_ReferenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.StatusType
func ptrFromHandle_Slice_uniprot_StatusType(h CGoHandle) *[]uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.StatusType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.StatusType)
}
func deptrFromHandle_Slice_uniprot_StatusType(h CGoHandle) []uniprot.StatusType {
	p := ptrFromHandle_Slice_uniprot_StatusType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.StatusType", p))
}

// --- wrapping slice: []uniprot.StatusType ---
//
//export Slice_uniprot_StatusType_CTor
func Slice_uniprot_StatusType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_StatusType(&[]uniprot.StatusType{}))
}

//export Slice_uniprot_StatusType_len
func Slice_uniprot_StatusType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_StatusType(handle))
}

//export Slice_uniprot_StatusType_elem
func Slice_uniprot_StatusType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	return handleFromPtr_uniprot_StatusType(&(s[_idx]))
}

//export Slice_uniprot_StatusType_subslice
func Slice_uniprot_StatusType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_StatusType(&ss))
}

//export Slice_uniprot_StatusType_set
func Slice_uniprot_StatusType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	s[_idx] = *ptrFromHandle_uniprot_StatusType(_vl)
}

//export Slice_uniprot_StatusType_append
func Slice_uniprot_StatusType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_StatusType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_StatusType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.SubcellularLocationType
func ptrFromHandle_Slice_uniprot_SubcellularLocationType(h CGoHandle) *[]uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.SubcellularLocationType)
}
func deptrFromHandle_Slice_uniprot_SubcellularLocationType(h CGoHandle) []uniprot.SubcellularLocationType {
	p := ptrFromHandle_Slice_uniprot_SubcellularLocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.SubcellularLocationType", p))
}

// --- wrapping slice: []uniprot.SubcellularLocationType ---
//
//export Slice_uniprot_SubcellularLocationType_CTor
func Slice_uniprot_SubcellularLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_SubcellularLocationType(&[]uniprot.SubcellularLocationType{}))
}

//export Slice_uniprot_SubcellularLocationType_len
func Slice_uniprot_SubcellularLocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle))
}

//export Slice_uniprot_SubcellularLocationType_elem
func Slice_uniprot_SubcellularLocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_uniprot_SubcellularLocationType(&(s[_idx]))
}

//export Slice_uniprot_SubcellularLocationType_subslice
func Slice_uniprot_SubcellularLocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_SubcellularLocationType(&ss))
}

//export Slice_uniprot_SubcellularLocationType_set
func Slice_uniprot_SubcellularLocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_SubcellularLocationType(_vl)
}

//export Slice_uniprot_SubcellularLocationType_append
func Slice_uniprot_SubcellularLocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_SubcellularLocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.SubmittedName
func ptrFromHandle_Slice_uniprot_SubmittedName(h CGoHandle) *[]uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.SubmittedName)
}
func deptrFromHandle_Slice_uniprot_SubmittedName(h CGoHandle) []uniprot.SubmittedName {
	p := ptrFromHandle_Slice_uniprot_SubmittedName(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.SubmittedName", p))
}

// --- wrapping slice: []uniprot.SubmittedName ---
//
//export Slice_uniprot_SubmittedName_CTor
func Slice_uniprot_SubmittedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_SubmittedName(&[]uniprot.SubmittedName{}))
}

//export Slice_uniprot_SubmittedName_len
func Slice_uniprot_SubmittedName_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_SubmittedName(handle))
}

//export Slice_uniprot_SubmittedName_elem
func Slice_uniprot_SubmittedName_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	return handleFromPtr_uniprot_SubmittedName(&(s[_idx]))
}

//export Slice_uniprot_SubmittedName_subslice
func Slice_uniprot_SubmittedName_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_SubmittedName(&ss))
}

//export Slice_uniprot_SubmittedName_set
func Slice_uniprot_SubmittedName_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	s[_idx] = *ptrFromHandle_uniprot_SubmittedName(_vl)
}

//export Slice_uniprot_SubmittedName_append
func Slice_uniprot_SubmittedName_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_SubmittedName(handle)
	*s = append(*s, *ptrFromHandle_uniprot_SubmittedName(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: uniprot.Absorption
func ptrFromHandle_uniprot_Absorption(h CGoHandle) *uniprot.Absorption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Absorption")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Absorption{})).(*uniprot.Absorption)
}
func handleFromPtr_uniprot_Absorption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Absorption", p))
}

// Converters for non-pointer handles for type: uniprot.AlternativeName
func ptrFromHandle_uniprot_AlternativeName(h CGoHandle) *uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.AlternativeName{})).(*uniprot.AlternativeName)
}
func handleFromPtr_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.AlternativeName", p))
}

// Converters for non-pointer handles for type: uniprot.Anon6
func ptrFromHandle_uniprot_Anon6(h CGoHandle) *uniprot.Anon6 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Anon6")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Anon6{})).(*uniprot.Anon6)
}
func handleFromPtr_uniprot_Anon6(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Anon6", p))
}

// Converters for non-pointer handles for type: uniprot.CitationType
func ptrFromHandle_uniprot_CitationType(h CGoHandle) *uniprot.CitationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CitationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CitationType{})).(*uniprot.CitationType)
}
func handleFromPtr_uniprot_CitationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CitationType", p))
}

// Converters for non-pointer handles for type: uniprot.CofactorType
func ptrFromHandle_uniprot_CofactorType(h CGoHandle) *uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CofactorType{})).(*uniprot.CofactorType)
}
func handleFromPtr_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CofactorType", p))
}

// Converters for non-pointer handles for type: uniprot.CommentType
func ptrFromHandle_uniprot_CommentType(h CGoHandle) *uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CommentType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType)
}
func handleFromPtr_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CommentType", p))
}

// Converters for non-pointer handles for type: uniprot.Component
func ptrFromHandle_uniprot_Component(h CGoHandle) *uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Component")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Component{})).(*uniprot.Component)
}
func handleFromPtr_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Component", p))
}

// Converters for non-pointer handles for type: uniprot.Conflict
func ptrFromHandle_uniprot_Conflict(h CGoHandle) *uniprot.Conflict {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Conflict")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Conflict{})).(*uniprot.Conflict)
}
func handleFromPtr_uniprot_Conflict(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Conflict", p))
}

// Converters for non-pointer handles for type: uniprot.ConsortiumType
func ptrFromHandle_uniprot_ConsortiumType(h CGoHandle) *uniprot.ConsortiumType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ConsortiumType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ConsortiumType{})).(*uniprot.ConsortiumType)
}
func handleFromPtr_uniprot_ConsortiumType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ConsortiumType", p))
}

// Converters for non-pointer handles for type: uniprot.DbReferenceType
func ptrFromHandle_uniprot_DbReferenceType(h CGoHandle) *uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.DbReferenceType{})).(*uniprot.DbReferenceType)
}
func handleFromPtr_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.DbReferenceType", p))
}

// Converters for pointer handles for type: uniprot.Decoder
func ptrFromHandle_uniprot_Decoder(h CGoHandle) uniprot.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Decoder")
	if p == nil {
		return nil
	}
	return p.(uniprot.Decoder)
}
func handleFromPtr_uniprot_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Decoder", p))
}

// Converters for non-pointer handles for type: uniprot.Disease
func ptrFromHandle_uniprot_Disease(h CGoHandle) *uniprot.Disease {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Disease")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Disease{})).(*uniprot.Disease)
}
func handleFromPtr_uniprot_Disease(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Disease", p))
}

// Converters for non-pointer handles for type: uniprot.Domain
func ptrFromHandle_uniprot_Domain(h CGoHandle) *uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Domain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Domain{})).(*uniprot.Domain)
}
func handleFromPtr_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Domain", p))
}

// Converters for non-pointer handles for type: uniprot.Entry
func ptrFromHandle_uniprot_Entry(h CGoHandle) *uniprot.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry)
}
func handleFromPtr_uniprot_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Entry", p))
}

// Converters for non-pointer handles for type: uniprot.EventType
func ptrFromHandle_uniprot_EventType(h CGoHandle) *uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EventType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EventType{})).(*uniprot.EventType)
}
func handleFromPtr_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EventType", p))
}

// Converters for non-pointer handles for type: uniprot.EvidenceType
func ptrFromHandle_uniprot_EvidenceType(h CGoHandle) *uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidenceType{})).(*uniprot.EvidenceType)
}
func handleFromPtr_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EvidenceType", p))
}

// Converters for non-pointer handles for type: uniprot.EvidencedStringType
func ptrFromHandle_uniprot_EvidencedStringType(h CGoHandle) *uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidencedStringType{})).(*uniprot.EvidencedStringType)
}
func handleFromPtr_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EvidencedStringType", p))
}

// Converters for non-pointer handles for type: uniprot.FeatureType
func ptrFromHandle_uniprot_FeatureType(h CGoHandle) *uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.FeatureType{})).(*uniprot.FeatureType)
}
func handleFromPtr_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.FeatureType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneLocationType
func ptrFromHandle_uniprot_GeneLocationType(h CGoHandle) *uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneLocationType{})).(*uniprot.GeneLocationType)
}
func handleFromPtr_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneLocationType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneNameType
func ptrFromHandle_uniprot_GeneNameType(h CGoHandle) *uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneNameType{})).(*uniprot.GeneNameType)
}
func handleFromPtr_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneNameType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneType
func ptrFromHandle_uniprot_GeneType(h CGoHandle) *uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneType{})).(*uniprot.GeneType)
}
func handleFromPtr_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneType", p))
}

// Converters for non-pointer handles for type: uniprot.ImportedFromType
func ptrFromHandle_uniprot_ImportedFromType(h CGoHandle) *uniprot.ImportedFromType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ImportedFromType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ImportedFromType{})).(*uniprot.ImportedFromType)
}
func handleFromPtr_uniprot_ImportedFromType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ImportedFromType", p))
}

// Converters for implicit pointer handles for type: uniprot.IntListType
func ptrFromHandle_uniprot_IntListType(h CGoHandle) *uniprot.IntListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.IntListType")
	if p == nil {
		return nil
	}
	return p.(*uniprot.IntListType)
}
func deptrFromHandle_uniprot_IntListType(h CGoHandle) uniprot.IntListType {
	p := ptrFromHandle_uniprot_IntListType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_uniprot_IntListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.IntListType", p))
}

// Converters for non-pointer handles for type: uniprot.InteractantType
func ptrFromHandle_uniprot_InteractantType(h CGoHandle) *uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.InteractantType{})).(*uniprot.InteractantType)
}
func handleFromPtr_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.InteractantType", p))
}

// Converters for non-pointer handles for type: uniprot.IsoformType
func ptrFromHandle_uniprot_IsoformType(h CGoHandle) *uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.IsoformType{})).(*uniprot.IsoformType)
}
func handleFromPtr_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.IsoformType", p))
}

// Converters for non-pointer handles for type: uniprot.KeywordType
func ptrFromHandle_uniprot_KeywordType(h CGoHandle) *uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.KeywordType{})).(*uniprot.KeywordType)
}
func handleFromPtr_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.KeywordType", p))
}

// Converters for non-pointer handles for type: uniprot.Kinetics
func ptrFromHandle_uniprot_Kinetics(h CGoHandle) *uniprot.Kinetics {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Kinetics")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Kinetics{})).(*uniprot.Kinetics)
}
func handleFromPtr_uniprot_Kinetics(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Kinetics", p))
}

// Converters for non-pointer handles for type: uniprot.Lineage
func ptrFromHandle_uniprot_Lineage(h CGoHandle) *uniprot.Lineage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Lineage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Lineage{})).(*uniprot.Lineage)
}
func handleFromPtr_uniprot_Lineage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Lineage", p))
}

// Converters for non-pointer handles for type: uniprot.Link
func ptrFromHandle_uniprot_Link(h CGoHandle) *uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Link")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Link{})).(*uniprot.Link)
}
func handleFromPtr_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Link", p))
}

// Converters for non-pointer handles for type: uniprot.LocationType
func ptrFromHandle_uniprot_LocationType(h CGoHandle) *uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.LocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.LocationType{})).(*uniprot.LocationType)
}
func handleFromPtr_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.LocationType", p))
}

// Converters for non-pointer handles for type: uniprot.Name
func ptrFromHandle_uniprot_Name(h CGoHandle) *uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Name{})).(*uniprot.Name)
}
func handleFromPtr_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Name", p))
}

// Converters for non-pointer handles for type: uniprot.NameListType
func ptrFromHandle_uniprot_NameListType(h CGoHandle) *uniprot.NameListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.NameListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.NameListType{})).(*uniprot.NameListType)
}
func handleFromPtr_uniprot_NameListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.NameListType", p))
}

// Converters for non-pointer handles for type: uniprot.OrganismNameType
func ptrFromHandle_uniprot_OrganismNameType(h CGoHandle) *uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismNameType{})).(*uniprot.OrganismNameType)
}
func handleFromPtr_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.OrganismNameType", p))
}

// Converters for non-pointer handles for type: uniprot.OrganismType
func ptrFromHandle_uniprot_OrganismType(h CGoHandle) *uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismType{})).(*uniprot.OrganismType)
}
func handleFromPtr_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.OrganismType", p))
}

// Converters for non-pointer handles for type: uniprot.PersonType
func ptrFromHandle_uniprot_PersonType(h CGoHandle) *uniprot.PersonType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PersonType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PersonType{})).(*uniprot.PersonType)
}
func handleFromPtr_uniprot_PersonType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PersonType", p))
}

// Converters for non-pointer handles for type: uniprot.PhDependence
func ptrFromHandle_uniprot_PhDependence(h CGoHandle) *uniprot.PhDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PhDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhDependence{})).(*uniprot.PhDependence)
}
func handleFromPtr_uniprot_PhDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PhDependence", p))
}

// Converters for non-pointer handles for type: uniprot.PhysiologicalReactionType
func ptrFromHandle_uniprot_PhysiologicalReactionType(h CGoHandle) *uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhysiologicalReactionType{})).(*uniprot.PhysiologicalReactionType)
}
func handleFromPtr_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PhysiologicalReactionType", p))
}

// Converters for non-pointer handles for type: uniprot.Plasmid
func ptrFromHandle_uniprot_Plasmid(h CGoHandle) *uniprot.Plasmid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Plasmid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Plasmid{})).(*uniprot.Plasmid)
}
func handleFromPtr_uniprot_Plasmid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Plasmid", p))
}

// Converters for non-pointer handles for type: uniprot.PositionType
func ptrFromHandle_uniprot_PositionType(h CGoHandle) *uniprot.PositionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PositionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType)
}
func handleFromPtr_uniprot_PositionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PositionType", p))
}

// Converters for non-pointer handles for type: uniprot.PropertyType
func ptrFromHandle_uniprot_PropertyType(h CGoHandle) *uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PropertyType{})).(*uniprot.PropertyType)
}
func handleFromPtr_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PropertyType", p))
}

// Converters for non-pointer handles for type: uniprot.ProteinExistenceType
func ptrFromHandle_uniprot_ProteinExistenceType(h CGoHandle) *uniprot.ProteinExistenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ProteinExistenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinExistenceType{})).(*uniprot.ProteinExistenceType)
}
func handleFromPtr_uniprot_ProteinExistenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ProteinExistenceType", p))
}

// Converters for non-pointer handles for type: uniprot.ProteinType
func ptrFromHandle_uniprot_ProteinType(h CGoHandle) *uniprot.ProteinType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ProteinType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinType{})).(*uniprot.ProteinType)
}
func handleFromPtr_uniprot_ProteinType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ProteinType", p))
}

// Converters for non-pointer handles for type: uniprot.ReactionType
func ptrFromHandle_uniprot_ReactionType(h CGoHandle) *uniprot.ReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReactionType{})).(*uniprot.ReactionType)
}
func handleFromPtr_uniprot_ReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ReactionType", p))
}

// Converters for non-pointer handles for type: uniprot.RecommendedName
func ptrFromHandle_uniprot_RecommendedName(h CGoHandle) *uniprot.RecommendedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.RecommendedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RecommendedName{})).(*uniprot.RecommendedName)
}
func handleFromPtr_uniprot_RecommendedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.RecommendedName", p))
}

// Converters for non-pointer handles for type: uniprot.RedoxPotential
func ptrFromHandle_uniprot_RedoxPotential(h CGoHandle) *uniprot.RedoxPotential {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.RedoxPotential")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RedoxPotential{})).(*uniprot.RedoxPotential)
}
func handleFromPtr_uniprot_RedoxPotential(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.RedoxPotential", p))
}

// Converters for non-pointer handles for type: uniprot.ReferenceType
func ptrFromHandle_uniprot_ReferenceType(h CGoHandle) *uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReferenceType{})).(*uniprot.ReferenceType)
}
func handleFromPtr_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ReferenceType", p))
}

// Converters for non-pointer handles for type: uniprot.Sequence
func ptrFromHandle_uniprot_Sequence(h CGoHandle) *uniprot.Sequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Sequence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Sequence{})).(*uniprot.Sequence)
}
func handleFromPtr_uniprot_Sequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Sequence", p))
}

// Converters for non-pointer handles for type: uniprot.SequenceType
func ptrFromHandle_uniprot_SequenceType(h CGoHandle) *uniprot.SequenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SequenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType)
}
func handleFromPtr_uniprot_SequenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SequenceType", p))
}

// Converters for non-pointer handles for type: uniprot.SourceDataType
func ptrFromHandle_uniprot_SourceDataType(h CGoHandle) *uniprot.SourceDataType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SourceDataType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceDataType{})).(*uniprot.SourceDataType)
}
func handleFromPtr_uniprot_SourceDataType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SourceDataType", p))
}

// Converters for non-pointer handles for type: uniprot.SourceType
func ptrFromHandle_uniprot_SourceType(h CGoHandle) *uniprot.SourceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SourceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceType{})).(*uniprot.SourceType)
}
func handleFromPtr_uniprot_SourceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SourceType", p))
}

// Converters for non-pointer handles for type: uniprot.StatusType
func ptrFromHandle_uniprot_StatusType(h CGoHandle) *uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.StatusType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.StatusType{})).(*uniprot.StatusType)
}
func handleFromPtr_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.StatusType", p))
}

// Converters for non-pointer handles for type: uniprot.Strain
func ptrFromHandle_uniprot_Strain(h CGoHandle) *uniprot.Strain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Strain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Strain{})).(*uniprot.Strain)
}
func handleFromPtr_uniprot_Strain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Strain", p))
}

// Converters for non-pointer handles for type: uniprot.SubcellularLocationType
func ptrFromHandle_uniprot_SubcellularLocationType(h CGoHandle) *uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubcellularLocationType{})).(*uniprot.SubcellularLocationType)
}
func handleFromPtr_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SubcellularLocationType", p))
}

// Converters for non-pointer handles for type: uniprot.SubmittedName
func ptrFromHandle_uniprot_SubmittedName(h CGoHandle) *uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubmittedName{})).(*uniprot.SubmittedName)
}
func handleFromPtr_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SubmittedName", p))
}

// Converters for non-pointer handles for type: uniprot.TemperatureDependence
func ptrFromHandle_uniprot_TemperatureDependence(h CGoHandle) *uniprot.TemperatureDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.TemperatureDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.TemperatureDependence{})).(*uniprot.TemperatureDependence)
}
func handleFromPtr_uniprot_TemperatureDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.TemperatureDependence", p))
}

// Converters for non-pointer handles for type: uniprot.Tissue
func ptrFromHandle_uniprot_Tissue(h CGoHandle) *uniprot.Tissue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Tissue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Tissue{})).(*uniprot.Tissue)
}
func handleFromPtr_uniprot_Tissue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Tissue", p))
}

// Converters for non-pointer handles for type: uniprot.Transposon
func ptrFromHandle_uniprot_Transposon(h CGoHandle) *uniprot.Transposon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Transposon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Transposon{})).(*uniprot.Transposon)
}
func handleFromPtr_uniprot_Transposon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Transposon", p))
}

// Converters for non-pointer handles for type: uniprot.Uniprot
func ptrFromHandle_uniprot_Uniprot(h CGoHandle) *uniprot.Uniprot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Uniprot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Uniprot{})).(*uniprot.Uniprot)
}
func handleFromPtr_uniprot_Uniprot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Uniprot", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export uniprot_Decoder_DecodeElement
func uniprot_Decoder_DecodeElement(_handle CGoHandle, v *C.char, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "uniprot.Decoder")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(uniprot.Decoder).DecodeElement(C.GoString(v), ptrFromHandle_Ptr_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export uniprot_Decoder_Token
func uniprot_Decoder_Token(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "uniprot.Decoder")
	if __err != nil {
		return handleFromPtr_xml_Token(nil)
	}
	cret, __err := vifc.(uniprot.Decoder).Token()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_xml_Token(nil)
	}
	return handleFromPtr_xml_Token(cret)
}

// ---- Structs ---

// --- wrapping struct: uniprot.NameListType ---
//
//export uniprot_NameListType_CTor
func uniprot_NameListType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_NameListType(&uniprot.NameListType{}))
}

//export uniprot_NameListType_Consortium_Get
func uniprot_NameListType_Consortium_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_NameListType(handle)
	return handleFromPtr_uniprot_ConsortiumType(&op.Consortium)
}

//export uniprot_NameListType_Consortium_Set
func uniprot_NameListType_Consortium_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_NameListType(handle)
	op.Consortium = *ptrFromHandle_uniprot_ConsortiumType(val)
}

//export uniprot_NameListType_Person_Get
func uniprot_NameListType_Person_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_NameListType(handle)
	return handleFromPtr_uniprot_PersonType(&op.Person)
}

//export uniprot_NameListType_Person_Set
func uniprot_NameListType_Person_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_NameListType(handle)
	op.Person = *ptrFromHandle_uniprot_PersonType(val)
}

// --- wrapping struct: uniprot.ReactionType ---
//
//export uniprot_ReactionType_CTor
func uniprot_ReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ReactionType(&uniprot.ReactionType{}))
}

//export uniprot_ReactionType_Text_Get
func uniprot_ReactionType_Text_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return C.CString(op.Text)
}

//export uniprot_ReactionType_Text_Set
func uniprot_ReactionType_Text_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.Text = C.GoString(val)
}

//export uniprot_ReactionType_DbReference_Get
func uniprot_ReactionType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_ReactionType_DbReference_Set
func uniprot_ReactionType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_ReactionType_Evidence_Get
func uniprot_ReactionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_ReactionType_Evidence_Set
func uniprot_ReactionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Tissue ---
//
//export uniprot_Tissue_CTor
func uniprot_Tissue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Tissue(&uniprot.Tissue{}))
}

//export uniprot_Tissue_Value_Get
func uniprot_Tissue_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Tissue(handle)
	return C.CString(op.Value)
}

//export uniprot_Tissue_Value_Set
func uniprot_Tissue_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Tissue(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Tissue_Evidence_Get
func uniprot_Tissue_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Tissue(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Tissue_Evidence_Set
func uniprot_Tissue_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Tissue(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.LocationType ---
//
//export uniprot_LocationType_CTor
func uniprot_LocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_LocationType(&uniprot.LocationType{}))
}

//export uniprot_LocationType_Begin_Get
func uniprot_LocationType_Begin_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.Begin)
}

//export uniprot_LocationType_Begin_Set
func uniprot_LocationType_Begin_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Begin = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_End_Get
func uniprot_LocationType_End_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.End)
}

//export uniprot_LocationType_End_Set
func uniprot_LocationType_End_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.End = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_Position_Get
func uniprot_LocationType_Position_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.Position)
}

//export uniprot_LocationType_Position_Set
func uniprot_LocationType_Position_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Position = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_Sequence_Get
func uniprot_LocationType_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return C.CString(op.Sequence)
}

//export uniprot_LocationType_Sequence_Set
func uniprot_LocationType_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Sequence = C.GoString(val)
}

// --- wrapping struct: uniprot.RecommendedName ---
//
//export uniprot_RecommendedName_CTor
func uniprot_RecommendedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_RecommendedName(&uniprot.RecommendedName{}))
}

//export uniprot_RecommendedName_FullName_Get
func uniprot_RecommendedName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_RecommendedName_FullName_Set
func uniprot_RecommendedName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_RecommendedName_ShortName_Get
func uniprot_RecommendedName_ShortName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.ShortName)
}

//export uniprot_RecommendedName_ShortName_Set
func uniprot_RecommendedName_ShortName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.ShortName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_RecommendedName_EcNumber_Get
func uniprot_RecommendedName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_RecommendedName_EcNumber_Set
func uniprot_RecommendedName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.SubcellularLocationType ---
//
//export uniprot_SubcellularLocationType_CTor
func uniprot_SubcellularLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SubcellularLocationType(&uniprot.SubcellularLocationType{}))
}

//export uniprot_SubcellularLocationType_Location_Get
func uniprot_SubcellularLocationType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Location)
}

//export uniprot_SubcellularLocationType_Location_Set
func uniprot_SubcellularLocationType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Location = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_SubcellularLocationType_Topology_Get
func uniprot_SubcellularLocationType_Topology_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Topology)
}

//export uniprot_SubcellularLocationType_Topology_Set
func uniprot_SubcellularLocationType_Topology_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Topology = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_SubcellularLocationType_Orientation_Get
func uniprot_SubcellularLocationType_Orientation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Orientation)
}

//export uniprot_SubcellularLocationType_Orientation_Set
func uniprot_SubcellularLocationType_Orientation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Orientation = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.OrganismNameType ---
//
//export uniprot_OrganismNameType_CTor
func uniprot_OrganismNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_OrganismNameType(&uniprot.OrganismNameType{}))
}

//export uniprot_OrganismNameType_Value_Get
func uniprot_OrganismNameType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	return C.CString(op.Value)
}

//export uniprot_OrganismNameType_Value_Set
func uniprot_OrganismNameType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_OrganismNameType_Type_Get
func uniprot_OrganismNameType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_OrganismNameType_Type_Set
func uniprot_OrganismNameType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.Sequence ---
//
//export uniprot_Sequence_CTor
func uniprot_Sequence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Sequence(&uniprot.Sequence{}))
}

//export uniprot_Sequence_Resource_Get
func uniprot_Sequence_Resource_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Sequence(handle)
	return C.CString(string(op.Resource))
}

//export uniprot_Sequence_Resource_Set
func uniprot_Sequence_Resource_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Sequence(handle)
	op.Resource = uniprot.Resource(C.GoString(val))
}

//export uniprot_Sequence_Version_Get
func uniprot_Sequence_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_Sequence(handle)
	return C.longlong(op.Version)
}

//export uniprot_Sequence_Version_Set
func uniprot_Sequence_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_Sequence(handle)
	op.Version = int(val)
}

// --- wrapping struct: uniprot.SequenceType ---
//
//export uniprot_SequenceType_CTor
func uniprot_SequenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SequenceType(&uniprot.SequenceType{}))
}

//export uniprot_SequenceType_Value_Get
func uniprot_SequenceType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(op.Value)
}

//export uniprot_SequenceType_Value_Set
func uniprot_SequenceType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_SequenceType_Length_Get
func uniprot_SequenceType_Length_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Length)
}

//export uniprot_SequenceType_Length_Set
func uniprot_SequenceType_Length_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Length = int(val)
}

//export uniprot_SequenceType_Mass_Get
func uniprot_SequenceType_Mass_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Mass)
}

//export uniprot_SequenceType_Mass_Set
func uniprot_SequenceType_Mass_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Mass = int(val)
}

//export uniprot_SequenceType_Checksum_Get
func uniprot_SequenceType_Checksum_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(op.Checksum)
}

//export uniprot_SequenceType_Checksum_Set
func uniprot_SequenceType_Checksum_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Checksum = C.GoString(val)
}

//export uniprot_SequenceType_Modified_Get
func uniprot_SequenceType_Modified_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return handleFromPtr_time_Time(&op.Modified)
}

//export uniprot_SequenceType_Modified_Set
func uniprot_SequenceType_Modified_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Modified = *ptrFromHandle_time_Time(val)
}

//export uniprot_SequenceType_Version_Get
func uniprot_SequenceType_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Version)
}

//export uniprot_SequenceType_Version_Set
func uniprot_SequenceType_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Version = int(val)
}

//export uniprot_SequenceType_Precursor_Get
func uniprot_SequenceType_Precursor_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return boolGoToPy(op.Precursor)
}

//export uniprot_SequenceType_Precursor_Set
func uniprot_SequenceType_Precursor_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Precursor = boolPyToGo(val)
}

//export uniprot_SequenceType_Fragment_Get
func uniprot_SequenceType_Fragment_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(string(op.Fragment))
}

//export uniprot_SequenceType_Fragment_Set
func uniprot_SequenceType_Fragment_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Fragment = uniprot.Fragment(C.GoString(val))
}

//export uniprot_SequenceType_UnmarshalXML
func uniprot_SequenceType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.SequenceType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.Uniprot ---
//
//export uniprot_Uniprot_CTor
func uniprot_Uniprot_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Uniprot(&uniprot.Uniprot{}))
}

//export uniprot_Uniprot_Entry_Get
func uniprot_Uniprot_Entry_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	return handleFromPtr_Slice_string(&op.Entry)
}

//export uniprot_Uniprot_Entry_Set
func uniprot_Uniprot_Entry_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	op.Entry = deptrFromHandle_Slice_string(val)
}

//export uniprot_Uniprot_Copyright_Get
func uniprot_Uniprot_Copyright_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	return C.CString(op.Copyright)
}

//export uniprot_Uniprot_Copyright_Set
func uniprot_Uniprot_Copyright_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	op.Copyright = C.GoString(val)
}

// --- wrapping struct: uniprot.Disease ---
//
//export uniprot_Disease_CTor
func uniprot_Disease_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Disease(&uniprot.Disease{}))
}

//export uniprot_Disease_Name_Get
func uniprot_Disease_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Name)
}

//export uniprot_Disease_Name_Set
func uniprot_Disease_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Name = C.GoString(val)
}

//export uniprot_Disease_Acronym_Get
func uniprot_Disease_Acronym_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Acronym)
}

//export uniprot_Disease_Acronym_Set
func uniprot_Disease_Acronym_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Acronym = C.GoString(val)
}

//export uniprot_Disease_Description_Get
func uniprot_Disease_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Description)
}

//export uniprot_Disease_Description_Set
func uniprot_Disease_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Description = C.GoString(val)
}

//export uniprot_Disease_DbReference_Get
func uniprot_Disease_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Disease(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_Disease_DbReference_Set
func uniprot_Disease_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.PhDependence ---
//
//export uniprot_PhDependence_CTor
func uniprot_PhDependence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PhDependence(&uniprot.PhDependence{}))
}

//export uniprot_PhDependence_Text_Get
func uniprot_PhDependence_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhDependence(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_PhDependence_Text_Set
func uniprot_PhDependence_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhDependence(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.PropertyType ---
//
//export uniprot_PropertyType_CTor
func uniprot_PropertyType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PropertyType(&uniprot.PropertyType{}))
}

//export uniprot_PropertyType_Type_Get
func uniprot_PropertyType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	return C.CString(op.Type)
}

//export uniprot_PropertyType_Type_Set
func uniprot_PropertyType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_PropertyType_Value_Get
func uniprot_PropertyType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	return C.CString(op.Value)
}

//export uniprot_PropertyType_Value_Set
func uniprot_PropertyType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	op.Value = C.GoString(val)
}

// --- wrapping struct: uniprot.Anon6 ---
//
//export uniprot_Anon6_CTor
func uniprot_Anon6_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Anon6(&uniprot.Anon6{}))
}

//export uniprot_Anon6_Type_Get
func uniprot_Anon6_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Anon6(handle)
	return C.CString(string(op.Type))
}

//export uniprot_Anon6_Type_Set
func uniprot_Anon6_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Anon6(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.FeatureType ---
//
//export uniprot_FeatureType_CTor
func uniprot_FeatureType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_FeatureType(&uniprot.FeatureType{}))
}

//export uniprot_FeatureType_Original_Get
func uniprot_FeatureType_Original_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(op.Original)
}

//export uniprot_FeatureType_Original_Set
func uniprot_FeatureType_Original_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Original = C.GoString(val)
}

//export uniprot_FeatureType_Variation_Get
func uniprot_FeatureType_Variation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_Slice_string(&op.Variation)
}

//export uniprot_FeatureType_Variation_Set
func uniprot_FeatureType_Variation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Variation = deptrFromHandle_Slice_string(val)
}

//export uniprot_FeatureType_Location_Get
func uniprot_FeatureType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_LocationType(&op.Location)
}

//export uniprot_FeatureType_Location_Set
func uniprot_FeatureType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Location = *ptrFromHandle_uniprot_LocationType(val)
}

//export uniprot_FeatureType_Type_Get
func uniprot_FeatureType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_FeatureType_Type_Set
func uniprot_FeatureType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_FeatureType_Description_Get
func uniprot_FeatureType_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(op.Description)
}

//export uniprot_FeatureType_Description_Set
func uniprot_FeatureType_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Description = C.GoString(val)
}

//export uniprot_FeatureType_Evidence_Get
func uniprot_FeatureType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_FeatureType_Evidence_Set
func uniprot_FeatureType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.GeneType ---
//
//export uniprot_GeneType_CTor
func uniprot_GeneType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneType(&uniprot.GeneType{}))
}

//export uniprot_GeneType_Name_Get
func uniprot_GeneType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneType(handle)
	return handleFromPtr_Slice_uniprot_GeneNameType(&op.Name)
}

//export uniprot_GeneType_Name_Set
func uniprot_GeneType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_GeneNameType(val)
}

// --- wrapping struct: uniprot.Link ---
//
//export uniprot_Link_CTor
func uniprot_Link_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Link(&uniprot.Link{}))
}

//export uniprot_Link_Uri_Get
func uniprot_Link_Uri_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Link(handle)
	return C.CString(op.Uri)
}

//export uniprot_Link_Uri_Set
func uniprot_Link_Uri_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Link(handle)
	op.Uri = C.GoString(val)
}

// --- wrapping struct: uniprot.OrganismType ---
//
//export uniprot_OrganismType_CTor
func uniprot_OrganismType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_OrganismType(&uniprot.OrganismType{}))
}

//export uniprot_OrganismType_Name_Get
func uniprot_OrganismType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_Slice_uniprot_OrganismNameType(&op.Name)
}

//export uniprot_OrganismType_Name_Set
func uniprot_OrganismType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_OrganismNameType(val)
}

//export uniprot_OrganismType_DbReference_Get
func uniprot_OrganismType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_OrganismType_DbReference_Set
func uniprot_OrganismType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_OrganismType_Lineage_Get
func uniprot_OrganismType_Lineage_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_Lineage(&op.Lineage)
}

//export uniprot_OrganismType_Lineage_Set
func uniprot_OrganismType_Lineage_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Lineage = *ptrFromHandle_uniprot_Lineage(val)
}

//export uniprot_OrganismType_Evidence_Get
func uniprot_OrganismType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_OrganismType_Evidence_Set
func uniprot_OrganismType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.DbReferenceType ---
//
//export uniprot_DbReferenceType_CTor
func uniprot_DbReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_DbReferenceType(&uniprot.DbReferenceType{}))
}

//export uniprot_DbReferenceType_Molecule_Get
func uniprot_DbReferenceType_Molecule_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return C.CString(op.Molecule)
}

//export uniprot_DbReferenceType_Molecule_Set
func uniprot_DbReferenceType_Molecule_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Molecule = C.GoString(val)
}

//export uniprot_DbReferenceType_Property_Get
func uniprot_DbReferenceType_Property_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return handleFromPtr_Slice_uniprot_PropertyType(&op.Property)
}

//export uniprot_DbReferenceType_Property_Set
func uniprot_DbReferenceType_Property_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Property = deptrFromHandle_Slice_uniprot_PropertyType(val)
}

//export uniprot_DbReferenceType_Type_Get
func uniprot_DbReferenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return C.CString(op.Type)
}

//export uniprot_DbReferenceType_Type_Set
func uniprot_DbReferenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_DbReferenceType_Evidence_Get
func uniprot_DbReferenceType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_DbReferenceType_Evidence_Set
func uniprot_DbReferenceType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Strain ---
//
//export uniprot_Strain_CTor
func uniprot_Strain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Strain(&uniprot.Strain{}))
}

//export uniprot_Strain_Value_Get
func uniprot_Strain_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Strain(handle)
	return C.CString(op.Value)
}

//export uniprot_Strain_Value_Set
func uniprot_Strain_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Strain(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Strain_Evidence_Get
func uniprot_Strain_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Strain(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Strain_Evidence_Set
func uniprot_Strain_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Strain(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.SubmittedName ---
//
//export uniprot_SubmittedName_CTor
func uniprot_SubmittedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SubmittedName(&uniprot.SubmittedName{}))
}

//export uniprot_SubmittedName_FullName_Get
func uniprot_SubmittedName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_SubmittedName_FullName_Set
func uniprot_SubmittedName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_SubmittedName_EcNumber_Get
func uniprot_SubmittedName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_SubmittedName_EcNumber_Set
func uniprot_SubmittedName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Transposon ---
//
//export uniprot_Transposon_CTor
func uniprot_Transposon_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Transposon(&uniprot.Transposon{}))
}

//export uniprot_Transposon_Value_Get
func uniprot_Transposon_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Transposon(handle)
	return C.CString(op.Value)
}

//export uniprot_Transposon_Value_Set
func uniprot_Transposon_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Transposon(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Transposon_Evidence_Get
func uniprot_Transposon_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Transposon(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Transposon_Evidence_Set
func uniprot_Transposon_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Transposon(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.CommentType ---
//
//export uniprot_CommentType_CTor
func uniprot_CommentType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CommentType(&uniprot.CommentType{}))
}

//export uniprot_CommentType_Molecule_Get
func uniprot_CommentType_Molecule_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Molecule)
}

//export uniprot_CommentType_Molecule_Set
func uniprot_CommentType_Molecule_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Molecule = C.GoString(val)
}

//export uniprot_CommentType_Absorption_Get
func uniprot_CommentType_Absorption_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Absorption(&op.Absorption)
}

//export uniprot_CommentType_Absorption_Set
func uniprot_CommentType_Absorption_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Absorption = *ptrFromHandle_uniprot_Absorption(val)
}

//export uniprot_CommentType_Kinetics_Get
func uniprot_CommentType_Kinetics_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Kinetics(&op.Kinetics)
}

//export uniprot_CommentType_Kinetics_Set
func uniprot_CommentType_Kinetics_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Kinetics = *ptrFromHandle_uniprot_Kinetics(val)
}

//export uniprot_CommentType_PhDependence_Get
func uniprot_CommentType_PhDependence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_PhDependence(&op.PhDependence)
}

//export uniprot_CommentType_PhDependence_Set
func uniprot_CommentType_PhDependence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.PhDependence = *ptrFromHandle_uniprot_PhDependence(val)
}

//export uniprot_CommentType_RedoxPotential_Get
func uniprot_CommentType_RedoxPotential_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_RedoxPotential(&op.RedoxPotential)
}

//export uniprot_CommentType_RedoxPotential_Set
func uniprot_CommentType_RedoxPotential_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.RedoxPotential = *ptrFromHandle_uniprot_RedoxPotential(val)
}

//export uniprot_CommentType_TemperatureDependence_Get
func uniprot_CommentType_TemperatureDependence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_TemperatureDependence(&op.TemperatureDependence)
}

//export uniprot_CommentType_TemperatureDependence_Set
func uniprot_CommentType_TemperatureDependence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.TemperatureDependence = *ptrFromHandle_uniprot_TemperatureDependence(val)
}

//export uniprot_CommentType_Reaction_Get
func uniprot_CommentType_Reaction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_ReactionType(&op.Reaction)
}

//export uniprot_CommentType_Reaction_Set
func uniprot_CommentType_Reaction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Reaction = *ptrFromHandle_uniprot_ReactionType(val)
}

//export uniprot_CommentType_PhysiologicalReaction_Get
func uniprot_CommentType_PhysiologicalReaction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&op.PhysiologicalReaction)
}

//export uniprot_CommentType_PhysiologicalReaction_Set
func uniprot_CommentType_PhysiologicalReaction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.PhysiologicalReaction = deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(val)
}

//export uniprot_CommentType_Cofactor_Get
func uniprot_CommentType_Cofactor_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_CofactorType(&op.Cofactor)
}

//export uniprot_CommentType_Cofactor_Set
func uniprot_CommentType_Cofactor_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Cofactor = deptrFromHandle_Slice_uniprot_CofactorType(val)
}

//export uniprot_CommentType_SubcellularLocation_Get
func uniprot_CommentType_SubcellularLocation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_SubcellularLocationType(&op.SubcellularLocation)
}

//export uniprot_CommentType_SubcellularLocation_Set
func uniprot_CommentType_SubcellularLocation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.SubcellularLocation = deptrFromHandle_Slice_uniprot_SubcellularLocationType(val)
}

//export uniprot_CommentType_Conflict_Get
func uniprot_CommentType_Conflict_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Conflict(&op.Conflict)
}

//export uniprot_CommentType_Conflict_Set
func uniprot_CommentType_Conflict_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Conflict = *ptrFromHandle_uniprot_Conflict(val)
}

//export uniprot_CommentType_Link_Get
func uniprot_CommentType_Link_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_Link(&op.Link)
}

//export uniprot_CommentType_Link_Set
func uniprot_CommentType_Link_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Link = deptrFromHandle_Slice_uniprot_Link(val)
}

//export uniprot_CommentType_Event_Get
func uniprot_CommentType_Event_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_EventType(&op.Event)
}

//export uniprot_CommentType_Event_Set
func uniprot_CommentType_Event_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Event = deptrFromHandle_Slice_uniprot_EventType(val)
}

//export uniprot_CommentType_Isoform_Get
func uniprot_CommentType_Isoform_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_IsoformType(&op.Isoform)
}

//export uniprot_CommentType_Isoform_Set
func uniprot_CommentType_Isoform_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Isoform = deptrFromHandle_Slice_uniprot_IsoformType(val)
}

//export uniprot_CommentType_Interactant_Get
func uniprot_CommentType_Interactant_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_InteractantType(&op.Interactant)
}

//export uniprot_CommentType_Interactant_Set
func uniprot_CommentType_Interactant_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Interactant = deptrFromHandle_Slice_uniprot_InteractantType(val)
}

//export uniprot_CommentType_OrganismsDiffer_Get
func uniprot_CommentType_OrganismsDiffer_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return boolGoToPy(op.OrganismsDiffer)
}

//export uniprot_CommentType_OrganismsDiffer_Set
func uniprot_CommentType_OrganismsDiffer_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.OrganismsDiffer = boolPyToGo(val)
}

//export uniprot_CommentType_Experiments_Get
func uniprot_CommentType_Experiments_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.longlong(op.Experiments)
}

//export uniprot_CommentType_Experiments_Set
func uniprot_CommentType_Experiments_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Experiments = int(val)
}

//export uniprot_CommentType_Disease_Get
func uniprot_CommentType_Disease_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Disease(&op.Disease)
}

//export uniprot_CommentType_Disease_Set
func uniprot_CommentType_Disease_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Disease = *ptrFromHandle_uniprot_Disease(val)
}

//export uniprot_CommentType_Location_Get
func uniprot_CommentType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_LocationType(&op.Location)
}

//export uniprot_CommentType_Location_Set
func uniprot_CommentType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Location = deptrFromHandle_Slice_uniprot_LocationType(val)
}

//export uniprot_CommentType_Text_Get
func uniprot_CommentType_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_CommentType_Text_Set
func uniprot_CommentType_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_CommentType_Type_Get
func uniprot_CommentType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_CommentType_Type_Set
func uniprot_CommentType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_CommentType_LocationType_Get
func uniprot_CommentType_LocationType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.LocationType)
}

//export uniprot_CommentType_LocationType_Set
func uniprot_CommentType_LocationType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.LocationType = C.GoString(val)
}

//export uniprot_CommentType_Name_Get
func uniprot_CommentType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Name)
}

//export uniprot_CommentType_Name_Set
func uniprot_CommentType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CommentType_Mass_Get
func uniprot_CommentType_Mass_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.float(op.Mass)
}

//export uniprot_CommentType_Mass_Set
func uniprot_CommentType_Mass_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Mass = float32(val)
}

//export uniprot_CommentType_Error_Get
func uniprot_CommentType_Error_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Error)
}

//export uniprot_CommentType_Error_Set
func uniprot_CommentType_Error_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Error = C.GoString(val)
}

//export uniprot_CommentType_Method_Get
func uniprot_CommentType_Method_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Method)
}

//export uniprot_CommentType_Method_Set
func uniprot_CommentType_Method_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Method = C.GoString(val)
}

//export uniprot_CommentType_Evidence_Get
func uniprot_CommentType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_CommentType_Evidence_Set
func uniprot_CommentType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_CommentType_UnmarshalXML
func uniprot_CommentType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.CommentType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.PositionType ---
//
//export uniprot_PositionType_CTor
func uniprot_PositionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PositionType(&uniprot.PositionType{}))
}

//export uniprot_PositionType_Position_Get
func uniprot_PositionType_Position_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return C.ulonglong(op.Position)
}

//export uniprot_PositionType_Position_Set
func uniprot_PositionType_Position_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Position = uint64(val)
}

//export uniprot_PositionType_Status_Get
func uniprot_PositionType_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return C.CString(string(op.Status))
}

//export uniprot_PositionType_Status_Set
func uniprot_PositionType_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Status = uniprot.Status(C.GoString(val))
}

//export uniprot_PositionType_Evidence_Get
func uniprot_PositionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_PositionType_Evidence_Set
func uniprot_PositionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_PositionType_UnmarshalXML
func uniprot_PositionType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.PositionType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.StatusType ---
//
//export uniprot_StatusType_CTor
func uniprot_StatusType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_StatusType(&uniprot.StatusType{}))
}

//export uniprot_StatusType_Value_Get
func uniprot_StatusType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_StatusType(handle)
	return C.CString(op.Value)
}

//export uniprot_StatusType_Value_Set
func uniprot_StatusType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_StatusType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_StatusType_Status_Get
func uniprot_StatusType_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_StatusType(handle)
	return C.CString(string(op.Status))
}

//export uniprot_StatusType_Status_Set
func uniprot_StatusType_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_StatusType(handle)
	op.Status = uniprot.Status(C.GoString(val))
}

// --- wrapping struct: uniprot.GeneLocationType ---
//
//export uniprot_GeneLocationType_CTor
func uniprot_GeneLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneLocationType(&uniprot.GeneLocationType{}))
}

//export uniprot_GeneLocationType_Name_Get
func uniprot_GeneLocationType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return handleFromPtr_Slice_uniprot_StatusType(&op.Name)
}

//export uniprot_GeneLocationType_Name_Set
func uniprot_GeneLocationType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_StatusType(val)
}

//export uniprot_GeneLocationType_Type_Get
func uniprot_GeneLocationType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_GeneLocationType_Type_Set
func uniprot_GeneLocationType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_GeneLocationType_Evidence_Get
func uniprot_GeneLocationType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_GeneLocationType_Evidence_Set
func uniprot_GeneLocationType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Entry ---
//
//export uniprot_Entry_CTor
func uniprot_Entry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Entry(&uniprot.Entry{}))
}

//export uniprot_Entry_Accession_Get
func uniprot_Entry_Accession_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_string(&op.Accession)
}

//export uniprot_Entry_Accession_Set
func uniprot_Entry_Accession_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Accession = deptrFromHandle_Slice_string(val)
}

//export uniprot_Entry_Name_Get
func uniprot_Entry_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_string(&op.Name)
}

//export uniprot_Entry_Name_Set
func uniprot_Entry_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Name = deptrFromHandle_Slice_string(val)
}

//export uniprot_Entry_Protein_Get
func uniprot_Entry_Protein_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_ProteinType(&op.Protein)
}

//export uniprot_Entry_Protein_Set
func uniprot_Entry_Protein_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Protein = *ptrFromHandle_uniprot_ProteinType(val)
}

//export uniprot_Entry_Gene_Get
func uniprot_Entry_Gene_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_GeneType(&op.Gene)
}

//export uniprot_Entry_Gene_Set
func uniprot_Entry_Gene_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Gene = deptrFromHandle_Slice_uniprot_GeneType(val)
}

//export uniprot_Entry_Organism_Get
func uniprot_Entry_Organism_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_OrganismType(&op.Organism)
}

//export uniprot_Entry_Organism_Set
func uniprot_Entry_Organism_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Organism = *ptrFromHandle_uniprot_OrganismType(val)
}

//export uniprot_Entry_OrganismHost_Get
func uniprot_Entry_OrganismHost_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_OrganismType(&op.OrganismHost)
}

//export uniprot_Entry_OrganismHost_Set
func uniprot_Entry_OrganismHost_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.OrganismHost = deptrFromHandle_Slice_uniprot_OrganismType(val)
}

//export uniprot_Entry_GeneLocation_Get
func uniprot_Entry_GeneLocation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_GeneLocationType(&op.GeneLocation)
}

//export uniprot_Entry_GeneLocation_Set
func uniprot_Entry_GeneLocation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.GeneLocation = deptrFromHandle_Slice_uniprot_GeneLocationType(val)
}

//export uniprot_Entry_Reference_Get
func uniprot_Entry_Reference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_ReferenceType(&op.Reference)
}

//export uniprot_Entry_Reference_Set
func uniprot_Entry_Reference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Reference = deptrFromHandle_Slice_uniprot_ReferenceType(val)
}

//export uniprot_Entry_Comment_Get
func uniprot_Entry_Comment_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_CommentType(&op.Comment)
}

//export uniprot_Entry_Comment_Set
func uniprot_Entry_Comment_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Comment = deptrFromHandle_Slice_uniprot_CommentType(val)
}

//export uniprot_Entry_DbReference_Get
func uniprot_Entry_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_Entry_DbReference_Set
func uniprot_Entry_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_Entry_ProteinExistence_Get
func uniprot_Entry_ProteinExistence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_ProteinExistenceType(&op.ProteinExistence)
}

//export uniprot_Entry_ProteinExistence_Set
func uniprot_Entry_ProteinExistence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.ProteinExistence = *ptrFromHandle_uniprot_ProteinExistenceType(val)
}

//export uniprot_Entry_Keyword_Get
func uniprot_Entry_Keyword_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_KeywordType(&op.Keyword)
}

//export uniprot_Entry_Keyword_Set
func uniprot_Entry_Keyword_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Keyword = deptrFromHandle_Slice_uniprot_KeywordType(val)
}

//export uniprot_Entry_Feature_Get
func uniprot_Entry_Feature_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_FeatureType(&op.Feature)
}

//export uniprot_Entry_Feature_Set
func uniprot_Entry_Feature_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Feature = deptrFromHandle_Slice_uniprot_FeatureType(val)
}

//export uniprot_Entry_Evidence_Get
func uniprot_Entry_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_EvidenceType(&op.Evidence)
}

//export uniprot_Entry_Evidence_Set
func uniprot_Entry_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Evidence = deptrFromHandle_Slice_uniprot_EvidenceType(val)
}

//export uniprot_Entry_Sequence_Get
func uniprot_Entry_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_SequenceType(&op.Sequence)
}

//export uniprot_Entry_Sequence_Set
func uniprot_Entry_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Sequence = *ptrFromHandle_uniprot_SequenceType(val)
}

//export uniprot_Entry_Dataset_Get
func uniprot_Entry_Dataset_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Entry(handle)
	return C.CString(string(op.Dataset))
}

//export uniprot_Entry_Dataset_Set
func uniprot_Entry_Dataset_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Dataset = uniprot.Dataset(C.GoString(val))
}

//export uniprot_Entry_Created_Get
func uniprot_Entry_Created_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_time_Time(&op.Created)
}

//export uniprot_Entry_Created_Set
func uniprot_Entry_Created_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Created = *ptrFromHandle_time_Time(val)
}

//export uniprot_Entry_Modified_Get
func uniprot_Entry_Modified_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_time_Time(&op.Modified)
}

//export uniprot_Entry_Modified_Set
func uniprot_Entry_Modified_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Modified = *ptrFromHandle_time_Time(val)
}

//export uniprot_Entry_Version_Get
func uniprot_Entry_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_Entry(handle)
	return C.longlong(op.Version)
}

//export uniprot_Entry_Version_Set
func uniprot_Entry_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Version = int(val)
}

//export uniprot_Entry_UnmarshalXML
func uniprot_Entry_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.Entry")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.Name ---
//
//export uniprot_Name_CTor
func uniprot_Name_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Name(&uniprot.Name{}))
}

//export uniprot_Name_Value_Get
func uniprot_Name_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Name(handle)
	return C.CString(op.Value)
}

//export uniprot_Name_Value_Set
func uniprot_Name_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Name(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Name_Evidence_Get
func uniprot_Name_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Name(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Name_Evidence_Set
func uniprot_Name_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Name(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.PhysiologicalReactionType ---
//
//export uniprot_PhysiologicalReactionType_CTor
func uniprot_PhysiologicalReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PhysiologicalReactionType(&uniprot.PhysiologicalReactionType{}))
}

//export uniprot_PhysiologicalReactionType_DbReference_Get
func uniprot_PhysiologicalReactionType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_PhysiologicalReactionType_DbReference_Set
func uniprot_PhysiologicalReactionType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_PhysiologicalReactionType_Direction_Get
func uniprot_PhysiologicalReactionType_Direction_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return C.CString(string(op.Direction))
}

//export uniprot_PhysiologicalReactionType_Direction_Set
func uniprot_PhysiologicalReactionType_Direction_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.Direction = uniprot.Direction(C.GoString(val))
}

//export uniprot_PhysiologicalReactionType_Evidence_Get
func uniprot_PhysiologicalReactionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_PhysiologicalReactionType_Evidence_Set
func uniprot_PhysiologicalReactionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ProteinExistenceType ---
//
//export uniprot_ProteinExistenceType_CTor
func uniprot_ProteinExistenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ProteinExistenceType(&uniprot.ProteinExistenceType{}))
}

//export uniprot_ProteinExistenceType_Type_Get
func uniprot_ProteinExistenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ProteinExistenceType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_ProteinExistenceType_Type_Set
func uniprot_ProteinExistenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ProteinExistenceType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.ConsortiumType ---
//
//export uniprot_ConsortiumType_CTor
func uniprot_ConsortiumType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ConsortiumType(&uniprot.ConsortiumType{}))
}

//export uniprot_ConsortiumType_Name_Get
func uniprot_ConsortiumType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ConsortiumType(handle)
	return C.CString(op.Name)
}

//export uniprot_ConsortiumType_Name_Set
func uniprot_ConsortiumType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ConsortiumType(handle)
	op.Name = C.GoString(val)
}

// --- wrapping struct: uniprot.Kinetics ---
//
//export uniprot_Kinetics_CTor
func uniprot_Kinetics_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Kinetics(&uniprot.Kinetics{}))
}

//export uniprot_Kinetics_KM_Get
func uniprot_Kinetics_KM_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.KM)
}

//export uniprot_Kinetics_KM_Set
func uniprot_Kinetics_KM_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.KM = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Kinetics_Vmax_Get
func uniprot_Kinetics_Vmax_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Vmax)
}

//export uniprot_Kinetics_Vmax_Set
func uniprot_Kinetics_Vmax_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.Vmax = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Kinetics_Text_Get
func uniprot_Kinetics_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_Kinetics_Text_Set
func uniprot_Kinetics_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.PersonType ---
//
//export uniprot_PersonType_CTor
func uniprot_PersonType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PersonType(&uniprot.PersonType{}))
}

//export uniprot_PersonType_Name_Get
func uniprot_PersonType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PersonType(handle)
	return C.CString(op.Name)
}

//export uniprot_PersonType_Name_Set
func uniprot_PersonType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PersonType(handle)
	op.Name = C.GoString(val)
}

// --- wrapping struct: uniprot.RedoxPotential ---
//
//export uniprot_RedoxPotential_CTor
func uniprot_RedoxPotential_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_RedoxPotential(&uniprot.RedoxPotential{}))
}

//export uniprot_RedoxPotential_Text_Get
func uniprot_RedoxPotential_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RedoxPotential(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_RedoxPotential_Text_Set
func uniprot_RedoxPotential_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RedoxPotential(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Conflict ---
//
//export uniprot_Conflict_CTor
func uniprot_Conflict_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Conflict(&uniprot.Conflict{}))
}

//export uniprot_Conflict_Sequence_Get
func uniprot_Conflict_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Conflict(handle)
	return handleFromPtr_uniprot_Sequence(&op.Sequence)
}

//export uniprot_Conflict_Sequence_Set
func uniprot_Conflict_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Conflict(handle)
	op.Sequence = *ptrFromHandle_uniprot_Sequence(val)
}

//export uniprot_Conflict_Type_Get
func uniprot_Conflict_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Conflict(handle)
	return C.CString(string(op.Type))
}

//export uniprot_Conflict_Type_Set
func uniprot_Conflict_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Conflict(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.Lineage ---
//
//export uniprot_Lineage_CTor
func uniprot_Lineage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Lineage(&uniprot.Lineage{}))
}

//export uniprot_Lineage_Taxon_Get
func uniprot_Lineage_Taxon_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Lineage(handle)
	return handleFromPtr_Slice_string(&op.Taxon)
}

//export uniprot_Lineage_Taxon_Set
func uniprot_Lineage_Taxon_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Lineage(handle)
	op.Taxon = deptrFromHandle_Slice_string(val)
}

// --- wrapping struct: uniprot.ProteinType ---
//
//export uniprot_ProteinType_CTor
func uniprot_ProteinType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ProteinType(&uniprot.ProteinType{}))
}

//export uniprot_ProteinType_RecommendedName_Get
func uniprot_ProteinType_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_ProteinType_RecommendedName_Set
func uniprot_ProteinType_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_ProteinType_AlternativeName_Get
func uniprot_ProteinType_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_ProteinType_AlternativeName_Set
func uniprot_ProteinType_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_ProteinType_SubmittedName_Get
func uniprot_ProteinType_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_ProteinType_SubmittedName_Set
func uniprot_ProteinType_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_ProteinType_AllergenName_Get
func uniprot_ProteinType_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_ProteinType_AllergenName_Set
func uniprot_ProteinType_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_BiotechName_Get
func uniprot_ProteinType_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_ProteinType_BiotechName_Set
func uniprot_ProteinType_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_CdAntigenName_Get
func uniprot_ProteinType_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_ProteinType_CdAntigenName_Set
func uniprot_ProteinType_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_InnName_Get
func uniprot_ProteinType_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_ProteinType_InnName_Set
func uniprot_ProteinType_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_Domain_Get
func uniprot_ProteinType_Domain_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_Domain(&op.Domain)
}

//export uniprot_ProteinType_Domain_Set
func uniprot_ProteinType_Domain_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.Domain = deptrFromHandle_Slice_uniprot_Domain(val)
}

//export uniprot_ProteinType_Component_Get
func uniprot_ProteinType_Component_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_Component(&op.Component)
}

//export uniprot_ProteinType_Component_Set
func uniprot_ProteinType_Component_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.Component = deptrFromHandle_Slice_uniprot_Component(val)
}

// --- wrapping struct: uniprot.SourceType ---
//
//export uniprot_SourceType_CTor
func uniprot_SourceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SourceType(&uniprot.SourceType{}))
}

//export uniprot_SourceType_DbReference_Get
func uniprot_SourceType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_SourceType_DbReference_Set
func uniprot_SourceType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.Component ---
//
//export uniprot_Component_CTor
func uniprot_Component_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Component(&uniprot.Component{}))
}

//export uniprot_Component_RecommendedName_Get
func uniprot_Component_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_Component_RecommendedName_Set
func uniprot_Component_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_Component_AlternativeName_Get
func uniprot_Component_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_Component_AlternativeName_Set
func uniprot_Component_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_Component_SubmittedName_Get
func uniprot_Component_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_Component_SubmittedName_Set
func uniprot_Component_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_Component_AllergenName_Get
func uniprot_Component_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_Component_AllergenName_Set
func uniprot_Component_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_BiotechName_Get
func uniprot_Component_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_Component_BiotechName_Set
func uniprot_Component_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_CdAntigenName_Get
func uniprot_Component_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_Component_CdAntigenName_Set
func uniprot_Component_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_InnName_Get
func uniprot_Component_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_Component_InnName_Set
func uniprot_Component_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.CofactorType ---
//
//export uniprot_CofactorType_CTor
func uniprot_CofactorType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CofactorType(&uniprot.CofactorType{}))
}

//export uniprot_CofactorType_Name_Get
func uniprot_CofactorType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return C.CString(op.Name)
}

//export uniprot_CofactorType_Name_Set
func uniprot_CofactorType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CofactorType_DbReference_Get
func uniprot_CofactorType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_CofactorType_DbReference_Set
func uniprot_CofactorType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_CofactorType_Evidence_Get
func uniprot_CofactorType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_CofactorType_Evidence_Set
func uniprot_CofactorType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.EvidenceType ---
//
//export uniprot_EvidenceType_CTor
func uniprot_EvidenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EvidenceType(&uniprot.EvidenceType{}))
}

//export uniprot_EvidenceType_Source_Get
func uniprot_EvidenceType_Source_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_SourceType(&op.Source)
}

//export uniprot_EvidenceType_Source_Set
func uniprot_EvidenceType_Source_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Source = *ptrFromHandle_uniprot_SourceType(val)
}

//export uniprot_EvidenceType_ImportedFrom_Get
func uniprot_EvidenceType_ImportedFrom_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_ImportedFromType(&op.ImportedFrom)
}

//export uniprot_EvidenceType_ImportedFrom_Set
func uniprot_EvidenceType_ImportedFrom_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.ImportedFrom = *ptrFromHandle_uniprot_ImportedFromType(val)
}

//export uniprot_EvidenceType_Type_Get
func uniprot_EvidenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return C.CString(op.Type)
}

//export uniprot_EvidenceType_Type_Set
func uniprot_EvidenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_EvidenceType_Key_Get
func uniprot_EvidenceType_Key_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return C.longlong(op.Key)
}

//export uniprot_EvidenceType_Key_Set
func uniprot_EvidenceType_Key_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Key = int(val)
}

// --- wrapping struct: uniprot.ImportedFromType ---
//
//export uniprot_ImportedFromType_CTor
func uniprot_ImportedFromType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ImportedFromType(&uniprot.ImportedFromType{}))
}

//export uniprot_ImportedFromType_DbReference_Get
func uniprot_ImportedFromType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ImportedFromType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_ImportedFromType_DbReference_Set
func uniprot_ImportedFromType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ImportedFromType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.SourceDataType ---
//
//export uniprot_SourceDataType_CTor
func uniprot_SourceDataType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SourceDataType(&uniprot.SourceDataType{}))
}

//export uniprot_SourceDataType_Strain_Get
func uniprot_SourceDataType_Strain_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Strain(&op.Strain)
}

//export uniprot_SourceDataType_Strain_Set
func uniprot_SourceDataType_Strain_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Strain = *ptrFromHandle_uniprot_Strain(val)
}

//export uniprot_SourceDataType_Plasmid_Get
func uniprot_SourceDataType_Plasmid_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Plasmid(&op.Plasmid)
}

//export uniprot_SourceDataType_Plasmid_Set
func uniprot_SourceDataType_Plasmid_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Plasmid = *ptrFromHandle_uniprot_Plasmid(val)
}

//export uniprot_SourceDataType_Transposon_Get
func uniprot_SourceDataType_Transposon_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Transposon(&op.Transposon)
}

//export uniprot_SourceDataType_Transposon_Set
func uniprot_SourceDataType_Transposon_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Transposon = *ptrFromHandle_uniprot_Transposon(val)
}

//export uniprot_SourceDataType_Tissue_Get
func uniprot_SourceDataType_Tissue_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Tissue(&op.Tissue)
}

//export uniprot_SourceDataType_Tissue_Set
func uniprot_SourceDataType_Tissue_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Tissue = *ptrFromHandle_uniprot_Tissue(val)
}

// --- wrapping struct: uniprot.AlternativeName ---
//
//export uniprot_AlternativeName_CTor
func uniprot_AlternativeName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_AlternativeName(&uniprot.AlternativeName{}))
}

//export uniprot_AlternativeName_FullName_Get
func uniprot_AlternativeName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_AlternativeName_FullName_Set
func uniprot_AlternativeName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_AlternativeName_ShortName_Get
func uniprot_AlternativeName_ShortName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.ShortName)
}

//export uniprot_AlternativeName_ShortName_Set
func uniprot_AlternativeName_ShortName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.ShortName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_AlternativeName_EcNumber_Get
func uniprot_AlternativeName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_AlternativeName_EcNumber_Set
func uniprot_AlternativeName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.InteractantType ---
//
//export uniprot_InteractantType_CTor
func uniprot_InteractantType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_InteractantType(&uniprot.InteractantType{}))
}

//export uniprot_InteractantType_Id_Get
func uniprot_InteractantType_Id_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.Id)
}

//export uniprot_InteractantType_Id_Set
func uniprot_InteractantType_Id_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.Id = C.GoString(val)
}

//export uniprot_InteractantType_Label_Get
func uniprot_InteractantType_Label_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.Label)
}

//export uniprot_InteractantType_Label_Set
func uniprot_InteractantType_Label_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.Label = C.GoString(val)
}

//export uniprot_InteractantType_DbReference_Get
func uniprot_InteractantType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_InteractantType_DbReference_Set
func uniprot_InteractantType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_InteractantType_IntactId_Get
func uniprot_InteractantType_IntactId_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.IntactId)
}

//export uniprot_InteractantType_IntactId_Set
func uniprot_InteractantType_IntactId_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.IntactId = C.GoString(val)
}

// --- wrapping struct: uniprot.KeywordType ---
//
//export uniprot_KeywordType_CTor
func uniprot_KeywordType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_KeywordType(&uniprot.KeywordType{}))
}

//export uniprot_KeywordType_Value_Get
func uniprot_KeywordType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	return C.CString(op.Value)
}

//export uniprot_KeywordType_Value_Set
func uniprot_KeywordType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_KeywordType_Evidence_Get
func uniprot_KeywordType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_KeywordType_Evidence_Set
func uniprot_KeywordType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.EventType ---
//
//export uniprot_EventType_CTor
func uniprot_EventType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EventType(&uniprot.EventType{}))
}

//export uniprot_EventType_Type_Get
func uniprot_EventType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EventType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_EventType_Type_Set
func uniprot_EventType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EventType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.CitationType ---
//
//export uniprot_CitationType_CTor
func uniprot_CitationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CitationType(&uniprot.CitationType{}))
}

//export uniprot_CitationType_Title_Get
func uniprot_CitationType_Title_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Title)
}

//export uniprot_CitationType_Title_Set
func uniprot_CitationType_Title_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Title = C.GoString(val)
}

//export uniprot_CitationType_EditorList_Get
func uniprot_CitationType_EditorList_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_uniprot_NameListType(&op.EditorList)
}

//export uniprot_CitationType_EditorList_Set
func uniprot_CitationType_EditorList_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.EditorList = *ptrFromHandle_uniprot_NameListType(val)
}

//export uniprot_CitationType_AuthorList_Get
func uniprot_CitationType_AuthorList_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_uniprot_NameListType(&op.AuthorList)
}

//export uniprot_CitationType_AuthorList_Set
func uniprot_CitationType_AuthorList_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.AuthorList = *ptrFromHandle_uniprot_NameListType(val)
}

//export uniprot_CitationType_Locator_Get
func uniprot_CitationType_Locator_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Locator)
}

//export uniprot_CitationType_Locator_Set
func uniprot_CitationType_Locator_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Locator = C.GoString(val)
}

//export uniprot_CitationType_DbReference_Get
func uniprot_CitationType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_CitationType_DbReference_Set
func uniprot_CitationType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_CitationType_Type_Get
func uniprot_CitationType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_CitationType_Type_Set
func uniprot_CitationType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_CitationType_Date_Get
func uniprot_CitationType_Date_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(string(op.Date))
}

//export uniprot_CitationType_Date_Set
func uniprot_CitationType_Date_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Date = uniprot.Date(C.GoString(val))
}

//export uniprot_CitationType_Name_Get
func uniprot_CitationType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Name)
}

//export uniprot_CitationType_Name_Set
func uniprot_CitationType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CitationType_Volume_Get
func uniprot_CitationType_Volume_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Volume)
}

//export uniprot_CitationType_Volume_Set
func uniprot_CitationType_Volume_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Volume = C.GoString(val)
}

//export uniprot_CitationType_First_Get
func uniprot_CitationType_First_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.First)
}

//export uniprot_CitationType_First_Set
func uniprot_CitationType_First_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.First = C.GoString(val)
}

//export uniprot_CitationType_Last_Get
func uniprot_CitationType_Last_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Last)
}

//export uniprot_CitationType_Last_Set
func uniprot_CitationType_Last_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Last = C.GoString(val)
}

//export uniprot_CitationType_Publisher_Get
func uniprot_CitationType_Publisher_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Publisher)
}

//export uniprot_CitationType_Publisher_Set
func uniprot_CitationType_Publisher_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Publisher = C.GoString(val)
}

//export uniprot_CitationType_City_Get
func uniprot_CitationType_City_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.City)
}

//export uniprot_CitationType_City_Set
func uniprot_CitationType_City_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.City = C.GoString(val)
}

//export uniprot_CitationType_Db_Get
func uniprot_CitationType_Db_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Db)
}

//export uniprot_CitationType_Db_Set
func uniprot_CitationType_Db_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Db = C.GoString(val)
}

//export uniprot_CitationType_Number_Get
func uniprot_CitationType_Number_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Number)
}

//export uniprot_CitationType_Number_Set
func uniprot_CitationType_Number_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Number = C.GoString(val)
}

//export uniprot_CitationType_Institute_Get
func uniprot_CitationType_Institute_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Institute)
}

//export uniprot_CitationType_Institute_Set
func uniprot_CitationType_Institute_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Institute = C.GoString(val)
}

//export uniprot_CitationType_Country_Get
func uniprot_CitationType_Country_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Country)
}

//export uniprot_CitationType_Country_Set
func uniprot_CitationType_Country_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Country = C.GoString(val)
}

// --- wrapping struct: uniprot.Domain ---
//
//export uniprot_Domain_CTor
func uniprot_Domain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Domain(&uniprot.Domain{}))
}

//export uniprot_Domain_RecommendedName_Get
func uniprot_Domain_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_Domain_RecommendedName_Set
func uniprot_Domain_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_Domain_AlternativeName_Get
func uniprot_Domain_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_Domain_AlternativeName_Set
func uniprot_Domain_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_Domain_SubmittedName_Get
func uniprot_Domain_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_Domain_SubmittedName_Set
func uniprot_Domain_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_Domain_AllergenName_Get
func uniprot_Domain_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_Domain_AllergenName_Set
func uniprot_Domain_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_BiotechName_Get
func uniprot_Domain_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_Domain_BiotechName_Set
func uniprot_Domain_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_CdAntigenName_Get
func uniprot_Domain_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_Domain_CdAntigenName_Set
func uniprot_Domain_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_InnName_Get
func uniprot_Domain_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_Domain_InnName_Set
func uniprot_Domain_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.EvidencedStringType ---
//
//export uniprot_EvidencedStringType_CTor
func uniprot_EvidencedStringType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EvidencedStringType(&uniprot.EvidencedStringType{}))
}

//export uniprot_EvidencedStringType_Value_Get
func uniprot_EvidencedStringType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	return C.CString(op.Value)
}

//export uniprot_EvidencedStringType_Value_Set
func uniprot_EvidencedStringType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_EvidencedStringType_Evidence_Get
func uniprot_EvidencedStringType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_EvidencedStringType_Evidence_Set
func uniprot_EvidencedStringType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Plasmid ---
//
//export uniprot_Plasmid_CTor
func uniprot_Plasmid_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Plasmid(&uniprot.Plasmid{}))
}

//export uniprot_Plasmid_Value_Get
func uniprot_Plasmid_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	return C.CString(op.Value)
}

//export uniprot_Plasmid_Value_Set
func uniprot_Plasmid_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Plasmid_Evidence_Get
func uniprot_Plasmid_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Plasmid_Evidence_Set
func uniprot_Plasmid_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ReferenceType ---
//
//export uniprot_ReferenceType_CTor
func uniprot_ReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ReferenceType(&uniprot.ReferenceType{}))
}

//export uniprot_ReferenceType_Citation_Get
func uniprot_ReferenceType_Citation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_CitationType(&op.Citation)
}

//export uniprot_ReferenceType_Citation_Set
func uniprot_ReferenceType_Citation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Citation = *ptrFromHandle_uniprot_CitationType(val)
}

//export uniprot_ReferenceType_Scope_Get
func uniprot_ReferenceType_Scope_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_Slice_string(&op.Scope)
}

//export uniprot_ReferenceType_Scope_Set
func uniprot_ReferenceType_Scope_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Scope = deptrFromHandle_Slice_string(val)
}

//export uniprot_ReferenceType_Source_Get
func uniprot_ReferenceType_Source_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_SourceDataType(&op.Source)
}

//export uniprot_ReferenceType_Source_Set
func uniprot_ReferenceType_Source_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Source = *ptrFromHandle_uniprot_SourceDataType(val)
}

//export uniprot_ReferenceType_Evidence_Get
func uniprot_ReferenceType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_ReferenceType_Evidence_Set
func uniprot_ReferenceType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_ReferenceType_Key_Get
func uniprot_ReferenceType_Key_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return C.CString(op.Key)
}

//export uniprot_ReferenceType_Key_Set
func uniprot_ReferenceType_Key_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Key = C.GoString(val)
}

// --- wrapping struct: uniprot.TemperatureDependence ---
//
//export uniprot_TemperatureDependence_CTor
func uniprot_TemperatureDependence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_TemperatureDependence(&uniprot.TemperatureDependence{}))
}

//export uniprot_TemperatureDependence_Text_Get
func uniprot_TemperatureDependence_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_TemperatureDependence(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_TemperatureDependence_Text_Set
func uniprot_TemperatureDependence_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_TemperatureDependence(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Absorption ---
//
//export uniprot_Absorption_CTor
func uniprot_Absorption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Absorption(&uniprot.Absorption{}))
}

//export uniprot_Absorption_Max_Get
func uniprot_Absorption_Max_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Absorption(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.Max)
}

//export uniprot_Absorption_Max_Set
func uniprot_Absorption_Max_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Absorption(handle)
	op.Max = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Absorption_Text_Get
func uniprot_Absorption_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Absorption(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_Absorption_Text_Set
func uniprot_Absorption_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Absorption(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.IsoformType ---
//
//export uniprot_IsoformType_CTor
func uniprot_IsoformType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_IsoformType(&uniprot.IsoformType{}))
}

//export uniprot_IsoformType_Id_Get
func uniprot_IsoformType_Id_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_string(&op.Id)
}

//export uniprot_IsoformType_Id_Set
func uniprot_IsoformType_Id_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Id = deptrFromHandle_Slice_string(val)
}

//export uniprot_IsoformType_Name_Get
func uniprot_IsoformType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_uniprot_Name(&op.Name)
}

//export uniprot_IsoformType_Name_Set
func uniprot_IsoformType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_Name(val)
}

//export uniprot_IsoformType_Sequence_Get
func uniprot_IsoformType_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_uniprot_Anon6(&op.Sequence)
}

//export uniprot_IsoformType_Sequence_Set
func uniprot_IsoformType_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Sequence = *ptrFromHandle_uniprot_Anon6(val)
}

//export uniprot_IsoformType_Text_Get
func uniprot_IsoformType_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_IsoformType_Text_Set
func uniprot_IsoformType_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.GeneNameType ---
//
//export uniprot_GeneNameType_CTor
func uniprot_GeneNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneNameType(&uniprot.GeneNameType{}))
}

//export uniprot_GeneNameType_Value_Get
func uniprot_GeneNameType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return C.CString(op.Value)
}

//export uniprot_GeneNameType_Value_Set
func uniprot_GeneNameType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_GeneNameType_Evidence_Get
func uniprot_GeneNameType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_GeneNameType_Evidence_Set
func uniprot_GeneNameType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_GeneNameType_Type_Get
func uniprot_GeneNameType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_GeneNameType_Type_Set
func uniprot_GeneNameType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// ---- Slices ---

// --- wrapping slice: uniprot.IntListType ---
//
//export uniprot_IntListType_CTor
func uniprot_IntListType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_IntListType(&uniprot.IntListType{}))
}

//export uniprot_IntListType_len
func uniprot_IntListType_len(handle CGoHandle) int {
	return len(deptrFromHandle_uniprot_IntListType(handle))
}

//export uniprot_IntListType_elem
func uniprot_IntListType_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_uniprot_IntListType(handle)
	return C.longlong(s[_idx])
}

//export uniprot_IntListType_subslice
func uniprot_IntListType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_uniprot_IntListType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_uniprot_IntListType(&ss))
}

//export uniprot_IntListType_set
func uniprot_IntListType_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_uniprot_IntListType(handle)
	s[_idx] = int(_vl)
}

//export uniprot_IntListType_append
func uniprot_IntListType_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_uniprot_IntListType(handle)
	*s = append(*s, int(_vl))
}

//export uniprot_IntListType_UnmarshalText
func uniprot_IntListType_UnmarshalText(_handle CGoHandle, text CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.IntListType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(*uniprot.IntListType).UnmarshalText(deptrFromHandle_Slice_byte(text))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: primers ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export primers_CreateBarcodes
func primers_CreateBarcodes(length C.longlong, maxSubSequence C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := primers.CreateBarcodes(int(length), int(maxSubSequence))

	return handleFromPtr_Slice_string(&cret)
}

//export primers_CreateBarcodesGcRange
func primers_CreateBarcodesGcRange(length C.longlong, maxSubSequence C.longlong, minGcContent C.double, maxGcContent C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := primers.CreateBarcodesGcRange(int(length), int(maxSubSequence), float64(minGcContent), float64(maxGcContent))

	return handleFromPtr_Slice_string(&cret)
}

//export primers_MarmurDoty
func primers_MarmurDoty(sequence *C.char) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.double(primers.MarmurDoty(C.GoString(sequence)))

}

//export primers_MeltingTemp
func primers_MeltingTemp(sequence *C.char) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.double(primers.MeltingTemp(C.GoString(sequence)))

}

//export primers_NucleobaseDeBruijnSequence
func primers_NucleobaseDeBruijnSequence(substringLength C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(primers.NucleobaseDeBruijnSequence(int(substringLength)))

}

// ---- Package: pcr ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export pcr_Simulate
func pcr_Simulate(sequences CGoHandle, targetTm C.double, circular C.char, primerList CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := pcr.Simulate(deptrFromHandle_Slice_string(sequences), float64(targetTm), boolPyToGo(circular), deptrFromHandle_Slice_string(primerList))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export pcr_SimulateSimple
func pcr_SimulateSimple(sequences CGoHandle, targetTm C.double, circular C.char, primerList CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := pcr.SimulateSimple(deptrFromHandle_Slice_string(sequences), float64(targetTm), boolPyToGo(circular), deptrFromHandle_Slice_string(primerList))

	return handleFromPtr_Slice_string(&cret)
}

// ---- Package: random ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export random_DNASequence
func random_DNASequence(length C.longlong, seed C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := random.DNASequence(int(length), int64(seed))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export random_ProteinSequence
func random_ProteinSequence(length C.longlong, seed C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := random.ProteinSequence(int(length), int64(seed))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export random_RNASequence
func random_RNASequence(length C.longlong, seed C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := random.RNASequence(int(length), int64(seed))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// ---- Package: search ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: align ---

// ---- Types ---

// Converters for pointer handles for type: *align.Scoring
func ptrFromHandle_Ptr_align_Scoring(h CGoHandle) *align.Scoring {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*align.Scoring")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(align.Scoring{})).(*align.Scoring)
}
func handleFromPtr_Ptr_align_Scoring(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*align.Scoring", p))
}

// Converters for non-pointer handles for type: align.Scoring
func ptrFromHandle_align_Scoring(h CGoHandle) *align.Scoring {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "align.Scoring")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(align.Scoring{})).(*align.Scoring)
}
func handleFromPtr_align_Scoring(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("align.Scoring", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: align.Scoring ---
//
//export align_Scoring_CTor
func align_Scoring_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_align_Scoring(&align.Scoring{}))
}

//export align_Scoring_SubstitutionMatrix_Get
func align_Scoring_SubstitutionMatrix_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_align_Scoring(handle)
	return handleFromPtr_Ptr_matrix_SubstitutionMatrix(op.SubstitutionMatrix)
}

//export align_Scoring_SubstitutionMatrix_Set
func align_Scoring_SubstitutionMatrix_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_align_Scoring(handle)
	op.SubstitutionMatrix = ptrFromHandle_Ptr_matrix_SubstitutionMatrix(val)
}

//export align_Scoring_GapPenalty_Get
func align_Scoring_GapPenalty_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_align_Scoring(handle)
	return C.longlong(op.GapPenalty)
}

//export align_Scoring_GapPenalty_Set
func align_Scoring_GapPenalty_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_align_Scoring(handle)
	op.GapPenalty = int(val)
}

//export align_Scoring_Score
func align_Scoring_Score(_handle CGoHandle, a C.char, b C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*align.Scoring")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(align.Scoring{})).(*align.Scoring).Score(byte(a), byte(b))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export align_NewScoring
func align_NewScoring(substitutionMatrix CGoHandle, gapPenalty C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := align.NewScoring(ptrFromHandle_Ptr_matrix_SubstitutionMatrix(substitutionMatrix), int(gapPenalty))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_align_Scoring(nil)
	}
	return handleFromPtr_align_Scoring(&cret)
}

// ---- Functions ---

// ---- Package: matrix ---

// ---- Types ---

// Converters for pointer handles for type: *matrix.SubstitutionMatrix
func ptrFromHandle_Ptr_matrix_SubstitutionMatrix(h CGoHandle) *matrix.SubstitutionMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*matrix.SubstitutionMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix)
}
func handleFromPtr_Ptr_matrix_SubstitutionMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*matrix.SubstitutionMatrix", p))
}

// Converters for non-pointer handles for type: matrix.SubstitutionMatrix
func ptrFromHandle_matrix_SubstitutionMatrix(h CGoHandle) *matrix.SubstitutionMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "matrix.SubstitutionMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix)
}
func handleFromPtr_matrix_SubstitutionMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("matrix.SubstitutionMatrix", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export matrix_BLOSUM100
func matrix_BLOSUM100() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM100)
}

//export matrix_Set_BLOSUM100
func matrix_Set_BLOSUM100(val CGoHandle) {
	matrix.BLOSUM100 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM30
func matrix_BLOSUM30() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM30)
}

//export matrix_Set_BLOSUM30
func matrix_Set_BLOSUM30(val CGoHandle) {
	matrix.BLOSUM30 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM35
func matrix_BLOSUM35() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM35)
}

//export matrix_Set_BLOSUM35
func matrix_Set_BLOSUM35(val CGoHandle) {
	matrix.BLOSUM35 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM40
func matrix_BLOSUM40() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM40)
}

//export matrix_Set_BLOSUM40
func matrix_Set_BLOSUM40(val CGoHandle) {
	matrix.BLOSUM40 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM45
func matrix_BLOSUM45() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM45)
}

//export matrix_Set_BLOSUM45
func matrix_Set_BLOSUM45(val CGoHandle) {
	matrix.BLOSUM45 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM50
func matrix_BLOSUM50() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM50)
}

//export matrix_Set_BLOSUM50
func matrix_Set_BLOSUM50(val CGoHandle) {
	matrix.BLOSUM50 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM55
func matrix_BLOSUM55() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM55)
}

//export matrix_Set_BLOSUM55
func matrix_Set_BLOSUM55(val CGoHandle) {
	matrix.BLOSUM55 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM60
func matrix_BLOSUM60() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM60)
}

//export matrix_Set_BLOSUM60
func matrix_Set_BLOSUM60(val CGoHandle) {
	matrix.BLOSUM60 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM62
func matrix_BLOSUM62() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM62)
}

//export matrix_Set_BLOSUM62
func matrix_Set_BLOSUM62(val CGoHandle) {
	matrix.BLOSUM62 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM65
func matrix_BLOSUM65() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM65)
}

//export matrix_Set_BLOSUM65
func matrix_Set_BLOSUM65(val CGoHandle) {
	matrix.BLOSUM65 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM70
func matrix_BLOSUM70() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM70)
}

//export matrix_Set_BLOSUM70
func matrix_Set_BLOSUM70(val CGoHandle) {
	matrix.BLOSUM70 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM75
func matrix_BLOSUM75() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM75)
}

//export matrix_Set_BLOSUM75
func matrix_Set_BLOSUM75(val CGoHandle) {
	matrix.BLOSUM75 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM80
func matrix_BLOSUM80() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM80)
}

//export matrix_Set_BLOSUM80
func matrix_Set_BLOSUM80(val CGoHandle) {
	matrix.BLOSUM80 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM85
func matrix_BLOSUM85() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM85)
}

//export matrix_Set_BLOSUM85
func matrix_Set_BLOSUM85(val CGoHandle) {
	matrix.BLOSUM85 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM90
func matrix_BLOSUM90() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM90)
}

//export matrix_Set_BLOSUM90
func matrix_Set_BLOSUM90(val CGoHandle) {
	matrix.BLOSUM90 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUMN
func matrix_BLOSUMN() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUMN)
}

//export matrix_Set_BLOSUMN
func matrix_Set_BLOSUMN(val CGoHandle) {
	matrix.BLOSUMN = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_DAYHOFF
func matrix_DAYHOFF() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.DAYHOFF)
}

//export matrix_Set_DAYHOFF
func matrix_Set_DAYHOFF(val CGoHandle) {
	matrix.DAYHOFF = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_Default
func matrix_Default() CGoHandle {
	return handleFromPtr_Ptr_matrix_SubstitutionMatrix(matrix.Default)
}

//export matrix_Set_Default
func matrix_Set_Default(val CGoHandle) {
	matrix.Default = ptrFromHandle_Ptr_matrix_SubstitutionMatrix(val)
}

//export matrix_GONNET
func matrix_GONNET() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.GONNET)
}

//export matrix_Set_GONNET
func matrix_Set_GONNET(val CGoHandle) {
	matrix.GONNET = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_IDENTITY
func matrix_IDENTITY() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.IDENTITY)
}

//export matrix_Set_IDENTITY
func matrix_Set_IDENTITY(val CGoHandle) {
	matrix.IDENTITY = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_MATCH
func matrix_MATCH() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.MATCH)
}

//export matrix_Set_MATCH
func matrix_Set_MATCH(val CGoHandle) {
	matrix.MATCH = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_NUC_4
func matrix_NUC_4() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.NUC_4)
}

//export matrix_Set_NUC_4
func matrix_Set_NUC_4(val CGoHandle) {
	matrix.NUC_4 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_NUC_4_4
func matrix_NUC_4_4() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.NUC_4_4)
}

//export matrix_Set_NUC_4_4
func matrix_Set_NUC_4_4(val CGoHandle) {
	matrix.NUC_4_4 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM10
func matrix_PAM10() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM10)
}

//export matrix_Set_PAM10
func matrix_Set_PAM10(val CGoHandle) {
	matrix.PAM10 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM100
func matrix_PAM100() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM100)
}

//export matrix_Set_PAM100
func matrix_Set_PAM100(val CGoHandle) {
	matrix.PAM100 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM110
func matrix_PAM110() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM110)
}

//export matrix_Set_PAM110
func matrix_Set_PAM110(val CGoHandle) {
	matrix.PAM110 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM120
func matrix_PAM120() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM120)
}

//export matrix_Set_PAM120
func matrix_Set_PAM120(val CGoHandle) {
	matrix.PAM120 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM120_cdi
func matrix_PAM120_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM120_cdi)
}

//export matrix_Set_PAM120_cdi
func matrix_Set_PAM120_cdi(val CGoHandle) {
	matrix.PAM120_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM130
func matrix_PAM130() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM130)
}

//export matrix_Set_PAM130
func matrix_Set_PAM130(val CGoHandle) {
	matrix.PAM130 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM140
func matrix_PAM140() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM140)
}

//export matrix_Set_PAM140
func matrix_Set_PAM140(val CGoHandle) {
	matrix.PAM140 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM150
func matrix_PAM150() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM150)
}

//export matrix_Set_PAM150
func matrix_Set_PAM150(val CGoHandle) {
	matrix.PAM150 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM160
func matrix_PAM160() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM160)
}

//export matrix_Set_PAM160
func matrix_Set_PAM160(val CGoHandle) {
	matrix.PAM160 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM160_cdi
func matrix_PAM160_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM160_cdi)
}

//export matrix_Set_PAM160_cdi
func matrix_Set_PAM160_cdi(val CGoHandle) {
	matrix.PAM160_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM170
func matrix_PAM170() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM170)
}

//export matrix_Set_PAM170
func matrix_Set_PAM170(val CGoHandle) {
	matrix.PAM170 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM180
func matrix_PAM180() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM180)
}

//export matrix_Set_PAM180
func matrix_Set_PAM180(val CGoHandle) {
	matrix.PAM180 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM190
func matrix_PAM190() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM190)
}

//export matrix_Set_PAM190
func matrix_Set_PAM190(val CGoHandle) {
	matrix.PAM190 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM20
func matrix_PAM20() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM20)
}

//export matrix_Set_PAM20
func matrix_Set_PAM20(val CGoHandle) {
	matrix.PAM20 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM200
func matrix_PAM200() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM200)
}

//export matrix_Set_PAM200
func matrix_Set_PAM200(val CGoHandle) {
	matrix.PAM200 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM200_cdi
func matrix_PAM200_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM200_cdi)
}

//export matrix_Set_PAM200_cdi
func matrix_Set_PAM200_cdi(val CGoHandle) {
	matrix.PAM200_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM210
func matrix_PAM210() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM210)
}

//export matrix_Set_PAM210
func matrix_Set_PAM210(val CGoHandle) {
	matrix.PAM210 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM220
func matrix_PAM220() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM220)
}

//export matrix_Set_PAM220
func matrix_Set_PAM220(val CGoHandle) {
	matrix.PAM220 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM230
func matrix_PAM230() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM230)
}

//export matrix_Set_PAM230
func matrix_Set_PAM230(val CGoHandle) {
	matrix.PAM230 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM240
func matrix_PAM240() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM240)
}

//export matrix_Set_PAM240
func matrix_Set_PAM240(val CGoHandle) {
	matrix.PAM240 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM250
func matrix_PAM250() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM250)
}

//export matrix_Set_PAM250
func matrix_Set_PAM250(val CGoHandle) {
	matrix.PAM250 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM250_cdi
func matrix_PAM250_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM250_cdi)
}

//export matrix_Set_PAM250_cdi
func matrix_Set_PAM250_cdi(val CGoHandle) {
	matrix.PAM250_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM260
func matrix_PAM260() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM260)
}

//export matrix_Set_PAM260
func matrix_Set_PAM260(val CGoHandle) {
	matrix.PAM260 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM270
func matrix_PAM270() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM270)
}

//export matrix_Set_PAM270
func matrix_Set_PAM270(val CGoHandle) {
	matrix.PAM270 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM280
func matrix_PAM280() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM280)
}

//export matrix_Set_PAM280
func matrix_Set_PAM280(val CGoHandle) {
	matrix.PAM280 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM290
func matrix_PAM290() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM290)
}

//export matrix_Set_PAM290
func matrix_Set_PAM290(val CGoHandle) {
	matrix.PAM290 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM30
func matrix_PAM30() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM30)
}

//export matrix_Set_PAM30
func matrix_Set_PAM30(val CGoHandle) {
	matrix.PAM30 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM300
func matrix_PAM300() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM300)
}

//export matrix_Set_PAM300
func matrix_Set_PAM300(val CGoHandle) {
	matrix.PAM300 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM310
func matrix_PAM310() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM310)
}

//export matrix_Set_PAM310
func matrix_Set_PAM310(val CGoHandle) {
	matrix.PAM310 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM320
func matrix_PAM320() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM320)
}

//export matrix_Set_PAM320
func matrix_Set_PAM320(val CGoHandle) {
	matrix.PAM320 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM330
func matrix_PAM330() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM330)
}

//export matrix_Set_PAM330
func matrix_Set_PAM330(val CGoHandle) {
	matrix.PAM330 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM340
func matrix_PAM340() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM340)
}

//export matrix_Set_PAM340
func matrix_Set_PAM340(val CGoHandle) {
	matrix.PAM340 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM350
func matrix_PAM350() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM350)
}

//export matrix_Set_PAM350
func matrix_Set_PAM350(val CGoHandle) {
	matrix.PAM350 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM360
func matrix_PAM360() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM360)
}

//export matrix_Set_PAM360
func matrix_Set_PAM360(val CGoHandle) {
	matrix.PAM360 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM370
func matrix_PAM370() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM370)
}

//export matrix_Set_PAM370
func matrix_Set_PAM370(val CGoHandle) {
	matrix.PAM370 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM380
func matrix_PAM380() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM380)
}

//export matrix_Set_PAM380
func matrix_Set_PAM380(val CGoHandle) {
	matrix.PAM380 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM390
func matrix_PAM390() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM390)
}

//export matrix_Set_PAM390
func matrix_Set_PAM390(val CGoHandle) {
	matrix.PAM390 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM40
func matrix_PAM40() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM40)
}

//export matrix_Set_PAM40
func matrix_Set_PAM40(val CGoHandle) {
	matrix.PAM40 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM400
func matrix_PAM400() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM400)
}

//export matrix_Set_PAM400
func matrix_Set_PAM400(val CGoHandle) {
	matrix.PAM400 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM40_cdi
func matrix_PAM40_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM40_cdi)
}

//export matrix_Set_PAM40_cdi
func matrix_Set_PAM40_cdi(val CGoHandle) {
	matrix.PAM40_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM410
func matrix_PAM410() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM410)
}

//export matrix_Set_PAM410
func matrix_Set_PAM410(val CGoHandle) {
	matrix.PAM410 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM420
func matrix_PAM420() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM420)
}

//export matrix_Set_PAM420
func matrix_Set_PAM420(val CGoHandle) {
	matrix.PAM420 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM430
func matrix_PAM430() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM430)
}

//export matrix_Set_PAM430
func matrix_Set_PAM430(val CGoHandle) {
	matrix.PAM430 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM440
func matrix_PAM440() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM440)
}

//export matrix_Set_PAM440
func matrix_Set_PAM440(val CGoHandle) {
	matrix.PAM440 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM450
func matrix_PAM450() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM450)
}

//export matrix_Set_PAM450
func matrix_Set_PAM450(val CGoHandle) {
	matrix.PAM450 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM460
func matrix_PAM460() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM460)
}

//export matrix_Set_PAM460
func matrix_Set_PAM460(val CGoHandle) {
	matrix.PAM460 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM470
func matrix_PAM470() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM470)
}

//export matrix_Set_PAM470
func matrix_Set_PAM470(val CGoHandle) {
	matrix.PAM470 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM480
func matrix_PAM480() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM480)
}

//export matrix_Set_PAM480
func matrix_Set_PAM480(val CGoHandle) {
	matrix.PAM480 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM490
func matrix_PAM490() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM490)
}

//export matrix_Set_PAM490
func matrix_Set_PAM490(val CGoHandle) {
	matrix.PAM490 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM50
func matrix_PAM50() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM50)
}

//export matrix_Set_PAM50
func matrix_Set_PAM50(val CGoHandle) {
	matrix.PAM50 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM500
func matrix_PAM500() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM500)
}

//export matrix_Set_PAM500
func matrix_Set_PAM500(val CGoHandle) {
	matrix.PAM500 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM60
func matrix_PAM60() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM60)
}

//export matrix_Set_PAM60
func matrix_Set_PAM60(val CGoHandle) {
	matrix.PAM60 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM70
func matrix_PAM70() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM70)
}

//export matrix_Set_PAM70
func matrix_Set_PAM70(val CGoHandle) {
	matrix.PAM70 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM80
func matrix_PAM80() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM80)
}

//export matrix_Set_PAM80
func matrix_Set_PAM80(val CGoHandle) {
	matrix.PAM80 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM80_cdi
func matrix_PAM80_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM80_cdi)
}

//export matrix_Set_PAM80_cdi
func matrix_Set_PAM80_cdi(val CGoHandle) {
	matrix.PAM80_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM90
func matrix_PAM90() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM90)
}

//export matrix_Set_PAM90
func matrix_Set_PAM90(val CGoHandle) {
	matrix.PAM90 = deptrFromHandle_Slice_Slice_int(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: matrix.SubstitutionMatrix ---
//
//export matrix_SubstitutionMatrix_CTor
func matrix_SubstitutionMatrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_matrix_SubstitutionMatrix(&matrix.SubstitutionMatrix{}))
}

//export matrix_SubstitutionMatrix_FirstAlphabet_Get
func matrix_SubstitutionMatrix_FirstAlphabet_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	return handleFromPtr_Ptr_alphabet_Alphabet(op.FirstAlphabet)
}

//export matrix_SubstitutionMatrix_FirstAlphabet_Set
func matrix_SubstitutionMatrix_FirstAlphabet_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	op.FirstAlphabet = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export matrix_SubstitutionMatrix_SecondAlphabet_Get
func matrix_SubstitutionMatrix_SecondAlphabet_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	return handleFromPtr_Ptr_alphabet_Alphabet(op.SecondAlphabet)
}

//export matrix_SubstitutionMatrix_SecondAlphabet_Set
func matrix_SubstitutionMatrix_SecondAlphabet_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	op.SecondAlphabet = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export matrix_SubstitutionMatrix_Score
func matrix_SubstitutionMatrix_Score(_handle CGoHandle, a *C.char, b *C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*matrix.SubstitutionMatrix")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix).Score(C.GoString(a), C.GoString(b))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export matrix_NewSubstitutionMatrix
func matrix_NewSubstitutionMatrix(firstAlphabet CGoHandle, secondAlphabet CGoHandle, scores CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := matrix.NewSubstitutionMatrix(ptrFromHandle_Ptr_alphabet_Alphabet(firstAlphabet), ptrFromHandle_Ptr_alphabet_Alphabet(secondAlphabet), deptrFromHandle_Slice_Slice_int(scores))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_matrix_SubstitutionMatrix(nil)
	}
	return handleFromPtr_Ptr_matrix_SubstitutionMatrix(cret)
}

// ---- Functions ---

// ---- Package: bwt ---

// ---- Types ---

// Converters for pointer handles for type: *bwt.BWT
func ptrFromHandle_Ptr_bwt_BWT(h CGoHandle) *bwt.BWT {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*bwt.BWT")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT)
}
func handleFromPtr_Ptr_bwt_BWT(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*bwt.BWT", p))
}

// Converters for non-pointer handles for type: bwt.BWT
func ptrFromHandle_bwt_BWT(h CGoHandle) *bwt.BWT {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "bwt.BWT")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT)
}
func handleFromPtr_bwt_BWT(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("bwt.BWT", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: bwt.BWT ---
//
//export bwt_BWT_CTor
func bwt_BWT_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_bwt_BWT(&bwt.BWT{}))
}

//export bwt_BWT_Count
func bwt_BWT_Count(_handle CGoHandle, pattern *C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bwt.BWT")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT).Count(C.GoString(pattern))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export bwt_BWT_Locate
func bwt_BWT_Locate(_handle CGoHandle, pattern *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bwt.BWT")
	if __err != nil {
		return handleFromPtr_Slice_int(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT).Locate(C.GoString(pattern))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_int(nil)
	}
	return handleFromPtr_Slice_int(&cret)
}

//export bwt_BWT_Extract
func bwt_BWT_Extract(_handle CGoHandle, start C.longlong, end C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bwt.BWT")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT).Extract(int(start), int(end))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export bwt_BWT_Len
func bwt_BWT_Len(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bwt.BWT")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT).Len())

}

//export bwt_BWT_GetTransform
func bwt_BWT_GetTransform(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bwt.BWT")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(bwt.BWT{})).(*bwt.BWT).GetTransform())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export bwt_New
func bwt_New(sequence *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := bwt.New(C.GoString(sequence))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_bwt_BWT(nil)
	}
	return handleFromPtr_bwt_BWT(&cret)
}

// ---- Functions ---

// ---- Package: mash ---

// ---- Types ---

// Converters for pointer handles for type: *mash.Mash
func ptrFromHandle_Ptr_mash_Mash(h CGoHandle) *mash.Mash {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*mash.Mash")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(mash.Mash{})).(*mash.Mash)
}
func handleFromPtr_Ptr_mash_Mash(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*mash.Mash", p))
}

// Converters for non-pointer handles for type: mash.Mash
func ptrFromHandle_mash_Mash(h CGoHandle) *mash.Mash {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "mash.Mash")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(mash.Mash{})).(*mash.Mash)
}
func handleFromPtr_mash_Mash(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("mash.Mash", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: mash.Mash ---
//
//export mash_Mash_CTor
func mash_Mash_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_mash_Mash(&mash.Mash{}))
}

//export mash_Mash_KmerSize_Get
func mash_Mash_KmerSize_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_mash_Mash(handle)
	return C.longlong(op.KmerSize)
}

//export mash_Mash_KmerSize_Set
func mash_Mash_KmerSize_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_mash_Mash(handle)
	op.KmerSize = int(val)
}

//export mash_Mash_SketchSize_Get
func mash_Mash_SketchSize_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_mash_Mash(handle)
	return C.longlong(op.SketchSize)
}

//export mash_Mash_SketchSize_Set
func mash_Mash_SketchSize_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_mash_Mash(handle)
	op.SketchSize = int(val)
}

//export mash_Mash_Sketches_Get
func mash_Mash_Sketches_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_mash_Mash(handle)
	return handleFromPtr_Slice_uint32(&op.Sketches)
}

//export mash_Mash_Sketches_Set
func mash_Mash_Sketches_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_mash_Mash(handle)
	op.Sketches = deptrFromHandle_Slice_uint32(val)
}

//export mash_Mash_Sketch
func mash_Mash_Sketch(_handle CGoHandle, sequence *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*mash.Mash")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(mash.Mash{})).(*mash.Mash).Sketch(C.GoString(sequence))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(mash.Mash{})).(*mash.Mash).Sketch(C.GoString(sequence))
	}
}

//export mash_Mash_Similarity
func mash_Mash_Similarity(_handle CGoHandle, other CGoHandle) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*mash.Mash")
	if __err != nil {
		return C.double(0)
	}
	return C.double(gopyh.Embed(vifc, reflect.TypeOf(mash.Mash{})).(*mash.Mash).Similarity(ptrFromHandle_Ptr_mash_Mash(other)))

}

//export mash_Mash_Distance
func mash_Mash_Distance(_handle CGoHandle, other CGoHandle) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*mash.Mash")
	if __err != nil {
		return C.double(0)
	}
	return C.double(gopyh.Embed(vifc, reflect.TypeOf(mash.Mash{})).(*mash.Mash).Distance(ptrFromHandle_Ptr_mash_Mash(other)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export mash_New
func mash_New(kmerSize C.longlong, sketchSize C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_mash_Mash(mash.New(int(kmerSize), int(sketchSize)))

}

// ---- Functions ---

// ---- Package: seqhash ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export seqhash_Hash
func seqhash_Hash(sequence *C.char, sequenceType *C.char, circular C.char, doubleStranded C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := seqhash.Hash(C.GoString(sequence), seqhash.SequenceType(C.GoString(sequenceType)), boolPyToGo(circular), boolPyToGo(doubleStranded))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export seqhash_RotateSequence
func seqhash_RotateSequence(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(seqhash.RotateSequence(C.GoString(sequence)))

}

// ---- Package: synthesis ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: codon ---

// ---- Types ---

// Converters for pointer handles for type: *codon.AminoAcid
func ptrFromHandle_Ptr_codon_AminoAcid(h CGoHandle) *codon.AminoAcid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*codon.AminoAcid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.AminoAcid{})).(*codon.AminoAcid)
}
func handleFromPtr_Ptr_codon_AminoAcid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*codon.AminoAcid", p))
}

// Converters for pointer handles for type: *codon.Codon
func ptrFromHandle_Ptr_codon_Codon(h CGoHandle) *codon.Codon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*codon.Codon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.Codon{})).(*codon.Codon)
}
func handleFromPtr_Ptr_codon_Codon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*codon.Codon", p))
}

// Converters for pointer handles for type: *codon.Stats
func ptrFromHandle_Ptr_codon_Stats(h CGoHandle) *codon.Stats {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*codon.Stats")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.Stats{})).(*codon.Stats)
}
func handleFromPtr_Ptr_codon_Stats(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*codon.Stats", p))
}

// Converters for pointer handles for type: *codon.TranslationTable
func ptrFromHandle_Ptr_codon_TranslationTable(h CGoHandle) *codon.TranslationTable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*codon.TranslationTable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable)
}
func handleFromPtr_Ptr_codon_TranslationTable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*codon.TranslationTable", p))
}

// Converters for implicit pointer handles for type: []codon.AminoAcid
func ptrFromHandle_Slice_codon_AminoAcid(h CGoHandle) *[]codon.AminoAcid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]codon.AminoAcid")
	if p == nil {
		return nil
	}
	return p.(*[]codon.AminoAcid)
}
func deptrFromHandle_Slice_codon_AminoAcid(h CGoHandle) []codon.AminoAcid {
	p := ptrFromHandle_Slice_codon_AminoAcid(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_codon_AminoAcid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]codon.AminoAcid", p))
}

// --- wrapping slice: []codon.AminoAcid ---
//
//export Slice_codon_AminoAcid_CTor
func Slice_codon_AminoAcid_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_codon_AminoAcid(&[]codon.AminoAcid{}))
}

//export Slice_codon_AminoAcid_len
func Slice_codon_AminoAcid_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_codon_AminoAcid(handle))
}

//export Slice_codon_AminoAcid_elem
func Slice_codon_AminoAcid_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_codon_AminoAcid(handle)
	return handleFromPtr_codon_AminoAcid(&(s[_idx]))
}

//export Slice_codon_AminoAcid_subslice
func Slice_codon_AminoAcid_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_codon_AminoAcid(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_codon_AminoAcid(&ss))
}

//export Slice_codon_AminoAcid_set
func Slice_codon_AminoAcid_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_codon_AminoAcid(handle)
	s[_idx] = *ptrFromHandle_codon_AminoAcid(_vl)
}

//export Slice_codon_AminoAcid_append
func Slice_codon_AminoAcid_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_codon_AminoAcid(handle)
	*s = append(*s, *ptrFromHandle_codon_AminoAcid(_vl))
}

// Converters for implicit pointer handles for type: []codon.Codon
func ptrFromHandle_Slice_codon_Codon(h CGoHandle) *[]codon.Codon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]codon.Codon")
	if p == nil {
		return nil
	}
	return p.(*[]codon.Codon)
}
func deptrFromHandle_Slice_codon_Codon(h CGoHandle) []codon.Codon {
	p := ptrFromHandle_Slice_codon_Codon(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_codon_Codon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]codon.Codon", p))
}

// --- wrapping slice: []codon.Codon ---
//
//export Slice_codon_Codon_CTor
func Slice_codon_Codon_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_codon_Codon(&[]codon.Codon{}))
}

//export Slice_codon_Codon_len
func Slice_codon_Codon_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_codon_Codon(handle))
}

//export Slice_codon_Codon_elem
func Slice_codon_Codon_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_codon_Codon(handle)
	return handleFromPtr_codon_Codon(&(s[_idx]))
}

//export Slice_codon_Codon_subslice
func Slice_codon_Codon_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_codon_Codon(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_codon_Codon(&ss))
}

//export Slice_codon_Codon_set
func Slice_codon_Codon_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_codon_Codon(handle)
	s[_idx] = *ptrFromHandle_codon_Codon(_vl)
}

//export Slice_codon_Codon_append
func Slice_codon_Codon_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_codon_Codon(handle)
	*s = append(*s, *ptrFromHandle_codon_Codon(_vl))
}

// Converters for non-pointer handles for type: codon.AminoAcid
func ptrFromHandle_codon_AminoAcid(h CGoHandle) *codon.AminoAcid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "codon.AminoAcid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.AminoAcid{})).(*codon.AminoAcid)
}
func handleFromPtr_codon_AminoAcid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("codon.AminoAcid", p))
}

// Converters for non-pointer handles for type: codon.Codon
func ptrFromHandle_codon_Codon(h CGoHandle) *codon.Codon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "codon.Codon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.Codon{})).(*codon.Codon)
}
func handleFromPtr_codon_Codon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("codon.Codon", p))
}

// Converters for non-pointer handles for type: codon.Stats
func ptrFromHandle_codon_Stats(h CGoHandle) *codon.Stats {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "codon.Stats")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.Stats{})).(*codon.Stats)
}
func handleFromPtr_codon_Stats(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("codon.Stats", p))
}

// Converters for pointer handles for type: codon.Table
func ptrFromHandle_codon_Table(h CGoHandle) codon.Table {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "codon.Table")
	if p == nil {
		return nil
	}
	return p.(codon.Table)
}
func handleFromPtr_codon_Table(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("codon.Table", p))
}

// Converters for non-pointer handles for type: codon.TranslationTable
func ptrFromHandle_codon_TranslationTable(h CGoHandle) *codon.TranslationTable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "codon.TranslationTable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable)
}
func handleFromPtr_codon_TranslationTable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("codon.TranslationTable", p))
}

// Converters for implicit pointer handles for type: map[string]weightedrand.Chooser
func ptrFromHandle_Map_string_weightedrand_Chooser(h CGoHandle) *map[string]weightedrand.Chooser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]weightedrand.Chooser")
	if p == nil {
		return nil
	}
	return p.(*map[string]weightedrand.Chooser)
}
func deptrFromHandle_Map_string_weightedrand_Chooser(h CGoHandle) map[string]weightedrand.Chooser {
	p := ptrFromHandle_Map_string_weightedrand_Chooser(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_weightedrand_Chooser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]weightedrand.Chooser", p))
}

// --- wrapping map: map[string]weightedrand.Chooser ---
//
//export Map_string_weightedrand_Chooser_CTor
func Map_string_weightedrand_Chooser_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_weightedrand_Chooser(&map[string]weightedrand.Chooser{}))
}

//export Map_string_weightedrand_Chooser_len
func Map_string_weightedrand_Chooser_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_weightedrand_Chooser(handle))
}

//export Map_string_weightedrand_Chooser_elem
func Map_string_weightedrand_Chooser_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_weightedrand_Chooser(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_weightedrand_Chooser(&v)
}

//export Map_string_weightedrand_Chooser_contains
func Map_string_weightedrand_Chooser_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_weightedrand_Chooser(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_weightedrand_Chooser_set
func Map_string_weightedrand_Chooser_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_weightedrand_Chooser(handle)
	s[C.GoString(_ky)] = *ptrFromHandle_weightedrand_Chooser(_vl)
}

//export Map_string_weightedrand_Chooser_delete
func Map_string_weightedrand_Chooser_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_weightedrand_Chooser(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_weightedrand_Chooser_keys
func Map_string_weightedrand_Chooser_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_weightedrand_Chooser(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export codon_Table_GetWeightedAminoAcids
func codon_Table_GetWeightedAminoAcids(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "codon.Table")
	if __err != nil {
		return handleFromPtr_Slice_codon_AminoAcid(nil)
	}
	cret := vifc.(codon.Table).GetWeightedAminoAcids()

	return handleFromPtr_Slice_codon_AminoAcid(&cret)
}

//export codon_Table_Optimize
func codon_Table_Optimize(_handle CGoHandle, aminoAcids *C.char, randomState CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "codon.Table")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := vifc.(codon.Table).Optimize(C.GoString(aminoAcids), deptrFromHandle_Slice_int(randomState)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export codon_Table_Translate
func codon_Table_Translate(_handle CGoHandle, dnaSeq *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "codon.Table")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := vifc.(codon.Table).Translate(C.GoString(dnaSeq))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// ---- Structs ---

// --- wrapping struct: codon.AminoAcid ---
//
//export codon_AminoAcid_CTor
func codon_AminoAcid_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_codon_AminoAcid(&codon.AminoAcid{}))
}

//export codon_AminoAcid_Letter_Get
func codon_AminoAcid_Letter_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_codon_AminoAcid(handle)
	return C.CString(op.Letter)
}

//export codon_AminoAcid_Letter_Set
func codon_AminoAcid_Letter_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_codon_AminoAcid(handle)
	op.Letter = C.GoString(val)
}

//export codon_AminoAcid_Codons_Get
func codon_AminoAcid_Codons_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_AminoAcid(handle)
	return handleFromPtr_Slice_codon_Codon(&op.Codons)
}

//export codon_AminoAcid_Codons_Set
func codon_AminoAcid_Codons_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_AminoAcid(handle)
	op.Codons = deptrFromHandle_Slice_codon_Codon(val)
}

// --- wrapping struct: codon.Codon ---
//
//export codon_Codon_CTor
func codon_Codon_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_codon_Codon(&codon.Codon{}))
}

//export codon_Codon_Triplet_Get
func codon_Codon_Triplet_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_codon_Codon(handle)
	return C.CString(op.Triplet)
}

//export codon_Codon_Triplet_Set
func codon_Codon_Triplet_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_codon_Codon(handle)
	op.Triplet = C.GoString(val)
}

//export codon_Codon_Weight_Get
func codon_Codon_Weight_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_codon_Codon(handle)
	return C.longlong(op.Weight)
}

//export codon_Codon_Weight_Set
func codon_Codon_Weight_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_codon_Codon(handle)
	op.Weight = int(val)
}

// --- wrapping struct: codon.Stats ---
//
//export codon_Stats_CTor
func codon_Stats_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_codon_Stats(&codon.Stats{}))
}

//export codon_Stats_StartCodonCount_Get
func codon_Stats_StartCodonCount_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_Stats(handle)
	return handleFromPtr_Map_string_int(&op.StartCodonCount)
}

//export codon_Stats_StartCodonCount_Set
func codon_Stats_StartCodonCount_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_Stats(handle)
	op.StartCodonCount = deptrFromHandle_Map_string_int(val)
}

//export codon_Stats_GeneCount_Get
func codon_Stats_GeneCount_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_codon_Stats(handle)
	return C.longlong(op.GeneCount)
}

//export codon_Stats_GeneCount_Set
func codon_Stats_GeneCount_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_codon_Stats(handle)
	op.GeneCount = int(val)
}

// --- wrapping struct: codon.TranslationTable ---
//
//export codon_TranslationTable_CTor
func codon_TranslationTable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_codon_TranslationTable(&codon.TranslationTable{}))
}

//export codon_TranslationTable_StartCodons_Get
func codon_TranslationTable_StartCodons_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Slice_string(&op.StartCodons)
}

//export codon_TranslationTable_StartCodons_Set
func codon_TranslationTable_StartCodons_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.StartCodons = deptrFromHandle_Slice_string(val)
}

//export codon_TranslationTable_StopCodons_Get
func codon_TranslationTable_StopCodons_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Slice_string(&op.StopCodons)
}

//export codon_TranslationTable_StopCodons_Set
func codon_TranslationTable_StopCodons_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.StopCodons = deptrFromHandle_Slice_string(val)
}

//export codon_TranslationTable_AminoAcids_Get
func codon_TranslationTable_AminoAcids_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Slice_codon_AminoAcid(&op.AminoAcids)
}

//export codon_TranslationTable_AminoAcids_Set
func codon_TranslationTable_AminoAcids_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.AminoAcids = deptrFromHandle_Slice_codon_AminoAcid(val)
}

//export codon_TranslationTable_TranslationMap_Get
func codon_TranslationTable_TranslationMap_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Map_string_string(&op.TranslationMap)
}

//export codon_TranslationTable_TranslationMap_Set
func codon_TranslationTable_TranslationMap_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.TranslationMap = deptrFromHandle_Map_string_string(val)
}

//export codon_TranslationTable_StartCodonTable_Get
func codon_TranslationTable_StartCodonTable_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Map_string_string(&op.StartCodonTable)
}

//export codon_TranslationTable_StartCodonTable_Set
func codon_TranslationTable_StartCodonTable_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.StartCodonTable = deptrFromHandle_Map_string_string(val)
}

//export codon_TranslationTable_Choosers_Get
func codon_TranslationTable_Choosers_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Map_string_weightedrand_Chooser(&op.Choosers)
}

//export codon_TranslationTable_Choosers_Set
func codon_TranslationTable_Choosers_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.Choosers = deptrFromHandle_Map_string_weightedrand_Chooser(val)
}

//export codon_TranslationTable_Stats_Get
func codon_TranslationTable_Stats_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_codon_TranslationTable(handle)
	return handleFromPtr_Ptr_codon_Stats(op.Stats)
}

//export codon_TranslationTable_Stats_Set
func codon_TranslationTable_Stats_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_codon_TranslationTable(handle)
	op.Stats = ptrFromHandle_Ptr_codon_Stats(val)
}

//export codon_TranslationTable_Copy
func codon_TranslationTable_Copy(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return handleFromPtr_Ptr_codon_TranslationTable(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).Copy()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_codon_TranslationTable(nil)
	}
	return handleFromPtr_Ptr_codon_TranslationTable(cret)
}

//export codon_TranslationTable_GetWeightedAminoAcids
func codon_TranslationTable_GetWeightedAminoAcids(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return handleFromPtr_Slice_codon_AminoAcid(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).GetWeightedAminoAcids()

	return handleFromPtr_Slice_codon_AminoAcid(&cret)
}

//export codon_TranslationTable_Optimize
func codon_TranslationTable_Optimize(_handle CGoHandle, aminoAcids *C.char, randomState CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).Optimize(C.GoString(aminoAcids), deptrFromHandle_Slice_int(randomState)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export codon_TranslationTable_UpdateWeights
func codon_TranslationTable_UpdateWeights(_handle CGoHandle, aminoAcids CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).UpdateWeights(deptrFromHandle_Slice_codon_AminoAcid(aminoAcids))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export codon_TranslationTable_UpdateWeightsWithSequence
func codon_TranslationTable_UpdateWeightsWithSequence(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).UpdateWeightsWithSequence(*ptrFromHandle_genbank_Genbank(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export codon_TranslationTable_Translate
func codon_TranslationTable_Translate(_handle CGoHandle, dnaSeq *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*codon.TranslationTable")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(codon.TranslationTable{})).(*codon.TranslationTable).Translate(C.GoString(dnaSeq))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export codon_NewStats
func codon_NewStats() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_codon_Stats(codon.NewStats())

}

//export codon_NewTranslationTable
func codon_NewTranslationTable(index C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := codon.NewTranslationTable(int(index))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_codon_TranslationTable(nil)
	}
	return handleFromPtr_Ptr_codon_TranslationTable(cret)
}

//export codon_ParseCodonJSON
func codon_ParseCodonJSON(file CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_codon_TranslationTable(codon.ParseCodonJSON(deptrFromHandle_Slice_byte(file)))

}

//export codon_ReadCodonJSON
func codon_ReadCodonJSON(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_codon_TranslationTable(codon.ReadCodonJSON(C.GoString(path)))

}

//export codon_AddCodonTable
func codon_AddCodonTable(firstCodonTable CGoHandle, secondCodonTable CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := codon.AddCodonTable(ptrFromHandle_Ptr_codon_TranslationTable(firstCodonTable), ptrFromHandle_Ptr_codon_TranslationTable(secondCodonTable))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_codon_TranslationTable(nil)
	}
	return handleFromPtr_Ptr_codon_TranslationTable(cret)
}

//export codon_CompromiseCodonTable
func codon_CompromiseCodonTable(firstCodonTable CGoHandle, secondCodonTable CGoHandle, cutOff C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := codon.CompromiseCodonTable(ptrFromHandle_Ptr_codon_TranslationTable(firstCodonTable), ptrFromHandle_Ptr_codon_TranslationTable(secondCodonTable), float64(cutOff))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_codon_TranslationTable(nil)
	}
	return handleFromPtr_Ptr_codon_TranslationTable(cret)
}

// ---- Functions ---

//export codon_WriteCodonJSON
func codon_WriteCodonJSON(codonTable CGoHandle, path *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go codon.WriteCodonJSON(ptrFromHandle_Ptr_codon_TranslationTable(codonTable), C.GoString(path))
	} else {
		codon.WriteCodonJSON(ptrFromHandle_Ptr_codon_TranslationTable(codonTable), C.GoString(path))
	}
}

// ---- Package: fix ---

// ---- Types ---

// Converters for pointer handles for type: *fix.Change
func ptrFromHandle_Ptr_fix_Change(h CGoHandle) *fix.Change {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fix.Change")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fix.Change{})).(*fix.Change)
}
func handleFromPtr_Ptr_fix_Change(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fix.Change", p))
}

// Converters for pointer handles for type: *fix.DnaSuggestion
func ptrFromHandle_Ptr_fix_DnaSuggestion(h CGoHandle) *fix.DnaSuggestion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fix.DnaSuggestion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fix.DnaSuggestion{})).(*fix.DnaSuggestion)
}
func handleFromPtr_Ptr_fix_DnaSuggestion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fix.DnaSuggestion", p))
}

// Converters for non-pointer handles for type: fix.Change
func ptrFromHandle_fix_Change(h CGoHandle) *fix.Change {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fix.Change")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fix.Change{})).(*fix.Change)
}
func handleFromPtr_fix_Change(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fix.Change", p))
}

// Converters for non-pointer handles for type: fix.DnaSuggestion
func ptrFromHandle_fix_DnaSuggestion(h CGoHandle) *fix.DnaSuggestion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fix.DnaSuggestion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fix.DnaSuggestion{})).(*fix.DnaSuggestion)
}
func handleFromPtr_fix_DnaSuggestion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fix.DnaSuggestion", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fix.Change ---
//
//export fix_Change_CTor
func fix_Change_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fix_Change(&fix.Change{}))
}

//export fix_Change_Position_Get
func fix_Change_Position_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_fix_Change(handle)
	return C.longlong(op.Position)
}

//export fix_Change_Position_Set
func fix_Change_Position_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_fix_Change(handle)
	op.Position = int(val)
}

//export fix_Change_Step_Get
func fix_Change_Step_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_fix_Change(handle)
	return C.longlong(op.Step)
}

//export fix_Change_Step_Set
func fix_Change_Step_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_fix_Change(handle)
	op.Step = int(val)
}

//export fix_Change_From_Get
func fix_Change_From_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fix_Change(handle)
	return C.CString(op.From)
}

//export fix_Change_From_Set
func fix_Change_From_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fix_Change(handle)
	op.From = C.GoString(val)
}

//export fix_Change_To_Get
func fix_Change_To_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fix_Change(handle)
	return C.CString(op.To)
}

//export fix_Change_To_Set
func fix_Change_To_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fix_Change(handle)
	op.To = C.GoString(val)
}

//export fix_Change_Reason_Get
func fix_Change_Reason_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fix_Change(handle)
	return C.CString(op.Reason)
}

//export fix_Change_Reason_Set
func fix_Change_Reason_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fix_Change(handle)
	op.Reason = C.GoString(val)
}

// --- wrapping struct: fix.DnaSuggestion ---
//
//export fix_DnaSuggestion_CTor
func fix_DnaSuggestion_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fix_DnaSuggestion(&fix.DnaSuggestion{}))
}

//export fix_DnaSuggestion_Start_Get
func fix_DnaSuggestion_Start_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	return C.longlong(op.Start)
}

//export fix_DnaSuggestion_Start_Set
func fix_DnaSuggestion_Start_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	op.Start = int(val)
}

//export fix_DnaSuggestion_End_Get
func fix_DnaSuggestion_End_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	return C.longlong(op.End)
}

//export fix_DnaSuggestion_End_Set
func fix_DnaSuggestion_End_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	op.End = int(val)
}

//export fix_DnaSuggestion_Bias_Get
func fix_DnaSuggestion_Bias_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	return C.CString(op.Bias)
}

//export fix_DnaSuggestion_Bias_Set
func fix_DnaSuggestion_Bias_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	op.Bias = C.GoString(val)
}

//export fix_DnaSuggestion_QuantityFixes_Get
func fix_DnaSuggestion_QuantityFixes_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	return C.longlong(op.QuantityFixes)
}

//export fix_DnaSuggestion_QuantityFixes_Set
func fix_DnaSuggestion_QuantityFixes_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	op.QuantityFixes = int(val)
}

//export fix_DnaSuggestion_SuggestionType_Get
func fix_DnaSuggestion_SuggestionType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	return C.CString(op.SuggestionType)
}

//export fix_DnaSuggestion_SuggestionType_Set
func fix_DnaSuggestion_SuggestionType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fix_DnaSuggestion(handle)
	op.SuggestionType = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: fragment ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export fragment_NextOverhang
func fragment_NextOverhang(currentOverhangs CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(fragment.NextOverhang(deptrFromHandle_Slice_string(currentOverhangs)))

}

//export fragment_SetEfficiency
func fragment_SetEfficiency(overhangs CGoHandle) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.double(fragment.SetEfficiency(deptrFromHandle_Slice_string(overhangs)))

}

// ---- Package: transform ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export transform_ComplementBaseRNA
func transform_ComplementBaseRNA(basePair C.long) C.long {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.long(transform.ComplementBaseRNA(rune(basePair)))

}

//export transform_ComplementRNA
func transform_ComplementRNA(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(transform.ComplementRNA(C.GoString(sequence)))

}

//export transform_Reverse
func transform_Reverse(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(transform.Reverse(C.GoString(sequence)))

}

//export transform_ReverseComplement
func transform_ReverseComplement(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(transform.ReverseComplement(C.GoString(sequence)))

}

//export transform_ReverseComplementRNA
func transform_ReverseComplementRNA(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(transform.ReverseComplementRNA(C.GoString(sequence)))

}

//export transform_Complement
func transform_Complement(sequence *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(transform.Complement(C.GoString(sequence)))

}

//export transform_ComplementBase
func transform_ComplementBase(basePair C.long) C.long {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.long(transform.ComplementBase(rune(basePair)))

}

// ---- Package: variants ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export variants_AllVariantsIUPAC
func variants_AllVariantsIUPAC(seq *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := variants.AllVariantsIUPAC(C.GoString(seq))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}
