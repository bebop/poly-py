/*
cgo stubs for package uniprot.
File is generated by gopy. Do not edit.
gopy build -output=poly/io/uniprot -vm=python3 github.com/bebop/poly/io/uniprot
*/

package main

/*

#cgo CFLAGS: "-I/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/lib" "-lpython3.13" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"encoding/xml"
	"time"

	"github.com/bebop/poly/io/uniprot"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: uniprot below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *xml.Decoder
func ptrFromHandle_Ptr_xml_Decoder(h CGoHandle) *xml.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*xml.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Decoder{})).(*xml.Decoder)
}
func handleFromPtr_Ptr_xml_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*xml.Decoder", p))
}

// Converters for pointer handles for type: *xml.StartElement
func ptrFromHandle_Ptr_xml_StartElement(h CGoHandle) *xml.StartElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*xml.StartElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.StartElement{})).(*xml.StartElement)
}
func handleFromPtr_Ptr_xml_StartElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*xml.StartElement", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for non-pointer handles for type: xml.Attr
func ptrFromHandle_xml_Attr(h CGoHandle) *xml.Attr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Attr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Attr{})).(*xml.Attr)
}
func handleFromPtr_xml_Attr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Attr", p))
}

// Converters for non-pointer handles for type: xml.Decoder
func ptrFromHandle_xml_Decoder(h CGoHandle) *xml.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Decoder{})).(*xml.Decoder)
}
func handleFromPtr_xml_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Decoder", p))
}

// Converters for non-pointer handles for type: xml.EndElement
func ptrFromHandle_xml_EndElement(h CGoHandle) *xml.EndElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.EndElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.EndElement{})).(*xml.EndElement)
}
func handleFromPtr_xml_EndElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.EndElement", p))
}

// Converters for non-pointer handles for type: xml.Name
func ptrFromHandle_xml_Name(h CGoHandle) *xml.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.Name{})).(*xml.Name)
}
func handleFromPtr_xml_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Name", p))
}

// Converters for non-pointer handles for type: xml.StartElement
func ptrFromHandle_xml_StartElement(h CGoHandle) *xml.StartElement {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.StartElement")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(xml.StartElement{})).(*xml.StartElement)
}
func handleFromPtr_xml_StartElement(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.StartElement", p))
}

// Converters for pointer handles for type: xml.Token
func ptrFromHandle_xml_Token(h CGoHandle) xml.Token {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "xml.Token")
	if p == nil {
		return nil
	}
	return p.(xml.Token)
}
func handleFromPtr_xml_Token(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("xml.Token", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: uniprot ---

// ---- Types ---

// Converters for pointer handles for type: *uniprot.Absorption
func ptrFromHandle_Ptr_uniprot_Absorption(h CGoHandle) *uniprot.Absorption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Absorption")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Absorption{})).(*uniprot.Absorption)
}
func handleFromPtr_Ptr_uniprot_Absorption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Absorption", p))
}

// Converters for pointer handles for type: *uniprot.AlternativeName
func ptrFromHandle_Ptr_uniprot_AlternativeName(h CGoHandle) *uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.AlternativeName{})).(*uniprot.AlternativeName)
}
func handleFromPtr_Ptr_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.AlternativeName", p))
}

// Converters for pointer handles for type: *uniprot.Anon6
func ptrFromHandle_Ptr_uniprot_Anon6(h CGoHandle) *uniprot.Anon6 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Anon6")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Anon6{})).(*uniprot.Anon6)
}
func handleFromPtr_Ptr_uniprot_Anon6(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Anon6", p))
}

// Converters for pointer handles for type: *uniprot.CitationType
func ptrFromHandle_Ptr_uniprot_CitationType(h CGoHandle) *uniprot.CitationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CitationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CitationType{})).(*uniprot.CitationType)
}
func handleFromPtr_Ptr_uniprot_CitationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CitationType", p))
}

// Converters for pointer handles for type: *uniprot.CofactorType
func ptrFromHandle_Ptr_uniprot_CofactorType(h CGoHandle) *uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CofactorType{})).(*uniprot.CofactorType)
}
func handleFromPtr_Ptr_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CofactorType", p))
}

// Converters for pointer handles for type: *uniprot.CommentType
func ptrFromHandle_Ptr_uniprot_CommentType(h CGoHandle) *uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.CommentType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType)
}
func handleFromPtr_Ptr_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.CommentType", p))
}

// Converters for pointer handles for type: *uniprot.Component
func ptrFromHandle_Ptr_uniprot_Component(h CGoHandle) *uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Component")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Component{})).(*uniprot.Component)
}
func handleFromPtr_Ptr_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Component", p))
}

// Converters for pointer handles for type: *uniprot.Conflict
func ptrFromHandle_Ptr_uniprot_Conflict(h CGoHandle) *uniprot.Conflict {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Conflict")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Conflict{})).(*uniprot.Conflict)
}
func handleFromPtr_Ptr_uniprot_Conflict(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Conflict", p))
}

// Converters for pointer handles for type: *uniprot.ConsortiumType
func ptrFromHandle_Ptr_uniprot_ConsortiumType(h CGoHandle) *uniprot.ConsortiumType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ConsortiumType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ConsortiumType{})).(*uniprot.ConsortiumType)
}
func handleFromPtr_Ptr_uniprot_ConsortiumType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ConsortiumType", p))
}

// Converters for pointer handles for type: *uniprot.DbReferenceType
func ptrFromHandle_Ptr_uniprot_DbReferenceType(h CGoHandle) *uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.DbReferenceType{})).(*uniprot.DbReferenceType)
}
func handleFromPtr_Ptr_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.DbReferenceType", p))
}

// Converters for pointer handles for type: *uniprot.Disease
func ptrFromHandle_Ptr_uniprot_Disease(h CGoHandle) *uniprot.Disease {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Disease")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Disease{})).(*uniprot.Disease)
}
func handleFromPtr_Ptr_uniprot_Disease(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Disease", p))
}

// Converters for pointer handles for type: *uniprot.Domain
func ptrFromHandle_Ptr_uniprot_Domain(h CGoHandle) *uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Domain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Domain{})).(*uniprot.Domain)
}
func handleFromPtr_Ptr_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Domain", p))
}

// Converters for pointer handles for type: *uniprot.Entry
func ptrFromHandle_Ptr_uniprot_Entry(h CGoHandle) *uniprot.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry)
}
func handleFromPtr_Ptr_uniprot_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Entry", p))
}

// Converters for pointer handles for type: *uniprot.EventType
func ptrFromHandle_Ptr_uniprot_EventType(h CGoHandle) *uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EventType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EventType{})).(*uniprot.EventType)
}
func handleFromPtr_Ptr_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EventType", p))
}

// Converters for pointer handles for type: *uniprot.EvidenceType
func ptrFromHandle_Ptr_uniprot_EvidenceType(h CGoHandle) *uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidenceType{})).(*uniprot.EvidenceType)
}
func handleFromPtr_Ptr_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EvidenceType", p))
}

// Converters for pointer handles for type: *uniprot.EvidencedStringType
func ptrFromHandle_Ptr_uniprot_EvidencedStringType(h CGoHandle) *uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidencedStringType{})).(*uniprot.EvidencedStringType)
}
func handleFromPtr_Ptr_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.EvidencedStringType", p))
}

// Converters for pointer handles for type: *uniprot.FeatureType
func ptrFromHandle_Ptr_uniprot_FeatureType(h CGoHandle) *uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.FeatureType{})).(*uniprot.FeatureType)
}
func handleFromPtr_Ptr_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.FeatureType", p))
}

// Converters for pointer handles for type: *uniprot.GeneLocationType
func ptrFromHandle_Ptr_uniprot_GeneLocationType(h CGoHandle) *uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneLocationType{})).(*uniprot.GeneLocationType)
}
func handleFromPtr_Ptr_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneLocationType", p))
}

// Converters for pointer handles for type: *uniprot.GeneNameType
func ptrFromHandle_Ptr_uniprot_GeneNameType(h CGoHandle) *uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneNameType{})).(*uniprot.GeneNameType)
}
func handleFromPtr_Ptr_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneNameType", p))
}

// Converters for pointer handles for type: *uniprot.GeneType
func ptrFromHandle_Ptr_uniprot_GeneType(h CGoHandle) *uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.GeneType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneType{})).(*uniprot.GeneType)
}
func handleFromPtr_Ptr_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.GeneType", p))
}

// Converters for pointer handles for type: *uniprot.ImportedFromType
func ptrFromHandle_Ptr_uniprot_ImportedFromType(h CGoHandle) *uniprot.ImportedFromType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ImportedFromType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ImportedFromType{})).(*uniprot.ImportedFromType)
}
func handleFromPtr_Ptr_uniprot_ImportedFromType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ImportedFromType", p))
}

// Converters for pointer handles for type: *uniprot.IntListType
func ptrFromHandle_Ptr_uniprot_IntListType(h CGoHandle) *uniprot.IntListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.IntListType")
	if p == nil {
		return nil
	}
	return p.(*uniprot.IntListType)
}
func handleFromPtr_Ptr_uniprot_IntListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.IntListType", p))
}

// Converters for pointer handles for type: *uniprot.InteractantType
func ptrFromHandle_Ptr_uniprot_InteractantType(h CGoHandle) *uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.InteractantType{})).(*uniprot.InteractantType)
}
func handleFromPtr_Ptr_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.InteractantType", p))
}

// Converters for pointer handles for type: *uniprot.IsoformType
func ptrFromHandle_Ptr_uniprot_IsoformType(h CGoHandle) *uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.IsoformType{})).(*uniprot.IsoformType)
}
func handleFromPtr_Ptr_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.IsoformType", p))
}

// Converters for pointer handles for type: *uniprot.KeywordType
func ptrFromHandle_Ptr_uniprot_KeywordType(h CGoHandle) *uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.KeywordType{})).(*uniprot.KeywordType)
}
func handleFromPtr_Ptr_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.KeywordType", p))
}

// Converters for pointer handles for type: *uniprot.Kinetics
func ptrFromHandle_Ptr_uniprot_Kinetics(h CGoHandle) *uniprot.Kinetics {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Kinetics")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Kinetics{})).(*uniprot.Kinetics)
}
func handleFromPtr_Ptr_uniprot_Kinetics(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Kinetics", p))
}

// Converters for pointer handles for type: *uniprot.Lineage
func ptrFromHandle_Ptr_uniprot_Lineage(h CGoHandle) *uniprot.Lineage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Lineage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Lineage{})).(*uniprot.Lineage)
}
func handleFromPtr_Ptr_uniprot_Lineage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Lineage", p))
}

// Converters for pointer handles for type: *uniprot.Link
func ptrFromHandle_Ptr_uniprot_Link(h CGoHandle) *uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Link")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Link{})).(*uniprot.Link)
}
func handleFromPtr_Ptr_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Link", p))
}

// Converters for pointer handles for type: *uniprot.LocationType
func ptrFromHandle_Ptr_uniprot_LocationType(h CGoHandle) *uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.LocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.LocationType{})).(*uniprot.LocationType)
}
func handleFromPtr_Ptr_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.LocationType", p))
}

// Converters for pointer handles for type: *uniprot.Name
func ptrFromHandle_Ptr_uniprot_Name(h CGoHandle) *uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Name{})).(*uniprot.Name)
}
func handleFromPtr_Ptr_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Name", p))
}

// Converters for pointer handles for type: *uniprot.NameListType
func ptrFromHandle_Ptr_uniprot_NameListType(h CGoHandle) *uniprot.NameListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.NameListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.NameListType{})).(*uniprot.NameListType)
}
func handleFromPtr_Ptr_uniprot_NameListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.NameListType", p))
}

// Converters for pointer handles for type: *uniprot.OrganismNameType
func ptrFromHandle_Ptr_uniprot_OrganismNameType(h CGoHandle) *uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismNameType{})).(*uniprot.OrganismNameType)
}
func handleFromPtr_Ptr_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.OrganismNameType", p))
}

// Converters for pointer handles for type: *uniprot.OrganismType
func ptrFromHandle_Ptr_uniprot_OrganismType(h CGoHandle) *uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismType{})).(*uniprot.OrganismType)
}
func handleFromPtr_Ptr_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.OrganismType", p))
}

// Converters for pointer handles for type: *uniprot.PersonType
func ptrFromHandle_Ptr_uniprot_PersonType(h CGoHandle) *uniprot.PersonType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PersonType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PersonType{})).(*uniprot.PersonType)
}
func handleFromPtr_Ptr_uniprot_PersonType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PersonType", p))
}

// Converters for pointer handles for type: *uniprot.PhDependence
func ptrFromHandle_Ptr_uniprot_PhDependence(h CGoHandle) *uniprot.PhDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PhDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhDependence{})).(*uniprot.PhDependence)
}
func handleFromPtr_Ptr_uniprot_PhDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PhDependence", p))
}

// Converters for pointer handles for type: *uniprot.PhysiologicalReactionType
func ptrFromHandle_Ptr_uniprot_PhysiologicalReactionType(h CGoHandle) *uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhysiologicalReactionType{})).(*uniprot.PhysiologicalReactionType)
}
func handleFromPtr_Ptr_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PhysiologicalReactionType", p))
}

// Converters for pointer handles for type: *uniprot.Plasmid
func ptrFromHandle_Ptr_uniprot_Plasmid(h CGoHandle) *uniprot.Plasmid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Plasmid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Plasmid{})).(*uniprot.Plasmid)
}
func handleFromPtr_Ptr_uniprot_Plasmid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Plasmid", p))
}

// Converters for pointer handles for type: *uniprot.PositionType
func ptrFromHandle_Ptr_uniprot_PositionType(h CGoHandle) *uniprot.PositionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PositionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType)
}
func handleFromPtr_Ptr_uniprot_PositionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PositionType", p))
}

// Converters for pointer handles for type: *uniprot.PropertyType
func ptrFromHandle_Ptr_uniprot_PropertyType(h CGoHandle) *uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PropertyType{})).(*uniprot.PropertyType)
}
func handleFromPtr_Ptr_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.PropertyType", p))
}

// Converters for pointer handles for type: *uniprot.ProteinExistenceType
func ptrFromHandle_Ptr_uniprot_ProteinExistenceType(h CGoHandle) *uniprot.ProteinExistenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ProteinExistenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinExistenceType{})).(*uniprot.ProteinExistenceType)
}
func handleFromPtr_Ptr_uniprot_ProteinExistenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ProteinExistenceType", p))
}

// Converters for pointer handles for type: *uniprot.ProteinType
func ptrFromHandle_Ptr_uniprot_ProteinType(h CGoHandle) *uniprot.ProteinType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ProteinType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinType{})).(*uniprot.ProteinType)
}
func handleFromPtr_Ptr_uniprot_ProteinType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ProteinType", p))
}

// Converters for pointer handles for type: *uniprot.ReactionType
func ptrFromHandle_Ptr_uniprot_ReactionType(h CGoHandle) *uniprot.ReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReactionType{})).(*uniprot.ReactionType)
}
func handleFromPtr_Ptr_uniprot_ReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ReactionType", p))
}

// Converters for pointer handles for type: *uniprot.RecommendedName
func ptrFromHandle_Ptr_uniprot_RecommendedName(h CGoHandle) *uniprot.RecommendedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.RecommendedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RecommendedName{})).(*uniprot.RecommendedName)
}
func handleFromPtr_Ptr_uniprot_RecommendedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.RecommendedName", p))
}

// Converters for pointer handles for type: *uniprot.RedoxPotential
func ptrFromHandle_Ptr_uniprot_RedoxPotential(h CGoHandle) *uniprot.RedoxPotential {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.RedoxPotential")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RedoxPotential{})).(*uniprot.RedoxPotential)
}
func handleFromPtr_Ptr_uniprot_RedoxPotential(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.RedoxPotential", p))
}

// Converters for pointer handles for type: *uniprot.ReferenceType
func ptrFromHandle_Ptr_uniprot_ReferenceType(h CGoHandle) *uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReferenceType{})).(*uniprot.ReferenceType)
}
func handleFromPtr_Ptr_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.ReferenceType", p))
}

// Converters for pointer handles for type: *uniprot.Sequence
func ptrFromHandle_Ptr_uniprot_Sequence(h CGoHandle) *uniprot.Sequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Sequence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Sequence{})).(*uniprot.Sequence)
}
func handleFromPtr_Ptr_uniprot_Sequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Sequence", p))
}

// Converters for pointer handles for type: *uniprot.SequenceType
func ptrFromHandle_Ptr_uniprot_SequenceType(h CGoHandle) *uniprot.SequenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SequenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType)
}
func handleFromPtr_Ptr_uniprot_SequenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SequenceType", p))
}

// Converters for pointer handles for type: *uniprot.SourceDataType
func ptrFromHandle_Ptr_uniprot_SourceDataType(h CGoHandle) *uniprot.SourceDataType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SourceDataType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceDataType{})).(*uniprot.SourceDataType)
}
func handleFromPtr_Ptr_uniprot_SourceDataType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SourceDataType", p))
}

// Converters for pointer handles for type: *uniprot.SourceType
func ptrFromHandle_Ptr_uniprot_SourceType(h CGoHandle) *uniprot.SourceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SourceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceType{})).(*uniprot.SourceType)
}
func handleFromPtr_Ptr_uniprot_SourceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SourceType", p))
}

// Converters for pointer handles for type: *uniprot.StatusType
func ptrFromHandle_Ptr_uniprot_StatusType(h CGoHandle) *uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.StatusType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.StatusType{})).(*uniprot.StatusType)
}
func handleFromPtr_Ptr_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.StatusType", p))
}

// Converters for pointer handles for type: *uniprot.Strain
func ptrFromHandle_Ptr_uniprot_Strain(h CGoHandle) *uniprot.Strain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Strain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Strain{})).(*uniprot.Strain)
}
func handleFromPtr_Ptr_uniprot_Strain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Strain", p))
}

// Converters for pointer handles for type: *uniprot.SubcellularLocationType
func ptrFromHandle_Ptr_uniprot_SubcellularLocationType(h CGoHandle) *uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubcellularLocationType{})).(*uniprot.SubcellularLocationType)
}
func handleFromPtr_Ptr_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SubcellularLocationType", p))
}

// Converters for pointer handles for type: *uniprot.SubmittedName
func ptrFromHandle_Ptr_uniprot_SubmittedName(h CGoHandle) *uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubmittedName{})).(*uniprot.SubmittedName)
}
func handleFromPtr_Ptr_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.SubmittedName", p))
}

// Converters for pointer handles for type: *uniprot.TemperatureDependence
func ptrFromHandle_Ptr_uniprot_TemperatureDependence(h CGoHandle) *uniprot.TemperatureDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.TemperatureDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.TemperatureDependence{})).(*uniprot.TemperatureDependence)
}
func handleFromPtr_Ptr_uniprot_TemperatureDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.TemperatureDependence", p))
}

// Converters for pointer handles for type: *uniprot.Tissue
func ptrFromHandle_Ptr_uniprot_Tissue(h CGoHandle) *uniprot.Tissue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Tissue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Tissue{})).(*uniprot.Tissue)
}
func handleFromPtr_Ptr_uniprot_Tissue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Tissue", p))
}

// Converters for pointer handles for type: *uniprot.Transposon
func ptrFromHandle_Ptr_uniprot_Transposon(h CGoHandle) *uniprot.Transposon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Transposon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Transposon{})).(*uniprot.Transposon)
}
func handleFromPtr_Ptr_uniprot_Transposon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Transposon", p))
}

// Converters for pointer handles for type: *uniprot.Uniprot
func ptrFromHandle_Ptr_uniprot_Uniprot(h CGoHandle) *uniprot.Uniprot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*uniprot.Uniprot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Uniprot{})).(*uniprot.Uniprot)
}
func handleFromPtr_Ptr_uniprot_Uniprot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*uniprot.Uniprot", p))
}

// Converters for implicit pointer handles for type: []xml.Attr
func ptrFromHandle_Slice_xml_Attr(h CGoHandle) *[]xml.Attr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]xml.Attr")
	if p == nil {
		return nil
	}
	return p.(*[]xml.Attr)
}
func deptrFromHandle_Slice_xml_Attr(h CGoHandle) []xml.Attr {
	p := ptrFromHandle_Slice_xml_Attr(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_xml_Attr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]xml.Attr", p))
}

// --- wrapping slice: []xml.Attr ---
//
//export Slice_xml_Attr_CTor
func Slice_xml_Attr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_xml_Attr(&[]xml.Attr{}))
}

//export Slice_xml_Attr_len
func Slice_xml_Attr_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_xml_Attr(handle))
}

//export Slice_xml_Attr_elem
func Slice_xml_Attr_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	return handleFromPtr_xml_Attr(&(s[_idx]))
}

//export Slice_xml_Attr_subslice
func Slice_xml_Attr_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_xml_Attr(&ss))
}

//export Slice_xml_Attr_set
func Slice_xml_Attr_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_xml_Attr(handle)
	s[_idx] = *ptrFromHandle_xml_Attr(_vl)
}

//export Slice_xml_Attr_append
func Slice_xml_Attr_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_xml_Attr(handle)
	*s = append(*s, *ptrFromHandle_xml_Attr(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.AlternativeName
func ptrFromHandle_Slice_uniprot_AlternativeName(h CGoHandle) *[]uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.AlternativeName)
}
func deptrFromHandle_Slice_uniprot_AlternativeName(h CGoHandle) []uniprot.AlternativeName {
	p := ptrFromHandle_Slice_uniprot_AlternativeName(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.AlternativeName", p))
}

// --- wrapping slice: []uniprot.AlternativeName ---
//
//export Slice_uniprot_AlternativeName_CTor
func Slice_uniprot_AlternativeName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_AlternativeName(&[]uniprot.AlternativeName{}))
}

//export Slice_uniprot_AlternativeName_len
func Slice_uniprot_AlternativeName_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_AlternativeName(handle))
}

//export Slice_uniprot_AlternativeName_elem
func Slice_uniprot_AlternativeName_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	return handleFromPtr_uniprot_AlternativeName(&(s[_idx]))
}

//export Slice_uniprot_AlternativeName_subslice
func Slice_uniprot_AlternativeName_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_AlternativeName(&ss))
}

//export Slice_uniprot_AlternativeName_set
func Slice_uniprot_AlternativeName_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_AlternativeName(handle)
	s[_idx] = *ptrFromHandle_uniprot_AlternativeName(_vl)
}

//export Slice_uniprot_AlternativeName_append
func Slice_uniprot_AlternativeName_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_AlternativeName(handle)
	*s = append(*s, *ptrFromHandle_uniprot_AlternativeName(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.CofactorType
func ptrFromHandle_Slice_uniprot_CofactorType(h CGoHandle) *[]uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.CofactorType)
}
func deptrFromHandle_Slice_uniprot_CofactorType(h CGoHandle) []uniprot.CofactorType {
	p := ptrFromHandle_Slice_uniprot_CofactorType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.CofactorType", p))
}

// --- wrapping slice: []uniprot.CofactorType ---
//
//export Slice_uniprot_CofactorType_CTor
func Slice_uniprot_CofactorType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_CofactorType(&[]uniprot.CofactorType{}))
}

//export Slice_uniprot_CofactorType_len
func Slice_uniprot_CofactorType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_CofactorType(handle))
}

//export Slice_uniprot_CofactorType_elem
func Slice_uniprot_CofactorType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_CofactorType(&(s[_idx]))
}

//export Slice_uniprot_CofactorType_subslice
func Slice_uniprot_CofactorType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_CofactorType(&ss))
}

//export Slice_uniprot_CofactorType_set
func Slice_uniprot_CofactorType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_CofactorType(handle)
	s[_idx] = *ptrFromHandle_uniprot_CofactorType(_vl)
}

//export Slice_uniprot_CofactorType_append
func Slice_uniprot_CofactorType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_CofactorType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_CofactorType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.CommentType
func ptrFromHandle_Slice_uniprot_CommentType(h CGoHandle) *[]uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.CommentType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.CommentType)
}
func deptrFromHandle_Slice_uniprot_CommentType(h CGoHandle) []uniprot.CommentType {
	p := ptrFromHandle_Slice_uniprot_CommentType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.CommentType", p))
}

// --- wrapping slice: []uniprot.CommentType ---
//
//export Slice_uniprot_CommentType_CTor
func Slice_uniprot_CommentType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_CommentType(&[]uniprot.CommentType{}))
}

//export Slice_uniprot_CommentType_len
func Slice_uniprot_CommentType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_CommentType(handle))
}

//export Slice_uniprot_CommentType_elem
func Slice_uniprot_CommentType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_CommentType(&(s[_idx]))
}

//export Slice_uniprot_CommentType_subslice
func Slice_uniprot_CommentType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_CommentType(&ss))
}

//export Slice_uniprot_CommentType_set
func Slice_uniprot_CommentType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_CommentType(handle)
	s[_idx] = *ptrFromHandle_uniprot_CommentType(_vl)
}

//export Slice_uniprot_CommentType_append
func Slice_uniprot_CommentType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_CommentType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_CommentType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Component
func ptrFromHandle_Slice_uniprot_Component(h CGoHandle) *[]uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Component")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Component)
}
func deptrFromHandle_Slice_uniprot_Component(h CGoHandle) []uniprot.Component {
	p := ptrFromHandle_Slice_uniprot_Component(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Component", p))
}

// --- wrapping slice: []uniprot.Component ---
//
//export Slice_uniprot_Component_CTor
func Slice_uniprot_Component_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Component(&[]uniprot.Component{}))
}

//export Slice_uniprot_Component_len
func Slice_uniprot_Component_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Component(handle))
}

//export Slice_uniprot_Component_elem
func Slice_uniprot_Component_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	return handleFromPtr_uniprot_Component(&(s[_idx]))
}

//export Slice_uniprot_Component_subslice
func Slice_uniprot_Component_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Component(&ss))
}

//export Slice_uniprot_Component_set
func Slice_uniprot_Component_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Component(handle)
	s[_idx] = *ptrFromHandle_uniprot_Component(_vl)
}

//export Slice_uniprot_Component_append
func Slice_uniprot_Component_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Component(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Component(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.DbReferenceType
func ptrFromHandle_Slice_uniprot_DbReferenceType(h CGoHandle) *[]uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.DbReferenceType)
}
func deptrFromHandle_Slice_uniprot_DbReferenceType(h CGoHandle) []uniprot.DbReferenceType {
	p := ptrFromHandle_Slice_uniprot_DbReferenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.DbReferenceType", p))
}

// --- wrapping slice: []uniprot.DbReferenceType ---
//
//export Slice_uniprot_DbReferenceType_CTor
func Slice_uniprot_DbReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_DbReferenceType(&[]uniprot.DbReferenceType{}))
}

//export Slice_uniprot_DbReferenceType_len
func Slice_uniprot_DbReferenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_DbReferenceType(handle))
}

//export Slice_uniprot_DbReferenceType_elem
func Slice_uniprot_DbReferenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&(s[_idx]))
}

//export Slice_uniprot_DbReferenceType_subslice
func Slice_uniprot_DbReferenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_DbReferenceType(&ss))
}

//export Slice_uniprot_DbReferenceType_set
func Slice_uniprot_DbReferenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_DbReferenceType(_vl)
}

//export Slice_uniprot_DbReferenceType_append
func Slice_uniprot_DbReferenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_DbReferenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_DbReferenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Domain
func ptrFromHandle_Slice_uniprot_Domain(h CGoHandle) *[]uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Domain")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Domain)
}
func deptrFromHandle_Slice_uniprot_Domain(h CGoHandle) []uniprot.Domain {
	p := ptrFromHandle_Slice_uniprot_Domain(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Domain", p))
}

// --- wrapping slice: []uniprot.Domain ---
//
//export Slice_uniprot_Domain_CTor
func Slice_uniprot_Domain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Domain(&[]uniprot.Domain{}))
}

//export Slice_uniprot_Domain_len
func Slice_uniprot_Domain_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Domain(handle))
}

//export Slice_uniprot_Domain_elem
func Slice_uniprot_Domain_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	return handleFromPtr_uniprot_Domain(&(s[_idx]))
}

//export Slice_uniprot_Domain_subslice
func Slice_uniprot_Domain_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Domain(&ss))
}

//export Slice_uniprot_Domain_set
func Slice_uniprot_Domain_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Domain(handle)
	s[_idx] = *ptrFromHandle_uniprot_Domain(_vl)
}

//export Slice_uniprot_Domain_append
func Slice_uniprot_Domain_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Domain(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Domain(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EventType
func ptrFromHandle_Slice_uniprot_EventType(h CGoHandle) *[]uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EventType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EventType)
}
func deptrFromHandle_Slice_uniprot_EventType(h CGoHandle) []uniprot.EventType {
	p := ptrFromHandle_Slice_uniprot_EventType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EventType", p))
}

// --- wrapping slice: []uniprot.EventType ---
//
//export Slice_uniprot_EventType_CTor
func Slice_uniprot_EventType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EventType(&[]uniprot.EventType{}))
}

//export Slice_uniprot_EventType_len
func Slice_uniprot_EventType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EventType(handle))
}

//export Slice_uniprot_EventType_elem
func Slice_uniprot_EventType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	return handleFromPtr_uniprot_EventType(&(s[_idx]))
}

//export Slice_uniprot_EventType_subslice
func Slice_uniprot_EventType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EventType(&ss))
}

//export Slice_uniprot_EventType_set
func Slice_uniprot_EventType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EventType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EventType(_vl)
}

//export Slice_uniprot_EventType_append
func Slice_uniprot_EventType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EventType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EventType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EvidenceType
func ptrFromHandle_Slice_uniprot_EvidenceType(h CGoHandle) *[]uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EvidenceType)
}
func deptrFromHandle_Slice_uniprot_EvidenceType(h CGoHandle) []uniprot.EvidenceType {
	p := ptrFromHandle_Slice_uniprot_EvidenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EvidenceType", p))
}

// --- wrapping slice: []uniprot.EvidenceType ---
//
//export Slice_uniprot_EvidenceType_CTor
func Slice_uniprot_EvidenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidenceType(&[]uniprot.EvidenceType{}))
}

//export Slice_uniprot_EvidenceType_len
func Slice_uniprot_EvidenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EvidenceType(handle))
}

//export Slice_uniprot_EvidenceType_elem
func Slice_uniprot_EvidenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_EvidenceType(&(s[_idx]))
}

//export Slice_uniprot_EvidenceType_subslice
func Slice_uniprot_EvidenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidenceType(&ss))
}

//export Slice_uniprot_EvidenceType_set
func Slice_uniprot_EvidenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EvidenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EvidenceType(_vl)
}

//export Slice_uniprot_EvidenceType_append
func Slice_uniprot_EvidenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EvidenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EvidenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.EvidencedStringType
func ptrFromHandle_Slice_uniprot_EvidencedStringType(h CGoHandle) *[]uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.EvidencedStringType)
}
func deptrFromHandle_Slice_uniprot_EvidencedStringType(h CGoHandle) []uniprot.EvidencedStringType {
	p := ptrFromHandle_Slice_uniprot_EvidencedStringType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.EvidencedStringType", p))
}

// --- wrapping slice: []uniprot.EvidencedStringType ---
//
//export Slice_uniprot_EvidencedStringType_CTor
func Slice_uniprot_EvidencedStringType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidencedStringType(&[]uniprot.EvidencedStringType{}))
}

//export Slice_uniprot_EvidencedStringType_len
func Slice_uniprot_EvidencedStringType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_EvidencedStringType(handle))
}

//export Slice_uniprot_EvidencedStringType_elem
func Slice_uniprot_EvidencedStringType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&(s[_idx]))
}

//export Slice_uniprot_EvidencedStringType_subslice
func Slice_uniprot_EvidencedStringType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_EvidencedStringType(&ss))
}

//export Slice_uniprot_EvidencedStringType_set
func Slice_uniprot_EvidencedStringType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	s[_idx] = *ptrFromHandle_uniprot_EvidencedStringType(_vl)
}

//export Slice_uniprot_EvidencedStringType_append
func Slice_uniprot_EvidencedStringType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_EvidencedStringType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_EvidencedStringType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.FeatureType
func ptrFromHandle_Slice_uniprot_FeatureType(h CGoHandle) *[]uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.FeatureType)
}
func deptrFromHandle_Slice_uniprot_FeatureType(h CGoHandle) []uniprot.FeatureType {
	p := ptrFromHandle_Slice_uniprot_FeatureType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.FeatureType", p))
}

// --- wrapping slice: []uniprot.FeatureType ---
//
//export Slice_uniprot_FeatureType_CTor
func Slice_uniprot_FeatureType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_FeatureType(&[]uniprot.FeatureType{}))
}

//export Slice_uniprot_FeatureType_len
func Slice_uniprot_FeatureType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_FeatureType(handle))
}

//export Slice_uniprot_FeatureType_elem
func Slice_uniprot_FeatureType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_FeatureType(&(s[_idx]))
}

//export Slice_uniprot_FeatureType_subslice
func Slice_uniprot_FeatureType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_FeatureType(&ss))
}

//export Slice_uniprot_FeatureType_set
func Slice_uniprot_FeatureType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_FeatureType(handle)
	s[_idx] = *ptrFromHandle_uniprot_FeatureType(_vl)
}

//export Slice_uniprot_FeatureType_append
func Slice_uniprot_FeatureType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_FeatureType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_FeatureType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneLocationType
func ptrFromHandle_Slice_uniprot_GeneLocationType(h CGoHandle) *[]uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneLocationType)
}
func deptrFromHandle_Slice_uniprot_GeneLocationType(h CGoHandle) []uniprot.GeneLocationType {
	p := ptrFromHandle_Slice_uniprot_GeneLocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneLocationType", p))
}

// --- wrapping slice: []uniprot.GeneLocationType ---
//
//export Slice_uniprot_GeneLocationType_CTor
func Slice_uniprot_GeneLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneLocationType(&[]uniprot.GeneLocationType{}))
}

//export Slice_uniprot_GeneLocationType_len
func Slice_uniprot_GeneLocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneLocationType(handle))
}

//export Slice_uniprot_GeneLocationType_elem
func Slice_uniprot_GeneLocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	return handleFromPtr_uniprot_GeneLocationType(&(s[_idx]))
}

//export Slice_uniprot_GeneLocationType_subslice
func Slice_uniprot_GeneLocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneLocationType(&ss))
}

//export Slice_uniprot_GeneLocationType_set
func Slice_uniprot_GeneLocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneLocationType(_vl)
}

//export Slice_uniprot_GeneLocationType_append
func Slice_uniprot_GeneLocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneLocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneLocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneNameType
func ptrFromHandle_Slice_uniprot_GeneNameType(h CGoHandle) *[]uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneNameType)
}
func deptrFromHandle_Slice_uniprot_GeneNameType(h CGoHandle) []uniprot.GeneNameType {
	p := ptrFromHandle_Slice_uniprot_GeneNameType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneNameType", p))
}

// --- wrapping slice: []uniprot.GeneNameType ---
//
//export Slice_uniprot_GeneNameType_CTor
func Slice_uniprot_GeneNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneNameType(&[]uniprot.GeneNameType{}))
}

//export Slice_uniprot_GeneNameType_len
func Slice_uniprot_GeneNameType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneNameType(handle))
}

//export Slice_uniprot_GeneNameType_elem
func Slice_uniprot_GeneNameType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	return handleFromPtr_uniprot_GeneNameType(&(s[_idx]))
}

//export Slice_uniprot_GeneNameType_subslice
func Slice_uniprot_GeneNameType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneNameType(&ss))
}

//export Slice_uniprot_GeneNameType_set
func Slice_uniprot_GeneNameType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneNameType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneNameType(_vl)
}

//export Slice_uniprot_GeneNameType_append
func Slice_uniprot_GeneNameType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneNameType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneNameType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.GeneType
func ptrFromHandle_Slice_uniprot_GeneType(h CGoHandle) *[]uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.GeneType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.GeneType)
}
func deptrFromHandle_Slice_uniprot_GeneType(h CGoHandle) []uniprot.GeneType {
	p := ptrFromHandle_Slice_uniprot_GeneType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.GeneType", p))
}

// --- wrapping slice: []uniprot.GeneType ---
//
//export Slice_uniprot_GeneType_CTor
func Slice_uniprot_GeneType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneType(&[]uniprot.GeneType{}))
}

//export Slice_uniprot_GeneType_len
func Slice_uniprot_GeneType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_GeneType(handle))
}

//export Slice_uniprot_GeneType_elem
func Slice_uniprot_GeneType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	return handleFromPtr_uniprot_GeneType(&(s[_idx]))
}

//export Slice_uniprot_GeneType_subslice
func Slice_uniprot_GeneType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_GeneType(&ss))
}

//export Slice_uniprot_GeneType_set
func Slice_uniprot_GeneType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_GeneType(handle)
	s[_idx] = *ptrFromHandle_uniprot_GeneType(_vl)
}

//export Slice_uniprot_GeneType_append
func Slice_uniprot_GeneType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_GeneType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_GeneType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.InteractantType
func ptrFromHandle_Slice_uniprot_InteractantType(h CGoHandle) *[]uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.InteractantType)
}
func deptrFromHandle_Slice_uniprot_InteractantType(h CGoHandle) []uniprot.InteractantType {
	p := ptrFromHandle_Slice_uniprot_InteractantType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.InteractantType", p))
}

// --- wrapping slice: []uniprot.InteractantType ---
//
//export Slice_uniprot_InteractantType_CTor
func Slice_uniprot_InteractantType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_InteractantType(&[]uniprot.InteractantType{}))
}

//export Slice_uniprot_InteractantType_len
func Slice_uniprot_InteractantType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_InteractantType(handle))
}

//export Slice_uniprot_InteractantType_elem
func Slice_uniprot_InteractantType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	return handleFromPtr_uniprot_InteractantType(&(s[_idx]))
}

//export Slice_uniprot_InteractantType_subslice
func Slice_uniprot_InteractantType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_InteractantType(&ss))
}

//export Slice_uniprot_InteractantType_set
func Slice_uniprot_InteractantType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_InteractantType(handle)
	s[_idx] = *ptrFromHandle_uniprot_InteractantType(_vl)
}

//export Slice_uniprot_InteractantType_append
func Slice_uniprot_InteractantType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_InteractantType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_InteractantType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.IsoformType
func ptrFromHandle_Slice_uniprot_IsoformType(h CGoHandle) *[]uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.IsoformType)
}
func deptrFromHandle_Slice_uniprot_IsoformType(h CGoHandle) []uniprot.IsoformType {
	p := ptrFromHandle_Slice_uniprot_IsoformType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.IsoformType", p))
}

// --- wrapping slice: []uniprot.IsoformType ---
//
//export Slice_uniprot_IsoformType_CTor
func Slice_uniprot_IsoformType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_IsoformType(&[]uniprot.IsoformType{}))
}

//export Slice_uniprot_IsoformType_len
func Slice_uniprot_IsoformType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_IsoformType(handle))
}

//export Slice_uniprot_IsoformType_elem
func Slice_uniprot_IsoformType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	return handleFromPtr_uniprot_IsoformType(&(s[_idx]))
}

//export Slice_uniprot_IsoformType_subslice
func Slice_uniprot_IsoformType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_IsoformType(&ss))
}

//export Slice_uniprot_IsoformType_set
func Slice_uniprot_IsoformType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_IsoformType(handle)
	s[_idx] = *ptrFromHandle_uniprot_IsoformType(_vl)
}

//export Slice_uniprot_IsoformType_append
func Slice_uniprot_IsoformType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_IsoformType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_IsoformType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.KeywordType
func ptrFromHandle_Slice_uniprot_KeywordType(h CGoHandle) *[]uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.KeywordType)
}
func deptrFromHandle_Slice_uniprot_KeywordType(h CGoHandle) []uniprot.KeywordType {
	p := ptrFromHandle_Slice_uniprot_KeywordType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.KeywordType", p))
}

// --- wrapping slice: []uniprot.KeywordType ---
//
//export Slice_uniprot_KeywordType_CTor
func Slice_uniprot_KeywordType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_KeywordType(&[]uniprot.KeywordType{}))
}

//export Slice_uniprot_KeywordType_len
func Slice_uniprot_KeywordType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_KeywordType(handle))
}

//export Slice_uniprot_KeywordType_elem
func Slice_uniprot_KeywordType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	return handleFromPtr_uniprot_KeywordType(&(s[_idx]))
}

//export Slice_uniprot_KeywordType_subslice
func Slice_uniprot_KeywordType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_KeywordType(&ss))
}

//export Slice_uniprot_KeywordType_set
func Slice_uniprot_KeywordType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_KeywordType(handle)
	s[_idx] = *ptrFromHandle_uniprot_KeywordType(_vl)
}

//export Slice_uniprot_KeywordType_append
func Slice_uniprot_KeywordType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_KeywordType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_KeywordType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Link
func ptrFromHandle_Slice_uniprot_Link(h CGoHandle) *[]uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Link")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Link)
}
func deptrFromHandle_Slice_uniprot_Link(h CGoHandle) []uniprot.Link {
	p := ptrFromHandle_Slice_uniprot_Link(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Link", p))
}

// --- wrapping slice: []uniprot.Link ---
//
//export Slice_uniprot_Link_CTor
func Slice_uniprot_Link_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Link(&[]uniprot.Link{}))
}

//export Slice_uniprot_Link_len
func Slice_uniprot_Link_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Link(handle))
}

//export Slice_uniprot_Link_elem
func Slice_uniprot_Link_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	return handleFromPtr_uniprot_Link(&(s[_idx]))
}

//export Slice_uniprot_Link_subslice
func Slice_uniprot_Link_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Link(&ss))
}

//export Slice_uniprot_Link_set
func Slice_uniprot_Link_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Link(handle)
	s[_idx] = *ptrFromHandle_uniprot_Link(_vl)
}

//export Slice_uniprot_Link_append
func Slice_uniprot_Link_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Link(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Link(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.LocationType
func ptrFromHandle_Slice_uniprot_LocationType(h CGoHandle) *[]uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.LocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.LocationType)
}
func deptrFromHandle_Slice_uniprot_LocationType(h CGoHandle) []uniprot.LocationType {
	p := ptrFromHandle_Slice_uniprot_LocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.LocationType", p))
}

// --- wrapping slice: []uniprot.LocationType ---
//
//export Slice_uniprot_LocationType_CTor
func Slice_uniprot_LocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_LocationType(&[]uniprot.LocationType{}))
}

//export Slice_uniprot_LocationType_len
func Slice_uniprot_LocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_LocationType(handle))
}

//export Slice_uniprot_LocationType_elem
func Slice_uniprot_LocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_LocationType(&(s[_idx]))
}

//export Slice_uniprot_LocationType_subslice
func Slice_uniprot_LocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_LocationType(&ss))
}

//export Slice_uniprot_LocationType_set
func Slice_uniprot_LocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_LocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_LocationType(_vl)
}

//export Slice_uniprot_LocationType_append
func Slice_uniprot_LocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_LocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_LocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.Name
func ptrFromHandle_Slice_uniprot_Name(h CGoHandle) *[]uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.Name")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.Name)
}
func deptrFromHandle_Slice_uniprot_Name(h CGoHandle) []uniprot.Name {
	p := ptrFromHandle_Slice_uniprot_Name(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.Name", p))
}

// --- wrapping slice: []uniprot.Name ---
//
//export Slice_uniprot_Name_CTor
func Slice_uniprot_Name_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_Name(&[]uniprot.Name{}))
}

//export Slice_uniprot_Name_len
func Slice_uniprot_Name_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_Name(handle))
}

//export Slice_uniprot_Name_elem
func Slice_uniprot_Name_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	return handleFromPtr_uniprot_Name(&(s[_idx]))
}

//export Slice_uniprot_Name_subslice
func Slice_uniprot_Name_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_Name(&ss))
}

//export Slice_uniprot_Name_set
func Slice_uniprot_Name_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_Name(handle)
	s[_idx] = *ptrFromHandle_uniprot_Name(_vl)
}

//export Slice_uniprot_Name_append
func Slice_uniprot_Name_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_Name(handle)
	*s = append(*s, *ptrFromHandle_uniprot_Name(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.OrganismNameType
func ptrFromHandle_Slice_uniprot_OrganismNameType(h CGoHandle) *[]uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.OrganismNameType)
}
func deptrFromHandle_Slice_uniprot_OrganismNameType(h CGoHandle) []uniprot.OrganismNameType {
	p := ptrFromHandle_Slice_uniprot_OrganismNameType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.OrganismNameType", p))
}

// --- wrapping slice: []uniprot.OrganismNameType ---
//
//export Slice_uniprot_OrganismNameType_CTor
func Slice_uniprot_OrganismNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismNameType(&[]uniprot.OrganismNameType{}))
}

//export Slice_uniprot_OrganismNameType_len
func Slice_uniprot_OrganismNameType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_OrganismNameType(handle))
}

//export Slice_uniprot_OrganismNameType_elem
func Slice_uniprot_OrganismNameType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	return handleFromPtr_uniprot_OrganismNameType(&(s[_idx]))
}

//export Slice_uniprot_OrganismNameType_subslice
func Slice_uniprot_OrganismNameType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismNameType(&ss))
}

//export Slice_uniprot_OrganismNameType_set
func Slice_uniprot_OrganismNameType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	s[_idx] = *ptrFromHandle_uniprot_OrganismNameType(_vl)
}

//export Slice_uniprot_OrganismNameType_append
func Slice_uniprot_OrganismNameType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_OrganismNameType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_OrganismNameType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.OrganismType
func ptrFromHandle_Slice_uniprot_OrganismType(h CGoHandle) *[]uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.OrganismType)
}
func deptrFromHandle_Slice_uniprot_OrganismType(h CGoHandle) []uniprot.OrganismType {
	p := ptrFromHandle_Slice_uniprot_OrganismType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.OrganismType", p))
}

// --- wrapping slice: []uniprot.OrganismType ---
//
//export Slice_uniprot_OrganismType_CTor
func Slice_uniprot_OrganismType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismType(&[]uniprot.OrganismType{}))
}

//export Slice_uniprot_OrganismType_len
func Slice_uniprot_OrganismType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_OrganismType(handle))
}

//export Slice_uniprot_OrganismType_elem
func Slice_uniprot_OrganismType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_OrganismType(&(s[_idx]))
}

//export Slice_uniprot_OrganismType_subslice
func Slice_uniprot_OrganismType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_OrganismType(&ss))
}

//export Slice_uniprot_OrganismType_set
func Slice_uniprot_OrganismType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_OrganismType(handle)
	s[_idx] = *ptrFromHandle_uniprot_OrganismType(_vl)
}

//export Slice_uniprot_OrganismType_append
func Slice_uniprot_OrganismType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_OrganismType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_OrganismType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.PhysiologicalReactionType
func ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h CGoHandle) *[]uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.PhysiologicalReactionType)
}
func deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h CGoHandle) []uniprot.PhysiologicalReactionType {
	p := ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.PhysiologicalReactionType", p))
}

// --- wrapping slice: []uniprot.PhysiologicalReactionType ---
//
//export Slice_uniprot_PhysiologicalReactionType_CTor
func Slice_uniprot_PhysiologicalReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&[]uniprot.PhysiologicalReactionType{}))
}

//export Slice_uniprot_PhysiologicalReactionType_len
func Slice_uniprot_PhysiologicalReactionType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle))
}

//export Slice_uniprot_PhysiologicalReactionType_elem
func Slice_uniprot_PhysiologicalReactionType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_PhysiologicalReactionType(&(s[_idx]))
}

//export Slice_uniprot_PhysiologicalReactionType_subslice
func Slice_uniprot_PhysiologicalReactionType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&ss))
}

//export Slice_uniprot_PhysiologicalReactionType_set
func Slice_uniprot_PhysiologicalReactionType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	s[_idx] = *ptrFromHandle_uniprot_PhysiologicalReactionType(_vl)
}

//export Slice_uniprot_PhysiologicalReactionType_append
func Slice_uniprot_PhysiologicalReactionType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_PhysiologicalReactionType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_PhysiologicalReactionType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.PropertyType
func ptrFromHandle_Slice_uniprot_PropertyType(h CGoHandle) *[]uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.PropertyType)
}
func deptrFromHandle_Slice_uniprot_PropertyType(h CGoHandle) []uniprot.PropertyType {
	p := ptrFromHandle_Slice_uniprot_PropertyType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.PropertyType", p))
}

// --- wrapping slice: []uniprot.PropertyType ---
//
//export Slice_uniprot_PropertyType_CTor
func Slice_uniprot_PropertyType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_PropertyType(&[]uniprot.PropertyType{}))
}

//export Slice_uniprot_PropertyType_len
func Slice_uniprot_PropertyType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_PropertyType(handle))
}

//export Slice_uniprot_PropertyType_elem
func Slice_uniprot_PropertyType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	return handleFromPtr_uniprot_PropertyType(&(s[_idx]))
}

//export Slice_uniprot_PropertyType_subslice
func Slice_uniprot_PropertyType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_PropertyType(&ss))
}

//export Slice_uniprot_PropertyType_set
func Slice_uniprot_PropertyType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_PropertyType(handle)
	s[_idx] = *ptrFromHandle_uniprot_PropertyType(_vl)
}

//export Slice_uniprot_PropertyType_append
func Slice_uniprot_PropertyType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_PropertyType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_PropertyType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.ReferenceType
func ptrFromHandle_Slice_uniprot_ReferenceType(h CGoHandle) *[]uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.ReferenceType)
}
func deptrFromHandle_Slice_uniprot_ReferenceType(h CGoHandle) []uniprot.ReferenceType {
	p := ptrFromHandle_Slice_uniprot_ReferenceType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.ReferenceType", p))
}

// --- wrapping slice: []uniprot.ReferenceType ---
//
//export Slice_uniprot_ReferenceType_CTor
func Slice_uniprot_ReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_ReferenceType(&[]uniprot.ReferenceType{}))
}

//export Slice_uniprot_ReferenceType_len
func Slice_uniprot_ReferenceType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_ReferenceType(handle))
}

//export Slice_uniprot_ReferenceType_elem
func Slice_uniprot_ReferenceType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_ReferenceType(&(s[_idx]))
}

//export Slice_uniprot_ReferenceType_subslice
func Slice_uniprot_ReferenceType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_ReferenceType(&ss))
}

//export Slice_uniprot_ReferenceType_set
func Slice_uniprot_ReferenceType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_ReferenceType(handle)
	s[_idx] = *ptrFromHandle_uniprot_ReferenceType(_vl)
}

//export Slice_uniprot_ReferenceType_append
func Slice_uniprot_ReferenceType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_ReferenceType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_ReferenceType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.StatusType
func ptrFromHandle_Slice_uniprot_StatusType(h CGoHandle) *[]uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.StatusType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.StatusType)
}
func deptrFromHandle_Slice_uniprot_StatusType(h CGoHandle) []uniprot.StatusType {
	p := ptrFromHandle_Slice_uniprot_StatusType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.StatusType", p))
}

// --- wrapping slice: []uniprot.StatusType ---
//
//export Slice_uniprot_StatusType_CTor
func Slice_uniprot_StatusType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_StatusType(&[]uniprot.StatusType{}))
}

//export Slice_uniprot_StatusType_len
func Slice_uniprot_StatusType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_StatusType(handle))
}

//export Slice_uniprot_StatusType_elem
func Slice_uniprot_StatusType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	return handleFromPtr_uniprot_StatusType(&(s[_idx]))
}

//export Slice_uniprot_StatusType_subslice
func Slice_uniprot_StatusType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_StatusType(&ss))
}

//export Slice_uniprot_StatusType_set
func Slice_uniprot_StatusType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_StatusType(handle)
	s[_idx] = *ptrFromHandle_uniprot_StatusType(_vl)
}

//export Slice_uniprot_StatusType_append
func Slice_uniprot_StatusType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_StatusType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_StatusType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.SubcellularLocationType
func ptrFromHandle_Slice_uniprot_SubcellularLocationType(h CGoHandle) *[]uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.SubcellularLocationType)
}
func deptrFromHandle_Slice_uniprot_SubcellularLocationType(h CGoHandle) []uniprot.SubcellularLocationType {
	p := ptrFromHandle_Slice_uniprot_SubcellularLocationType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.SubcellularLocationType", p))
}

// --- wrapping slice: []uniprot.SubcellularLocationType ---
//
//export Slice_uniprot_SubcellularLocationType_CTor
func Slice_uniprot_SubcellularLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_SubcellularLocationType(&[]uniprot.SubcellularLocationType{}))
}

//export Slice_uniprot_SubcellularLocationType_len
func Slice_uniprot_SubcellularLocationType_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle))
}

//export Slice_uniprot_SubcellularLocationType_elem
func Slice_uniprot_SubcellularLocationType_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_uniprot_SubcellularLocationType(&(s[_idx]))
}

//export Slice_uniprot_SubcellularLocationType_subslice
func Slice_uniprot_SubcellularLocationType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_SubcellularLocationType(&ss))
}

//export Slice_uniprot_SubcellularLocationType_set
func Slice_uniprot_SubcellularLocationType_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	s[_idx] = *ptrFromHandle_uniprot_SubcellularLocationType(_vl)
}

//export Slice_uniprot_SubcellularLocationType_append
func Slice_uniprot_SubcellularLocationType_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_SubcellularLocationType(handle)
	*s = append(*s, *ptrFromHandle_uniprot_SubcellularLocationType(_vl))
}

// Converters for implicit pointer handles for type: []uniprot.SubmittedName
func ptrFromHandle_Slice_uniprot_SubmittedName(h CGoHandle) *[]uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return p.(*[]uniprot.SubmittedName)
}
func deptrFromHandle_Slice_uniprot_SubmittedName(h CGoHandle) []uniprot.SubmittedName {
	p := ptrFromHandle_Slice_uniprot_SubmittedName(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uniprot.SubmittedName", p))
}

// --- wrapping slice: []uniprot.SubmittedName ---
//
//export Slice_uniprot_SubmittedName_CTor
func Slice_uniprot_SubmittedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uniprot_SubmittedName(&[]uniprot.SubmittedName{}))
}

//export Slice_uniprot_SubmittedName_len
func Slice_uniprot_SubmittedName_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uniprot_SubmittedName(handle))
}

//export Slice_uniprot_SubmittedName_elem
func Slice_uniprot_SubmittedName_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	return handleFromPtr_uniprot_SubmittedName(&(s[_idx]))
}

//export Slice_uniprot_SubmittedName_subslice
func Slice_uniprot_SubmittedName_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uniprot_SubmittedName(&ss))
}

//export Slice_uniprot_SubmittedName_set
func Slice_uniprot_SubmittedName_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_uniprot_SubmittedName(handle)
	s[_idx] = *ptrFromHandle_uniprot_SubmittedName(_vl)
}

//export Slice_uniprot_SubmittedName_append
func Slice_uniprot_SubmittedName_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_uniprot_SubmittedName(handle)
	*s = append(*s, *ptrFromHandle_uniprot_SubmittedName(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: uniprot.Absorption
func ptrFromHandle_uniprot_Absorption(h CGoHandle) *uniprot.Absorption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Absorption")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Absorption{})).(*uniprot.Absorption)
}
func handleFromPtr_uniprot_Absorption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Absorption", p))
}

// Converters for non-pointer handles for type: uniprot.AlternativeName
func ptrFromHandle_uniprot_AlternativeName(h CGoHandle) *uniprot.AlternativeName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.AlternativeName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.AlternativeName{})).(*uniprot.AlternativeName)
}
func handleFromPtr_uniprot_AlternativeName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.AlternativeName", p))
}

// Converters for non-pointer handles for type: uniprot.Anon6
func ptrFromHandle_uniprot_Anon6(h CGoHandle) *uniprot.Anon6 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Anon6")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Anon6{})).(*uniprot.Anon6)
}
func handleFromPtr_uniprot_Anon6(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Anon6", p))
}

// Converters for non-pointer handles for type: uniprot.CitationType
func ptrFromHandle_uniprot_CitationType(h CGoHandle) *uniprot.CitationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CitationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CitationType{})).(*uniprot.CitationType)
}
func handleFromPtr_uniprot_CitationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CitationType", p))
}

// Converters for non-pointer handles for type: uniprot.CofactorType
func ptrFromHandle_uniprot_CofactorType(h CGoHandle) *uniprot.CofactorType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CofactorType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CofactorType{})).(*uniprot.CofactorType)
}
func handleFromPtr_uniprot_CofactorType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CofactorType", p))
}

// Converters for non-pointer handles for type: uniprot.CommentType
func ptrFromHandle_uniprot_CommentType(h CGoHandle) *uniprot.CommentType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.CommentType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType)
}
func handleFromPtr_uniprot_CommentType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.CommentType", p))
}

// Converters for non-pointer handles for type: uniprot.Component
func ptrFromHandle_uniprot_Component(h CGoHandle) *uniprot.Component {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Component")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Component{})).(*uniprot.Component)
}
func handleFromPtr_uniprot_Component(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Component", p))
}

// Converters for non-pointer handles for type: uniprot.Conflict
func ptrFromHandle_uniprot_Conflict(h CGoHandle) *uniprot.Conflict {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Conflict")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Conflict{})).(*uniprot.Conflict)
}
func handleFromPtr_uniprot_Conflict(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Conflict", p))
}

// Converters for non-pointer handles for type: uniprot.ConsortiumType
func ptrFromHandle_uniprot_ConsortiumType(h CGoHandle) *uniprot.ConsortiumType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ConsortiumType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ConsortiumType{})).(*uniprot.ConsortiumType)
}
func handleFromPtr_uniprot_ConsortiumType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ConsortiumType", p))
}

// Converters for non-pointer handles for type: uniprot.DbReferenceType
func ptrFromHandle_uniprot_DbReferenceType(h CGoHandle) *uniprot.DbReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.DbReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.DbReferenceType{})).(*uniprot.DbReferenceType)
}
func handleFromPtr_uniprot_DbReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.DbReferenceType", p))
}

// Converters for pointer handles for type: uniprot.Decoder
func ptrFromHandle_uniprot_Decoder(h CGoHandle) uniprot.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Decoder")
	if p == nil {
		return nil
	}
	return p.(uniprot.Decoder)
}
func handleFromPtr_uniprot_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Decoder", p))
}

// Converters for non-pointer handles for type: uniprot.Disease
func ptrFromHandle_uniprot_Disease(h CGoHandle) *uniprot.Disease {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Disease")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Disease{})).(*uniprot.Disease)
}
func handleFromPtr_uniprot_Disease(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Disease", p))
}

// Converters for non-pointer handles for type: uniprot.Domain
func ptrFromHandle_uniprot_Domain(h CGoHandle) *uniprot.Domain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Domain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Domain{})).(*uniprot.Domain)
}
func handleFromPtr_uniprot_Domain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Domain", p))
}

// Converters for non-pointer handles for type: uniprot.Entry
func ptrFromHandle_uniprot_Entry(h CGoHandle) *uniprot.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry)
}
func handleFromPtr_uniprot_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Entry", p))
}

// Converters for non-pointer handles for type: uniprot.EventType
func ptrFromHandle_uniprot_EventType(h CGoHandle) *uniprot.EventType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EventType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EventType{})).(*uniprot.EventType)
}
func handleFromPtr_uniprot_EventType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EventType", p))
}

// Converters for non-pointer handles for type: uniprot.EvidenceType
func ptrFromHandle_uniprot_EvidenceType(h CGoHandle) *uniprot.EvidenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EvidenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidenceType{})).(*uniprot.EvidenceType)
}
func handleFromPtr_uniprot_EvidenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EvidenceType", p))
}

// Converters for non-pointer handles for type: uniprot.EvidencedStringType
func ptrFromHandle_uniprot_EvidencedStringType(h CGoHandle) *uniprot.EvidencedStringType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.EvidencedStringType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.EvidencedStringType{})).(*uniprot.EvidencedStringType)
}
func handleFromPtr_uniprot_EvidencedStringType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.EvidencedStringType", p))
}

// Converters for non-pointer handles for type: uniprot.FeatureType
func ptrFromHandle_uniprot_FeatureType(h CGoHandle) *uniprot.FeatureType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.FeatureType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.FeatureType{})).(*uniprot.FeatureType)
}
func handleFromPtr_uniprot_FeatureType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.FeatureType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneLocationType
func ptrFromHandle_uniprot_GeneLocationType(h CGoHandle) *uniprot.GeneLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneLocationType{})).(*uniprot.GeneLocationType)
}
func handleFromPtr_uniprot_GeneLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneLocationType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneNameType
func ptrFromHandle_uniprot_GeneNameType(h CGoHandle) *uniprot.GeneNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneNameType{})).(*uniprot.GeneNameType)
}
func handleFromPtr_uniprot_GeneNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneNameType", p))
}

// Converters for non-pointer handles for type: uniprot.GeneType
func ptrFromHandle_uniprot_GeneType(h CGoHandle) *uniprot.GeneType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.GeneType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.GeneType{})).(*uniprot.GeneType)
}
func handleFromPtr_uniprot_GeneType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.GeneType", p))
}

// Converters for non-pointer handles for type: uniprot.ImportedFromType
func ptrFromHandle_uniprot_ImportedFromType(h CGoHandle) *uniprot.ImportedFromType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ImportedFromType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ImportedFromType{})).(*uniprot.ImportedFromType)
}
func handleFromPtr_uniprot_ImportedFromType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ImportedFromType", p))
}

// Converters for implicit pointer handles for type: uniprot.IntListType
func ptrFromHandle_uniprot_IntListType(h CGoHandle) *uniprot.IntListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.IntListType")
	if p == nil {
		return nil
	}
	return p.(*uniprot.IntListType)
}
func deptrFromHandle_uniprot_IntListType(h CGoHandle) uniprot.IntListType {
	p := ptrFromHandle_uniprot_IntListType(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_uniprot_IntListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.IntListType", p))
}

// Converters for non-pointer handles for type: uniprot.InteractantType
func ptrFromHandle_uniprot_InteractantType(h CGoHandle) *uniprot.InteractantType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.InteractantType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.InteractantType{})).(*uniprot.InteractantType)
}
func handleFromPtr_uniprot_InteractantType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.InteractantType", p))
}

// Converters for non-pointer handles for type: uniprot.IsoformType
func ptrFromHandle_uniprot_IsoformType(h CGoHandle) *uniprot.IsoformType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.IsoformType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.IsoformType{})).(*uniprot.IsoformType)
}
func handleFromPtr_uniprot_IsoformType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.IsoformType", p))
}

// Converters for non-pointer handles for type: uniprot.KeywordType
func ptrFromHandle_uniprot_KeywordType(h CGoHandle) *uniprot.KeywordType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.KeywordType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.KeywordType{})).(*uniprot.KeywordType)
}
func handleFromPtr_uniprot_KeywordType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.KeywordType", p))
}

// Converters for non-pointer handles for type: uniprot.Kinetics
func ptrFromHandle_uniprot_Kinetics(h CGoHandle) *uniprot.Kinetics {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Kinetics")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Kinetics{})).(*uniprot.Kinetics)
}
func handleFromPtr_uniprot_Kinetics(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Kinetics", p))
}

// Converters for non-pointer handles for type: uniprot.Lineage
func ptrFromHandle_uniprot_Lineage(h CGoHandle) *uniprot.Lineage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Lineage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Lineage{})).(*uniprot.Lineage)
}
func handleFromPtr_uniprot_Lineage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Lineage", p))
}

// Converters for non-pointer handles for type: uniprot.Link
func ptrFromHandle_uniprot_Link(h CGoHandle) *uniprot.Link {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Link")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Link{})).(*uniprot.Link)
}
func handleFromPtr_uniprot_Link(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Link", p))
}

// Converters for non-pointer handles for type: uniprot.LocationType
func ptrFromHandle_uniprot_LocationType(h CGoHandle) *uniprot.LocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.LocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.LocationType{})).(*uniprot.LocationType)
}
func handleFromPtr_uniprot_LocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.LocationType", p))
}

// Converters for non-pointer handles for type: uniprot.Name
func ptrFromHandle_uniprot_Name(h CGoHandle) *uniprot.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Name{})).(*uniprot.Name)
}
func handleFromPtr_uniprot_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Name", p))
}

// Converters for non-pointer handles for type: uniprot.NameListType
func ptrFromHandle_uniprot_NameListType(h CGoHandle) *uniprot.NameListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.NameListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.NameListType{})).(*uniprot.NameListType)
}
func handleFromPtr_uniprot_NameListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.NameListType", p))
}

// Converters for non-pointer handles for type: uniprot.OrganismNameType
func ptrFromHandle_uniprot_OrganismNameType(h CGoHandle) *uniprot.OrganismNameType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.OrganismNameType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismNameType{})).(*uniprot.OrganismNameType)
}
func handleFromPtr_uniprot_OrganismNameType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.OrganismNameType", p))
}

// Converters for non-pointer handles for type: uniprot.OrganismType
func ptrFromHandle_uniprot_OrganismType(h CGoHandle) *uniprot.OrganismType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.OrganismType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.OrganismType{})).(*uniprot.OrganismType)
}
func handleFromPtr_uniprot_OrganismType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.OrganismType", p))
}

// Converters for non-pointer handles for type: uniprot.PersonType
func ptrFromHandle_uniprot_PersonType(h CGoHandle) *uniprot.PersonType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PersonType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PersonType{})).(*uniprot.PersonType)
}
func handleFromPtr_uniprot_PersonType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PersonType", p))
}

// Converters for non-pointer handles for type: uniprot.PhDependence
func ptrFromHandle_uniprot_PhDependence(h CGoHandle) *uniprot.PhDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PhDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhDependence{})).(*uniprot.PhDependence)
}
func handleFromPtr_uniprot_PhDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PhDependence", p))
}

// Converters for non-pointer handles for type: uniprot.PhysiologicalReactionType
func ptrFromHandle_uniprot_PhysiologicalReactionType(h CGoHandle) *uniprot.PhysiologicalReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PhysiologicalReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PhysiologicalReactionType{})).(*uniprot.PhysiologicalReactionType)
}
func handleFromPtr_uniprot_PhysiologicalReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PhysiologicalReactionType", p))
}

// Converters for non-pointer handles for type: uniprot.Plasmid
func ptrFromHandle_uniprot_Plasmid(h CGoHandle) *uniprot.Plasmid {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Plasmid")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Plasmid{})).(*uniprot.Plasmid)
}
func handleFromPtr_uniprot_Plasmid(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Plasmid", p))
}

// Converters for non-pointer handles for type: uniprot.PositionType
func ptrFromHandle_uniprot_PositionType(h CGoHandle) *uniprot.PositionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PositionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType)
}
func handleFromPtr_uniprot_PositionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PositionType", p))
}

// Converters for non-pointer handles for type: uniprot.PropertyType
func ptrFromHandle_uniprot_PropertyType(h CGoHandle) *uniprot.PropertyType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.PropertyType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.PropertyType{})).(*uniprot.PropertyType)
}
func handleFromPtr_uniprot_PropertyType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.PropertyType", p))
}

// Converters for non-pointer handles for type: uniprot.ProteinExistenceType
func ptrFromHandle_uniprot_ProteinExistenceType(h CGoHandle) *uniprot.ProteinExistenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ProteinExistenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinExistenceType{})).(*uniprot.ProteinExistenceType)
}
func handleFromPtr_uniprot_ProteinExistenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ProteinExistenceType", p))
}

// Converters for non-pointer handles for type: uniprot.ProteinType
func ptrFromHandle_uniprot_ProteinType(h CGoHandle) *uniprot.ProteinType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ProteinType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ProteinType{})).(*uniprot.ProteinType)
}
func handleFromPtr_uniprot_ProteinType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ProteinType", p))
}

// Converters for non-pointer handles for type: uniprot.ReactionType
func ptrFromHandle_uniprot_ReactionType(h CGoHandle) *uniprot.ReactionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ReactionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReactionType{})).(*uniprot.ReactionType)
}
func handleFromPtr_uniprot_ReactionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ReactionType", p))
}

// Converters for non-pointer handles for type: uniprot.RecommendedName
func ptrFromHandle_uniprot_RecommendedName(h CGoHandle) *uniprot.RecommendedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.RecommendedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RecommendedName{})).(*uniprot.RecommendedName)
}
func handleFromPtr_uniprot_RecommendedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.RecommendedName", p))
}

// Converters for non-pointer handles for type: uniprot.RedoxPotential
func ptrFromHandle_uniprot_RedoxPotential(h CGoHandle) *uniprot.RedoxPotential {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.RedoxPotential")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.RedoxPotential{})).(*uniprot.RedoxPotential)
}
func handleFromPtr_uniprot_RedoxPotential(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.RedoxPotential", p))
}

// Converters for non-pointer handles for type: uniprot.ReferenceType
func ptrFromHandle_uniprot_ReferenceType(h CGoHandle) *uniprot.ReferenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.ReferenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.ReferenceType{})).(*uniprot.ReferenceType)
}
func handleFromPtr_uniprot_ReferenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.ReferenceType", p))
}

// Converters for non-pointer handles for type: uniprot.Sequence
func ptrFromHandle_uniprot_Sequence(h CGoHandle) *uniprot.Sequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Sequence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Sequence{})).(*uniprot.Sequence)
}
func handleFromPtr_uniprot_Sequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Sequence", p))
}

// Converters for non-pointer handles for type: uniprot.SequenceType
func ptrFromHandle_uniprot_SequenceType(h CGoHandle) *uniprot.SequenceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SequenceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType)
}
func handleFromPtr_uniprot_SequenceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SequenceType", p))
}

// Converters for non-pointer handles for type: uniprot.SourceDataType
func ptrFromHandle_uniprot_SourceDataType(h CGoHandle) *uniprot.SourceDataType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SourceDataType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceDataType{})).(*uniprot.SourceDataType)
}
func handleFromPtr_uniprot_SourceDataType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SourceDataType", p))
}

// Converters for non-pointer handles for type: uniprot.SourceType
func ptrFromHandle_uniprot_SourceType(h CGoHandle) *uniprot.SourceType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SourceType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SourceType{})).(*uniprot.SourceType)
}
func handleFromPtr_uniprot_SourceType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SourceType", p))
}

// Converters for non-pointer handles for type: uniprot.StatusType
func ptrFromHandle_uniprot_StatusType(h CGoHandle) *uniprot.StatusType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.StatusType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.StatusType{})).(*uniprot.StatusType)
}
func handleFromPtr_uniprot_StatusType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.StatusType", p))
}

// Converters for non-pointer handles for type: uniprot.Strain
func ptrFromHandle_uniprot_Strain(h CGoHandle) *uniprot.Strain {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Strain")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Strain{})).(*uniprot.Strain)
}
func handleFromPtr_uniprot_Strain(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Strain", p))
}

// Converters for non-pointer handles for type: uniprot.SubcellularLocationType
func ptrFromHandle_uniprot_SubcellularLocationType(h CGoHandle) *uniprot.SubcellularLocationType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SubcellularLocationType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubcellularLocationType{})).(*uniprot.SubcellularLocationType)
}
func handleFromPtr_uniprot_SubcellularLocationType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SubcellularLocationType", p))
}

// Converters for non-pointer handles for type: uniprot.SubmittedName
func ptrFromHandle_uniprot_SubmittedName(h CGoHandle) *uniprot.SubmittedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.SubmittedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.SubmittedName{})).(*uniprot.SubmittedName)
}
func handleFromPtr_uniprot_SubmittedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.SubmittedName", p))
}

// Converters for non-pointer handles for type: uniprot.TemperatureDependence
func ptrFromHandle_uniprot_TemperatureDependence(h CGoHandle) *uniprot.TemperatureDependence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.TemperatureDependence")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.TemperatureDependence{})).(*uniprot.TemperatureDependence)
}
func handleFromPtr_uniprot_TemperatureDependence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.TemperatureDependence", p))
}

// Converters for non-pointer handles for type: uniprot.Tissue
func ptrFromHandle_uniprot_Tissue(h CGoHandle) *uniprot.Tissue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Tissue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Tissue{})).(*uniprot.Tissue)
}
func handleFromPtr_uniprot_Tissue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Tissue", p))
}

// Converters for non-pointer handles for type: uniprot.Transposon
func ptrFromHandle_uniprot_Transposon(h CGoHandle) *uniprot.Transposon {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Transposon")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Transposon{})).(*uniprot.Transposon)
}
func handleFromPtr_uniprot_Transposon(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Transposon", p))
}

// Converters for non-pointer handles for type: uniprot.Uniprot
func ptrFromHandle_uniprot_Uniprot(h CGoHandle) *uniprot.Uniprot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uniprot.Uniprot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(uniprot.Uniprot{})).(*uniprot.Uniprot)
}
func handleFromPtr_uniprot_Uniprot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uniprot.Uniprot", p))
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export uniprot_Decoder_DecodeElement
func uniprot_Decoder_DecodeElement(_handle CGoHandle, v *C.char, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "uniprot.Decoder")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(uniprot.Decoder).DecodeElement(C.GoString(v), ptrFromHandle_Ptr_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export uniprot_Decoder_Token
func uniprot_Decoder_Token(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "uniprot.Decoder")
	if __err != nil {
		return handleFromPtr_xml_Token(nil)
	}
	cret, __err := vifc.(uniprot.Decoder).Token()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_xml_Token(nil)
	}
	return handleFromPtr_xml_Token(cret)
}

// ---- Structs ---

// --- wrapping struct: uniprot.EvidencedStringType ---
//
//export uniprot_EvidencedStringType_CTor
func uniprot_EvidencedStringType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EvidencedStringType(&uniprot.EvidencedStringType{}))
}

//export uniprot_EvidencedStringType_Value_Get
func uniprot_EvidencedStringType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	return C.CString(op.Value)
}

//export uniprot_EvidencedStringType_Value_Set
func uniprot_EvidencedStringType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_EvidencedStringType_Evidence_Get
func uniprot_EvidencedStringType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_EvidencedStringType_Evidence_Set
func uniprot_EvidencedStringType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidencedStringType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.PhysiologicalReactionType ---
//
//export uniprot_PhysiologicalReactionType_CTor
func uniprot_PhysiologicalReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PhysiologicalReactionType(&uniprot.PhysiologicalReactionType{}))
}

//export uniprot_PhysiologicalReactionType_DbReference_Get
func uniprot_PhysiologicalReactionType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_PhysiologicalReactionType_DbReference_Set
func uniprot_PhysiologicalReactionType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_PhysiologicalReactionType_Direction_Get
func uniprot_PhysiologicalReactionType_Direction_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return C.CString(string(op.Direction))
}

//export uniprot_PhysiologicalReactionType_Direction_Set
func uniprot_PhysiologicalReactionType_Direction_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.Direction = uniprot.Direction(C.GoString(val))
}

//export uniprot_PhysiologicalReactionType_Evidence_Get
func uniprot_PhysiologicalReactionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_PhysiologicalReactionType_Evidence_Set
func uniprot_PhysiologicalReactionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhysiologicalReactionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.PropertyType ---
//
//export uniprot_PropertyType_CTor
func uniprot_PropertyType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PropertyType(&uniprot.PropertyType{}))
}

//export uniprot_PropertyType_Type_Get
func uniprot_PropertyType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	return C.CString(op.Type)
}

//export uniprot_PropertyType_Type_Set
func uniprot_PropertyType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_PropertyType_Value_Get
func uniprot_PropertyType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	return C.CString(op.Value)
}

//export uniprot_PropertyType_Value_Set
func uniprot_PropertyType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PropertyType(handle)
	op.Value = C.GoString(val)
}

// --- wrapping struct: uniprot.EvidenceType ---
//
//export uniprot_EvidenceType_CTor
func uniprot_EvidenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EvidenceType(&uniprot.EvidenceType{}))
}

//export uniprot_EvidenceType_Source_Get
func uniprot_EvidenceType_Source_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_SourceType(&op.Source)
}

//export uniprot_EvidenceType_Source_Set
func uniprot_EvidenceType_Source_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Source = *ptrFromHandle_uniprot_SourceType(val)
}

//export uniprot_EvidenceType_ImportedFrom_Get
func uniprot_EvidenceType_ImportedFrom_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return handleFromPtr_uniprot_ImportedFromType(&op.ImportedFrom)
}

//export uniprot_EvidenceType_ImportedFrom_Set
func uniprot_EvidenceType_ImportedFrom_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.ImportedFrom = *ptrFromHandle_uniprot_ImportedFromType(val)
}

//export uniprot_EvidenceType_Type_Get
func uniprot_EvidenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return C.CString(op.Type)
}

//export uniprot_EvidenceType_Type_Set
func uniprot_EvidenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_EvidenceType_Key_Get
func uniprot_EvidenceType_Key_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	return C.longlong(op.Key)
}

//export uniprot_EvidenceType_Key_Set
func uniprot_EvidenceType_Key_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_EvidenceType(handle)
	op.Key = int(val)
}

// --- wrapping struct: uniprot.Absorption ---
//
//export uniprot_Absorption_CTor
func uniprot_Absorption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Absorption(&uniprot.Absorption{}))
}

//export uniprot_Absorption_Max_Get
func uniprot_Absorption_Max_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Absorption(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.Max)
}

//export uniprot_Absorption_Max_Set
func uniprot_Absorption_Max_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Absorption(handle)
	op.Max = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Absorption_Text_Get
func uniprot_Absorption_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Absorption(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_Absorption_Text_Set
func uniprot_Absorption_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Absorption(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.ConsortiumType ---
//
//export uniprot_ConsortiumType_CTor
func uniprot_ConsortiumType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ConsortiumType(&uniprot.ConsortiumType{}))
}

//export uniprot_ConsortiumType_Name_Get
func uniprot_ConsortiumType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ConsortiumType(handle)
	return C.CString(op.Name)
}

//export uniprot_ConsortiumType_Name_Set
func uniprot_ConsortiumType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ConsortiumType(handle)
	op.Name = C.GoString(val)
}

// --- wrapping struct: uniprot.DbReferenceType ---
//
//export uniprot_DbReferenceType_CTor
func uniprot_DbReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_DbReferenceType(&uniprot.DbReferenceType{}))
}

//export uniprot_DbReferenceType_Molecule_Get
func uniprot_DbReferenceType_Molecule_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return C.CString(op.Molecule)
}

//export uniprot_DbReferenceType_Molecule_Set
func uniprot_DbReferenceType_Molecule_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Molecule = C.GoString(val)
}

//export uniprot_DbReferenceType_Property_Get
func uniprot_DbReferenceType_Property_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return handleFromPtr_Slice_uniprot_PropertyType(&op.Property)
}

//export uniprot_DbReferenceType_Property_Set
func uniprot_DbReferenceType_Property_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Property = deptrFromHandle_Slice_uniprot_PropertyType(val)
}

//export uniprot_DbReferenceType_Type_Get
func uniprot_DbReferenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return C.CString(op.Type)
}

//export uniprot_DbReferenceType_Type_Set
func uniprot_DbReferenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Type = C.GoString(val)
}

//export uniprot_DbReferenceType_Evidence_Get
func uniprot_DbReferenceType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_DbReferenceType_Evidence_Set
func uniprot_DbReferenceType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_DbReferenceType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.LocationType ---
//
//export uniprot_LocationType_CTor
func uniprot_LocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_LocationType(&uniprot.LocationType{}))
}

//export uniprot_LocationType_Begin_Get
func uniprot_LocationType_Begin_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.Begin)
}

//export uniprot_LocationType_Begin_Set
func uniprot_LocationType_Begin_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Begin = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_End_Get
func uniprot_LocationType_End_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.End)
}

//export uniprot_LocationType_End_Set
func uniprot_LocationType_End_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.End = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_Position_Get
func uniprot_LocationType_Position_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return handleFromPtr_uniprot_PositionType(&op.Position)
}

//export uniprot_LocationType_Position_Set
func uniprot_LocationType_Position_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Position = *ptrFromHandle_uniprot_PositionType(val)
}

//export uniprot_LocationType_Sequence_Get
func uniprot_LocationType_Sequence_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_LocationType(handle)
	return C.CString(op.Sequence)
}

//export uniprot_LocationType_Sequence_Set
func uniprot_LocationType_Sequence_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_LocationType(handle)
	op.Sequence = C.GoString(val)
}

// --- wrapping struct: uniprot.Transposon ---
//
//export uniprot_Transposon_CTor
func uniprot_Transposon_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Transposon(&uniprot.Transposon{}))
}

//export uniprot_Transposon_Value_Get
func uniprot_Transposon_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Transposon(handle)
	return C.CString(op.Value)
}

//export uniprot_Transposon_Value_Set
func uniprot_Transposon_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Transposon(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Transposon_Evidence_Get
func uniprot_Transposon_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Transposon(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Transposon_Evidence_Set
func uniprot_Transposon_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Transposon(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Anon6 ---
//
//export uniprot_Anon6_CTor
func uniprot_Anon6_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Anon6(&uniprot.Anon6{}))
}

//export uniprot_Anon6_Type_Get
func uniprot_Anon6_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Anon6(handle)
	return C.CString(string(op.Type))
}

//export uniprot_Anon6_Type_Set
func uniprot_Anon6_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Anon6(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.FeatureType ---
//
//export uniprot_FeatureType_CTor
func uniprot_FeatureType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_FeatureType(&uniprot.FeatureType{}))
}

//export uniprot_FeatureType_Original_Get
func uniprot_FeatureType_Original_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(op.Original)
}

//export uniprot_FeatureType_Original_Set
func uniprot_FeatureType_Original_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Original = C.GoString(val)
}

//export uniprot_FeatureType_Variation_Get
func uniprot_FeatureType_Variation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_Slice_string(&op.Variation)
}

//export uniprot_FeatureType_Variation_Set
func uniprot_FeatureType_Variation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Variation = deptrFromHandle_Slice_string(val)
}

//export uniprot_FeatureType_Location_Get
func uniprot_FeatureType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_LocationType(&op.Location)
}

//export uniprot_FeatureType_Location_Set
func uniprot_FeatureType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Location = *ptrFromHandle_uniprot_LocationType(val)
}

//export uniprot_FeatureType_Type_Get
func uniprot_FeatureType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_FeatureType_Type_Set
func uniprot_FeatureType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_FeatureType_Description_Get
func uniprot_FeatureType_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return C.CString(op.Description)
}

//export uniprot_FeatureType_Description_Set
func uniprot_FeatureType_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Description = C.GoString(val)
}

//export uniprot_FeatureType_Evidence_Get
func uniprot_FeatureType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_FeatureType_Evidence_Set
func uniprot_FeatureType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_FeatureType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.OrganismNameType ---
//
//export uniprot_OrganismNameType_CTor
func uniprot_OrganismNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_OrganismNameType(&uniprot.OrganismNameType{}))
}

//export uniprot_OrganismNameType_Value_Get
func uniprot_OrganismNameType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	return C.CString(op.Value)
}

//export uniprot_OrganismNameType_Value_Set
func uniprot_OrganismNameType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_OrganismNameType_Type_Get
func uniprot_OrganismNameType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_OrganismNameType_Type_Set
func uniprot_OrganismNameType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_OrganismNameType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.OrganismType ---
//
//export uniprot_OrganismType_CTor
func uniprot_OrganismType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_OrganismType(&uniprot.OrganismType{}))
}

//export uniprot_OrganismType_Name_Get
func uniprot_OrganismType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_Slice_uniprot_OrganismNameType(&op.Name)
}

//export uniprot_OrganismType_Name_Set
func uniprot_OrganismType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_OrganismNameType(val)
}

//export uniprot_OrganismType_DbReference_Get
func uniprot_OrganismType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_OrganismType_DbReference_Set
func uniprot_OrganismType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_OrganismType_Lineage_Get
func uniprot_OrganismType_Lineage_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_Lineage(&op.Lineage)
}

//export uniprot_OrganismType_Lineage_Set
func uniprot_OrganismType_Lineage_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Lineage = *ptrFromHandle_uniprot_Lineage(val)
}

//export uniprot_OrganismType_Evidence_Get
func uniprot_OrganismType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_OrganismType_Evidence_Set
func uniprot_OrganismType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_OrganismType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ProteinExistenceType ---
//
//export uniprot_ProteinExistenceType_CTor
func uniprot_ProteinExistenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ProteinExistenceType(&uniprot.ProteinExistenceType{}))
}

//export uniprot_ProteinExistenceType_Type_Get
func uniprot_ProteinExistenceType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ProteinExistenceType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_ProteinExistenceType_Type_Set
func uniprot_ProteinExistenceType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ProteinExistenceType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.SourceType ---
//
//export uniprot_SourceType_CTor
func uniprot_SourceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SourceType(&uniprot.SourceType{}))
}

//export uniprot_SourceType_DbReference_Get
func uniprot_SourceType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_SourceType_DbReference_Set
func uniprot_SourceType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.GeneNameType ---
//
//export uniprot_GeneNameType_CTor
func uniprot_GeneNameType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneNameType(&uniprot.GeneNameType{}))
}

//export uniprot_GeneNameType_Value_Get
func uniprot_GeneNameType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return C.CString(op.Value)
}

//export uniprot_GeneNameType_Value_Set
func uniprot_GeneNameType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_GeneNameType_Evidence_Get
func uniprot_GeneNameType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_GeneNameType_Evidence_Set
func uniprot_GeneNameType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_GeneNameType_Type_Get
func uniprot_GeneNameType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_GeneNameType_Type_Set
func uniprot_GeneNameType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneNameType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.Plasmid ---
//
//export uniprot_Plasmid_CTor
func uniprot_Plasmid_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Plasmid(&uniprot.Plasmid{}))
}

//export uniprot_Plasmid_Value_Get
func uniprot_Plasmid_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	return C.CString(op.Value)
}

//export uniprot_Plasmid_Value_Set
func uniprot_Plasmid_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Plasmid_Evidence_Get
func uniprot_Plasmid_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Plasmid_Evidence_Set
func uniprot_Plasmid_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Plasmid(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Name ---
//
//export uniprot_Name_CTor
func uniprot_Name_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Name(&uniprot.Name{}))
}

//export uniprot_Name_Value_Get
func uniprot_Name_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Name(handle)
	return C.CString(op.Value)
}

//export uniprot_Name_Value_Set
func uniprot_Name_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Name(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Name_Evidence_Get
func uniprot_Name_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Name(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Name_Evidence_Set
func uniprot_Name_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Name(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ReferenceType ---
//
//export uniprot_ReferenceType_CTor
func uniprot_ReferenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ReferenceType(&uniprot.ReferenceType{}))
}

//export uniprot_ReferenceType_Citation_Get
func uniprot_ReferenceType_Citation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_CitationType(&op.Citation)
}

//export uniprot_ReferenceType_Citation_Set
func uniprot_ReferenceType_Citation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Citation = *ptrFromHandle_uniprot_CitationType(val)
}

//export uniprot_ReferenceType_Scope_Get
func uniprot_ReferenceType_Scope_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_Slice_string(&op.Scope)
}

//export uniprot_ReferenceType_Scope_Set
func uniprot_ReferenceType_Scope_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Scope = deptrFromHandle_Slice_string(val)
}

//export uniprot_ReferenceType_Source_Get
func uniprot_ReferenceType_Source_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_SourceDataType(&op.Source)
}

//export uniprot_ReferenceType_Source_Set
func uniprot_ReferenceType_Source_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Source = *ptrFromHandle_uniprot_SourceDataType(val)
}

//export uniprot_ReferenceType_Evidence_Get
func uniprot_ReferenceType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_ReferenceType_Evidence_Set
func uniprot_ReferenceType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_ReferenceType_Key_Get
func uniprot_ReferenceType_Key_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	return C.CString(op.Key)
}

//export uniprot_ReferenceType_Key_Set
func uniprot_ReferenceType_Key_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ReferenceType(handle)
	op.Key = C.GoString(val)
}

// --- wrapping struct: uniprot.Disease ---
//
//export uniprot_Disease_CTor
func uniprot_Disease_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Disease(&uniprot.Disease{}))
}

//export uniprot_Disease_Name_Get
func uniprot_Disease_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Name)
}

//export uniprot_Disease_Name_Set
func uniprot_Disease_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Name = C.GoString(val)
}

//export uniprot_Disease_Acronym_Get
func uniprot_Disease_Acronym_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Acronym)
}

//export uniprot_Disease_Acronym_Set
func uniprot_Disease_Acronym_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Acronym = C.GoString(val)
}

//export uniprot_Disease_Description_Get
func uniprot_Disease_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Disease(handle)
	return C.CString(op.Description)
}

//export uniprot_Disease_Description_Set
func uniprot_Disease_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.Description = C.GoString(val)
}

//export uniprot_Disease_DbReference_Get
func uniprot_Disease_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Disease(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_Disease_DbReference_Set
func uniprot_Disease_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Disease(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.Entry ---
//
//export uniprot_Entry_CTor
func uniprot_Entry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Entry(&uniprot.Entry{}))
}

//export uniprot_Entry_Accession_Get
func uniprot_Entry_Accession_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_string(&op.Accession)
}

//export uniprot_Entry_Accession_Set
func uniprot_Entry_Accession_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Accession = deptrFromHandle_Slice_string(val)
}

//export uniprot_Entry_Name_Get
func uniprot_Entry_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_string(&op.Name)
}

//export uniprot_Entry_Name_Set
func uniprot_Entry_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Name = deptrFromHandle_Slice_string(val)
}

//export uniprot_Entry_Protein_Get
func uniprot_Entry_Protein_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_ProteinType(&op.Protein)
}

//export uniprot_Entry_Protein_Set
func uniprot_Entry_Protein_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Protein = *ptrFromHandle_uniprot_ProteinType(val)
}

//export uniprot_Entry_Gene_Get
func uniprot_Entry_Gene_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_GeneType(&op.Gene)
}

//export uniprot_Entry_Gene_Set
func uniprot_Entry_Gene_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Gene = deptrFromHandle_Slice_uniprot_GeneType(val)
}

//export uniprot_Entry_Organism_Get
func uniprot_Entry_Organism_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_OrganismType(&op.Organism)
}

//export uniprot_Entry_Organism_Set
func uniprot_Entry_Organism_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Organism = *ptrFromHandle_uniprot_OrganismType(val)
}

//export uniprot_Entry_OrganismHost_Get
func uniprot_Entry_OrganismHost_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_OrganismType(&op.OrganismHost)
}

//export uniprot_Entry_OrganismHost_Set
func uniprot_Entry_OrganismHost_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.OrganismHost = deptrFromHandle_Slice_uniprot_OrganismType(val)
}

//export uniprot_Entry_GeneLocation_Get
func uniprot_Entry_GeneLocation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_GeneLocationType(&op.GeneLocation)
}

//export uniprot_Entry_GeneLocation_Set
func uniprot_Entry_GeneLocation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.GeneLocation = deptrFromHandle_Slice_uniprot_GeneLocationType(val)
}

//export uniprot_Entry_Reference_Get
func uniprot_Entry_Reference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_ReferenceType(&op.Reference)
}

//export uniprot_Entry_Reference_Set
func uniprot_Entry_Reference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Reference = deptrFromHandle_Slice_uniprot_ReferenceType(val)
}

//export uniprot_Entry_Comment_Get
func uniprot_Entry_Comment_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_CommentType(&op.Comment)
}

//export uniprot_Entry_Comment_Set
func uniprot_Entry_Comment_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Comment = deptrFromHandle_Slice_uniprot_CommentType(val)
}

//export uniprot_Entry_DbReference_Get
func uniprot_Entry_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_Entry_DbReference_Set
func uniprot_Entry_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_Entry_ProteinExistence_Get
func uniprot_Entry_ProteinExistence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_ProteinExistenceType(&op.ProteinExistence)
}

//export uniprot_Entry_ProteinExistence_Set
func uniprot_Entry_ProteinExistence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.ProteinExistence = *ptrFromHandle_uniprot_ProteinExistenceType(val)
}

//export uniprot_Entry_Keyword_Get
func uniprot_Entry_Keyword_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_KeywordType(&op.Keyword)
}

//export uniprot_Entry_Keyword_Set
func uniprot_Entry_Keyword_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Keyword = deptrFromHandle_Slice_uniprot_KeywordType(val)
}

//export uniprot_Entry_Feature_Get
func uniprot_Entry_Feature_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_FeatureType(&op.Feature)
}

//export uniprot_Entry_Feature_Set
func uniprot_Entry_Feature_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Feature = deptrFromHandle_Slice_uniprot_FeatureType(val)
}

//export uniprot_Entry_Evidence_Get
func uniprot_Entry_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_Slice_uniprot_EvidenceType(&op.Evidence)
}

//export uniprot_Entry_Evidence_Set
func uniprot_Entry_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Evidence = deptrFromHandle_Slice_uniprot_EvidenceType(val)
}

//export uniprot_Entry_Sequence_Get
func uniprot_Entry_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_uniprot_SequenceType(&op.Sequence)
}

//export uniprot_Entry_Sequence_Set
func uniprot_Entry_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Sequence = *ptrFromHandle_uniprot_SequenceType(val)
}

//export uniprot_Entry_Dataset_Get
func uniprot_Entry_Dataset_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Entry(handle)
	return C.CString(string(op.Dataset))
}

//export uniprot_Entry_Dataset_Set
func uniprot_Entry_Dataset_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Dataset = uniprot.Dataset(C.GoString(val))
}

//export uniprot_Entry_Created_Get
func uniprot_Entry_Created_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_time_Time(&op.Created)
}

//export uniprot_Entry_Created_Set
func uniprot_Entry_Created_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Created = *ptrFromHandle_time_Time(val)
}

//export uniprot_Entry_Modified_Get
func uniprot_Entry_Modified_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Entry(handle)
	return handleFromPtr_time_Time(&op.Modified)
}

//export uniprot_Entry_Modified_Set
func uniprot_Entry_Modified_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Modified = *ptrFromHandle_time_Time(val)
}

//export uniprot_Entry_Version_Get
func uniprot_Entry_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_Entry(handle)
	return C.longlong(op.Version)
}

//export uniprot_Entry_Version_Set
func uniprot_Entry_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_Entry(handle)
	op.Version = int(val)
}

//export uniprot_Entry_UnmarshalXML
func uniprot_Entry_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.Entry")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.Entry{})).(*uniprot.Entry).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.KeywordType ---
//
//export uniprot_KeywordType_CTor
func uniprot_KeywordType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_KeywordType(&uniprot.KeywordType{}))
}

//export uniprot_KeywordType_Value_Get
func uniprot_KeywordType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	return C.CString(op.Value)
}

//export uniprot_KeywordType_Value_Set
func uniprot_KeywordType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_KeywordType_Evidence_Get
func uniprot_KeywordType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_KeywordType_Evidence_Set
func uniprot_KeywordType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_KeywordType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.GeneType ---
//
//export uniprot_GeneType_CTor
func uniprot_GeneType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneType(&uniprot.GeneType{}))
}

//export uniprot_GeneType_Name_Get
func uniprot_GeneType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneType(handle)
	return handleFromPtr_Slice_uniprot_GeneNameType(&op.Name)
}

//export uniprot_GeneType_Name_Set
func uniprot_GeneType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_GeneNameType(val)
}

// --- wrapping struct: uniprot.IsoformType ---
//
//export uniprot_IsoformType_CTor
func uniprot_IsoformType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_IsoformType(&uniprot.IsoformType{}))
}

//export uniprot_IsoformType_Id_Get
func uniprot_IsoformType_Id_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_string(&op.Id)
}

//export uniprot_IsoformType_Id_Set
func uniprot_IsoformType_Id_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Id = deptrFromHandle_Slice_string(val)
}

//export uniprot_IsoformType_Name_Get
func uniprot_IsoformType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_uniprot_Name(&op.Name)
}

//export uniprot_IsoformType_Name_Set
func uniprot_IsoformType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_Name(val)
}

//export uniprot_IsoformType_Sequence_Get
func uniprot_IsoformType_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_uniprot_Anon6(&op.Sequence)
}

//export uniprot_IsoformType_Sequence_Set
func uniprot_IsoformType_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Sequence = *ptrFromHandle_uniprot_Anon6(val)
}

//export uniprot_IsoformType_Text_Get
func uniprot_IsoformType_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_IsoformType_Text_Set
func uniprot_IsoformType_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_IsoformType(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.NameListType ---
//
//export uniprot_NameListType_CTor
func uniprot_NameListType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_NameListType(&uniprot.NameListType{}))
}

//export uniprot_NameListType_Consortium_Get
func uniprot_NameListType_Consortium_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_NameListType(handle)
	return handleFromPtr_uniprot_ConsortiumType(&op.Consortium)
}

//export uniprot_NameListType_Consortium_Set
func uniprot_NameListType_Consortium_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_NameListType(handle)
	op.Consortium = *ptrFromHandle_uniprot_ConsortiumType(val)
}

//export uniprot_NameListType_Person_Get
func uniprot_NameListType_Person_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_NameListType(handle)
	return handleFromPtr_uniprot_PersonType(&op.Person)
}

//export uniprot_NameListType_Person_Set
func uniprot_NameListType_Person_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_NameListType(handle)
	op.Person = *ptrFromHandle_uniprot_PersonType(val)
}

// --- wrapping struct: uniprot.ReactionType ---
//
//export uniprot_ReactionType_CTor
func uniprot_ReactionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ReactionType(&uniprot.ReactionType{}))
}

//export uniprot_ReactionType_Text_Get
func uniprot_ReactionType_Text_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return C.CString(op.Text)
}

//export uniprot_ReactionType_Text_Set
func uniprot_ReactionType_Text_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.Text = C.GoString(val)
}

//export uniprot_ReactionType_DbReference_Get
func uniprot_ReactionType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_ReactionType_DbReference_Set
func uniprot_ReactionType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_ReactionType_Evidence_Get
func uniprot_ReactionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_ReactionType_Evidence_Set
func uniprot_ReactionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ReactionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ImportedFromType ---
//
//export uniprot_ImportedFromType_CTor
func uniprot_ImportedFromType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ImportedFromType(&uniprot.ImportedFromType{}))
}

//export uniprot_ImportedFromType_DbReference_Get
func uniprot_ImportedFromType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ImportedFromType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_ImportedFromType_DbReference_Set
func uniprot_ImportedFromType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ImportedFromType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

// --- wrapping struct: uniprot.Lineage ---
//
//export uniprot_Lineage_CTor
func uniprot_Lineage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Lineage(&uniprot.Lineage{}))
}

//export uniprot_Lineage_Taxon_Get
func uniprot_Lineage_Taxon_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Lineage(handle)
	return handleFromPtr_Slice_string(&op.Taxon)
}

//export uniprot_Lineage_Taxon_Set
func uniprot_Lineage_Taxon_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Lineage(handle)
	op.Taxon = deptrFromHandle_Slice_string(val)
}

// --- wrapping struct: uniprot.StatusType ---
//
//export uniprot_StatusType_CTor
func uniprot_StatusType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_StatusType(&uniprot.StatusType{}))
}

//export uniprot_StatusType_Value_Get
func uniprot_StatusType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_StatusType(handle)
	return C.CString(op.Value)
}

//export uniprot_StatusType_Value_Set
func uniprot_StatusType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_StatusType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_StatusType_Status_Get
func uniprot_StatusType_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_StatusType(handle)
	return C.CString(string(op.Status))
}

//export uniprot_StatusType_Status_Set
func uniprot_StatusType_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_StatusType(handle)
	op.Status = uniprot.Status(C.GoString(val))
}

// --- wrapping struct: uniprot.SubcellularLocationType ---
//
//export uniprot_SubcellularLocationType_CTor
func uniprot_SubcellularLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SubcellularLocationType(&uniprot.SubcellularLocationType{}))
}

//export uniprot_SubcellularLocationType_Location_Get
func uniprot_SubcellularLocationType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Location)
}

//export uniprot_SubcellularLocationType_Location_Set
func uniprot_SubcellularLocationType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Location = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_SubcellularLocationType_Topology_Get
func uniprot_SubcellularLocationType_Topology_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Topology)
}

//export uniprot_SubcellularLocationType_Topology_Set
func uniprot_SubcellularLocationType_Topology_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Topology = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_SubcellularLocationType_Orientation_Get
func uniprot_SubcellularLocationType_Orientation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Orientation)
}

//export uniprot_SubcellularLocationType_Orientation_Set
func uniprot_SubcellularLocationType_Orientation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubcellularLocationType(handle)
	op.Orientation = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.SubmittedName ---
//
//export uniprot_SubmittedName_CTor
func uniprot_SubmittedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SubmittedName(&uniprot.SubmittedName{}))
}

//export uniprot_SubmittedName_FullName_Get
func uniprot_SubmittedName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_SubmittedName_FullName_Set
func uniprot_SubmittedName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_SubmittedName_EcNumber_Get
func uniprot_SubmittedName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_SubmittedName_EcNumber_Set
func uniprot_SubmittedName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SubmittedName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.CommentType ---
//
//export uniprot_CommentType_CTor
func uniprot_CommentType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CommentType(&uniprot.CommentType{}))
}

//export uniprot_CommentType_Molecule_Get
func uniprot_CommentType_Molecule_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Molecule)
}

//export uniprot_CommentType_Molecule_Set
func uniprot_CommentType_Molecule_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Molecule = C.GoString(val)
}

//export uniprot_CommentType_Absorption_Get
func uniprot_CommentType_Absorption_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Absorption(&op.Absorption)
}

//export uniprot_CommentType_Absorption_Set
func uniprot_CommentType_Absorption_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Absorption = *ptrFromHandle_uniprot_Absorption(val)
}

//export uniprot_CommentType_Kinetics_Get
func uniprot_CommentType_Kinetics_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Kinetics(&op.Kinetics)
}

//export uniprot_CommentType_Kinetics_Set
func uniprot_CommentType_Kinetics_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Kinetics = *ptrFromHandle_uniprot_Kinetics(val)
}

//export uniprot_CommentType_PhDependence_Get
func uniprot_CommentType_PhDependence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_PhDependence(&op.PhDependence)
}

//export uniprot_CommentType_PhDependence_Set
func uniprot_CommentType_PhDependence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.PhDependence = *ptrFromHandle_uniprot_PhDependence(val)
}

//export uniprot_CommentType_RedoxPotential_Get
func uniprot_CommentType_RedoxPotential_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_RedoxPotential(&op.RedoxPotential)
}

//export uniprot_CommentType_RedoxPotential_Set
func uniprot_CommentType_RedoxPotential_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.RedoxPotential = *ptrFromHandle_uniprot_RedoxPotential(val)
}

//export uniprot_CommentType_TemperatureDependence_Get
func uniprot_CommentType_TemperatureDependence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_TemperatureDependence(&op.TemperatureDependence)
}

//export uniprot_CommentType_TemperatureDependence_Set
func uniprot_CommentType_TemperatureDependence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.TemperatureDependence = *ptrFromHandle_uniprot_TemperatureDependence(val)
}

//export uniprot_CommentType_Reaction_Get
func uniprot_CommentType_Reaction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_ReactionType(&op.Reaction)
}

//export uniprot_CommentType_Reaction_Set
func uniprot_CommentType_Reaction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Reaction = *ptrFromHandle_uniprot_ReactionType(val)
}

//export uniprot_CommentType_PhysiologicalReaction_Get
func uniprot_CommentType_PhysiologicalReaction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_PhysiologicalReactionType(&op.PhysiologicalReaction)
}

//export uniprot_CommentType_PhysiologicalReaction_Set
func uniprot_CommentType_PhysiologicalReaction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.PhysiologicalReaction = deptrFromHandle_Slice_uniprot_PhysiologicalReactionType(val)
}

//export uniprot_CommentType_Cofactor_Get
func uniprot_CommentType_Cofactor_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_CofactorType(&op.Cofactor)
}

//export uniprot_CommentType_Cofactor_Set
func uniprot_CommentType_Cofactor_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Cofactor = deptrFromHandle_Slice_uniprot_CofactorType(val)
}

//export uniprot_CommentType_SubcellularLocation_Get
func uniprot_CommentType_SubcellularLocation_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_SubcellularLocationType(&op.SubcellularLocation)
}

//export uniprot_CommentType_SubcellularLocation_Set
func uniprot_CommentType_SubcellularLocation_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.SubcellularLocation = deptrFromHandle_Slice_uniprot_SubcellularLocationType(val)
}

//export uniprot_CommentType_Conflict_Get
func uniprot_CommentType_Conflict_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Conflict(&op.Conflict)
}

//export uniprot_CommentType_Conflict_Set
func uniprot_CommentType_Conflict_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Conflict = *ptrFromHandle_uniprot_Conflict(val)
}

//export uniprot_CommentType_Link_Get
func uniprot_CommentType_Link_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_Link(&op.Link)
}

//export uniprot_CommentType_Link_Set
func uniprot_CommentType_Link_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Link = deptrFromHandle_Slice_uniprot_Link(val)
}

//export uniprot_CommentType_Event_Get
func uniprot_CommentType_Event_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_EventType(&op.Event)
}

//export uniprot_CommentType_Event_Set
func uniprot_CommentType_Event_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Event = deptrFromHandle_Slice_uniprot_EventType(val)
}

//export uniprot_CommentType_Isoform_Get
func uniprot_CommentType_Isoform_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_IsoformType(&op.Isoform)
}

//export uniprot_CommentType_Isoform_Set
func uniprot_CommentType_Isoform_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Isoform = deptrFromHandle_Slice_uniprot_IsoformType(val)
}

//export uniprot_CommentType_Interactant_Get
func uniprot_CommentType_Interactant_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_InteractantType(&op.Interactant)
}

//export uniprot_CommentType_Interactant_Set
func uniprot_CommentType_Interactant_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Interactant = deptrFromHandle_Slice_uniprot_InteractantType(val)
}

//export uniprot_CommentType_OrganismsDiffer_Get
func uniprot_CommentType_OrganismsDiffer_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return boolGoToPy(op.OrganismsDiffer)
}

//export uniprot_CommentType_OrganismsDiffer_Set
func uniprot_CommentType_OrganismsDiffer_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.OrganismsDiffer = boolPyToGo(val)
}

//export uniprot_CommentType_Experiments_Get
func uniprot_CommentType_Experiments_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.longlong(op.Experiments)
}

//export uniprot_CommentType_Experiments_Set
func uniprot_CommentType_Experiments_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Experiments = int(val)
}

//export uniprot_CommentType_Disease_Get
func uniprot_CommentType_Disease_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_Disease(&op.Disease)
}

//export uniprot_CommentType_Disease_Set
func uniprot_CommentType_Disease_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Disease = *ptrFromHandle_uniprot_Disease(val)
}

//export uniprot_CommentType_Location_Get
func uniprot_CommentType_Location_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_LocationType(&op.Location)
}

//export uniprot_CommentType_Location_Set
func uniprot_CommentType_Location_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Location = deptrFromHandle_Slice_uniprot_LocationType(val)
}

//export uniprot_CommentType_Text_Get
func uniprot_CommentType_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_CommentType_Text_Set
func uniprot_CommentType_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_CommentType_Type_Get
func uniprot_CommentType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_CommentType_Type_Set
func uniprot_CommentType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_CommentType_LocationType_Get
func uniprot_CommentType_LocationType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.LocationType)
}

//export uniprot_CommentType_LocationType_Set
func uniprot_CommentType_LocationType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.LocationType = C.GoString(val)
}

//export uniprot_CommentType_Name_Get
func uniprot_CommentType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Name)
}

//export uniprot_CommentType_Name_Set
func uniprot_CommentType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CommentType_Mass_Get
func uniprot_CommentType_Mass_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.float(op.Mass)
}

//export uniprot_CommentType_Mass_Set
func uniprot_CommentType_Mass_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Mass = float32(val)
}

//export uniprot_CommentType_Error_Get
func uniprot_CommentType_Error_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Error)
}

//export uniprot_CommentType_Error_Set
func uniprot_CommentType_Error_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Error = C.GoString(val)
}

//export uniprot_CommentType_Method_Get
func uniprot_CommentType_Method_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return C.CString(op.Method)
}

//export uniprot_CommentType_Method_Set
func uniprot_CommentType_Method_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Method = C.GoString(val)
}

//export uniprot_CommentType_Evidence_Get
func uniprot_CommentType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CommentType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_CommentType_Evidence_Set
func uniprot_CommentType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CommentType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_CommentType_UnmarshalXML
func uniprot_CommentType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.CommentType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.CommentType{})).(*uniprot.CommentType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.EventType ---
//
//export uniprot_EventType_CTor
func uniprot_EventType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_EventType(&uniprot.EventType{}))
}

//export uniprot_EventType_Type_Get
func uniprot_EventType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_EventType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_EventType_Type_Set
func uniprot_EventType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_EventType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.PositionType ---
//
//export uniprot_PositionType_CTor
func uniprot_PositionType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PositionType(&uniprot.PositionType{}))
}

//export uniprot_PositionType_Position_Get
func uniprot_PositionType_Position_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return C.ulonglong(op.Position)
}

//export uniprot_PositionType_Position_Set
func uniprot_PositionType_Position_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Position = uint64(val)
}

//export uniprot_PositionType_Status_Get
func uniprot_PositionType_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return C.CString(string(op.Status))
}

//export uniprot_PositionType_Status_Set
func uniprot_PositionType_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Status = uniprot.Status(C.GoString(val))
}

//export uniprot_PositionType_Evidence_Get
func uniprot_PositionType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PositionType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_PositionType_Evidence_Set
func uniprot_PositionType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PositionType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

//export uniprot_PositionType_UnmarshalXML
func uniprot_PositionType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.PositionType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.PositionType{})).(*uniprot.PositionType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.RedoxPotential ---
//
//export uniprot_RedoxPotential_CTor
func uniprot_RedoxPotential_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_RedoxPotential(&uniprot.RedoxPotential{}))
}

//export uniprot_RedoxPotential_Text_Get
func uniprot_RedoxPotential_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RedoxPotential(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_RedoxPotential_Text_Set
func uniprot_RedoxPotential_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RedoxPotential(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.CofactorType ---
//
//export uniprot_CofactorType_CTor
func uniprot_CofactorType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CofactorType(&uniprot.CofactorType{}))
}

//export uniprot_CofactorType_Name_Get
func uniprot_CofactorType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return C.CString(op.Name)
}

//export uniprot_CofactorType_Name_Set
func uniprot_CofactorType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CofactorType_DbReference_Get
func uniprot_CofactorType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_CofactorType_DbReference_Set
func uniprot_CofactorType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_CofactorType_Evidence_Get
func uniprot_CofactorType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_CofactorType_Evidence_Set
func uniprot_CofactorType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CofactorType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.Conflict ---
//
//export uniprot_Conflict_CTor
func uniprot_Conflict_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Conflict(&uniprot.Conflict{}))
}

//export uniprot_Conflict_Sequence_Get
func uniprot_Conflict_Sequence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Conflict(handle)
	return handleFromPtr_uniprot_Sequence(&op.Sequence)
}

//export uniprot_Conflict_Sequence_Set
func uniprot_Conflict_Sequence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Conflict(handle)
	op.Sequence = *ptrFromHandle_uniprot_Sequence(val)
}

//export uniprot_Conflict_Type_Get
func uniprot_Conflict_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Conflict(handle)
	return C.CString(string(op.Type))
}

//export uniprot_Conflict_Type_Set
func uniprot_Conflict_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Conflict(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

// --- wrapping struct: uniprot.Strain ---
//
//export uniprot_Strain_CTor
func uniprot_Strain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Strain(&uniprot.Strain{}))
}

//export uniprot_Strain_Value_Get
func uniprot_Strain_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Strain(handle)
	return C.CString(op.Value)
}

//export uniprot_Strain_Value_Set
func uniprot_Strain_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Strain(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Strain_Evidence_Get
func uniprot_Strain_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Strain(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Strain_Evidence_Set
func uniprot_Strain_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Strain(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.ProteinType ---
//
//export uniprot_ProteinType_CTor
func uniprot_ProteinType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_ProteinType(&uniprot.ProteinType{}))
}

//export uniprot_ProteinType_RecommendedName_Get
func uniprot_ProteinType_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_ProteinType_RecommendedName_Set
func uniprot_ProteinType_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_ProteinType_AlternativeName_Get
func uniprot_ProteinType_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_ProteinType_AlternativeName_Set
func uniprot_ProteinType_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_ProteinType_SubmittedName_Get
func uniprot_ProteinType_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_ProteinType_SubmittedName_Set
func uniprot_ProteinType_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_ProteinType_AllergenName_Get
func uniprot_ProteinType_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_ProteinType_AllergenName_Set
func uniprot_ProteinType_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_BiotechName_Get
func uniprot_ProteinType_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_ProteinType_BiotechName_Set
func uniprot_ProteinType_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_CdAntigenName_Get
func uniprot_ProteinType_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_ProteinType_CdAntigenName_Set
func uniprot_ProteinType_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_InnName_Get
func uniprot_ProteinType_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_ProteinType_InnName_Set
func uniprot_ProteinType_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_ProteinType_Domain_Get
func uniprot_ProteinType_Domain_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_Domain(&op.Domain)
}

//export uniprot_ProteinType_Domain_Set
func uniprot_ProteinType_Domain_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.Domain = deptrFromHandle_Slice_uniprot_Domain(val)
}

//export uniprot_ProteinType_Component_Get
func uniprot_ProteinType_Component_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	return handleFromPtr_Slice_uniprot_Component(&op.Component)
}

//export uniprot_ProteinType_Component_Set
func uniprot_ProteinType_Component_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_ProteinType(handle)
	op.Component = deptrFromHandle_Slice_uniprot_Component(val)
}

// --- wrapping struct: uniprot.RecommendedName ---
//
//export uniprot_RecommendedName_CTor
func uniprot_RecommendedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_RecommendedName(&uniprot.RecommendedName{}))
}

//export uniprot_RecommendedName_FullName_Get
func uniprot_RecommendedName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_RecommendedName_FullName_Set
func uniprot_RecommendedName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_RecommendedName_ShortName_Get
func uniprot_RecommendedName_ShortName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.ShortName)
}

//export uniprot_RecommendedName_ShortName_Set
func uniprot_RecommendedName_ShortName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.ShortName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_RecommendedName_EcNumber_Get
func uniprot_RecommendedName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_RecommendedName_EcNumber_Set
func uniprot_RecommendedName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_RecommendedName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.SequenceType ---
//
//export uniprot_SequenceType_CTor
func uniprot_SequenceType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SequenceType(&uniprot.SequenceType{}))
}

//export uniprot_SequenceType_Value_Get
func uniprot_SequenceType_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(op.Value)
}

//export uniprot_SequenceType_Value_Set
func uniprot_SequenceType_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Value = C.GoString(val)
}

//export uniprot_SequenceType_Length_Get
func uniprot_SequenceType_Length_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Length)
}

//export uniprot_SequenceType_Length_Set
func uniprot_SequenceType_Length_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Length = int(val)
}

//export uniprot_SequenceType_Mass_Get
func uniprot_SequenceType_Mass_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Mass)
}

//export uniprot_SequenceType_Mass_Set
func uniprot_SequenceType_Mass_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Mass = int(val)
}

//export uniprot_SequenceType_Checksum_Get
func uniprot_SequenceType_Checksum_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(op.Checksum)
}

//export uniprot_SequenceType_Checksum_Set
func uniprot_SequenceType_Checksum_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Checksum = C.GoString(val)
}

//export uniprot_SequenceType_Modified_Get
func uniprot_SequenceType_Modified_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return handleFromPtr_time_Time(&op.Modified)
}

//export uniprot_SequenceType_Modified_Set
func uniprot_SequenceType_Modified_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Modified = *ptrFromHandle_time_Time(val)
}

//export uniprot_SequenceType_Version_Get
func uniprot_SequenceType_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.longlong(op.Version)
}

//export uniprot_SequenceType_Version_Set
func uniprot_SequenceType_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Version = int(val)
}

//export uniprot_SequenceType_Precursor_Get
func uniprot_SequenceType_Precursor_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return boolGoToPy(op.Precursor)
}

//export uniprot_SequenceType_Precursor_Set
func uniprot_SequenceType_Precursor_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Precursor = boolPyToGo(val)
}

//export uniprot_SequenceType_Fragment_Get
func uniprot_SequenceType_Fragment_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	return C.CString(string(op.Fragment))
}

//export uniprot_SequenceType_Fragment_Set
func uniprot_SequenceType_Fragment_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_SequenceType(handle)
	op.Fragment = uniprot.Fragment(C.GoString(val))
}

//export uniprot_SequenceType_UnmarshalXML
func uniprot_SequenceType_UnmarshalXML(_handle CGoHandle, d CGoHandle, start CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.SequenceType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(uniprot.SequenceType{})).(*uniprot.SequenceType).UnmarshalXML(ptrFromHandle_Ptr_xml_Decoder(d), *ptrFromHandle_xml_StartElement(start))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: uniprot.Component ---
//
//export uniprot_Component_CTor
func uniprot_Component_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Component(&uniprot.Component{}))
}

//export uniprot_Component_RecommendedName_Get
func uniprot_Component_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_Component_RecommendedName_Set
func uniprot_Component_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_Component_AlternativeName_Get
func uniprot_Component_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_Component_AlternativeName_Set
func uniprot_Component_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_Component_SubmittedName_Get
func uniprot_Component_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_Component_SubmittedName_Set
func uniprot_Component_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_Component_AllergenName_Get
func uniprot_Component_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_Component_AllergenName_Set
func uniprot_Component_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_BiotechName_Get
func uniprot_Component_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_Component_BiotechName_Set
func uniprot_Component_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_CdAntigenName_Get
func uniprot_Component_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_Component_CdAntigenName_Set
func uniprot_Component_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Component_InnName_Get
func uniprot_Component_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Component(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_Component_InnName_Set
func uniprot_Component_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Component(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Domain ---
//
//export uniprot_Domain_CTor
func uniprot_Domain_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Domain(&uniprot.Domain{}))
}

//export uniprot_Domain_RecommendedName_Get
func uniprot_Domain_RecommendedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_RecommendedName(&op.RecommendedName)
}

//export uniprot_Domain_RecommendedName_Set
func uniprot_Domain_RecommendedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.RecommendedName = *ptrFromHandle_uniprot_RecommendedName(val)
}

//export uniprot_Domain_AlternativeName_Get
func uniprot_Domain_AlternativeName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_AlternativeName(&op.AlternativeName)
}

//export uniprot_Domain_AlternativeName_Set
func uniprot_Domain_AlternativeName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.AlternativeName = deptrFromHandle_Slice_uniprot_AlternativeName(val)
}

//export uniprot_Domain_SubmittedName_Get
func uniprot_Domain_SubmittedName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_SubmittedName(&op.SubmittedName)
}

//export uniprot_Domain_SubmittedName_Set
func uniprot_Domain_SubmittedName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.SubmittedName = deptrFromHandle_Slice_uniprot_SubmittedName(val)
}

//export uniprot_Domain_AllergenName_Get
func uniprot_Domain_AllergenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.AllergenName)
}

//export uniprot_Domain_AllergenName_Set
func uniprot_Domain_AllergenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.AllergenName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_BiotechName_Get
func uniprot_Domain_BiotechName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.BiotechName)
}

//export uniprot_Domain_BiotechName_Set
func uniprot_Domain_BiotechName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.BiotechName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_CdAntigenName_Get
func uniprot_Domain_CdAntigenName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.CdAntigenName)
}

//export uniprot_Domain_CdAntigenName_Set
func uniprot_Domain_CdAntigenName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.CdAntigenName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Domain_InnName_Get
func uniprot_Domain_InnName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Domain(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.InnName)
}

//export uniprot_Domain_InnName_Set
func uniprot_Domain_InnName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Domain(handle)
	op.InnName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.InteractantType ---
//
//export uniprot_InteractantType_CTor
func uniprot_InteractantType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_InteractantType(&uniprot.InteractantType{}))
}

//export uniprot_InteractantType_Id_Get
func uniprot_InteractantType_Id_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.Id)
}

//export uniprot_InteractantType_Id_Set
func uniprot_InteractantType_Id_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.Id = C.GoString(val)
}

//export uniprot_InteractantType_Label_Get
func uniprot_InteractantType_Label_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.Label)
}

//export uniprot_InteractantType_Label_Set
func uniprot_InteractantType_Label_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.Label = C.GoString(val)
}

//export uniprot_InteractantType_DbReference_Get
func uniprot_InteractantType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return handleFromPtr_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_InteractantType_DbReference_Set
func uniprot_InteractantType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.DbReference = *ptrFromHandle_uniprot_DbReferenceType(val)
}

//export uniprot_InteractantType_IntactId_Get
func uniprot_InteractantType_IntactId_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	return C.CString(op.IntactId)
}

//export uniprot_InteractantType_IntactId_Set
func uniprot_InteractantType_IntactId_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_InteractantType(handle)
	op.IntactId = C.GoString(val)
}

// --- wrapping struct: uniprot.Kinetics ---
//
//export uniprot_Kinetics_CTor
func uniprot_Kinetics_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Kinetics(&uniprot.Kinetics{}))
}

//export uniprot_Kinetics_KM_Get
func uniprot_Kinetics_KM_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.KM)
}

//export uniprot_Kinetics_KM_Set
func uniprot_Kinetics_KM_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.KM = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Kinetics_Vmax_Get
func uniprot_Kinetics_Vmax_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Vmax)
}

//export uniprot_Kinetics_Vmax_Set
func uniprot_Kinetics_Vmax_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.Vmax = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_Kinetics_Text_Get
func uniprot_Kinetics_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_Kinetics_Text_Set
func uniprot_Kinetics_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Kinetics(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Sequence ---
//
//export uniprot_Sequence_CTor
func uniprot_Sequence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Sequence(&uniprot.Sequence{}))
}

//export uniprot_Sequence_Resource_Get
func uniprot_Sequence_Resource_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Sequence(handle)
	return C.CString(string(op.Resource))
}

//export uniprot_Sequence_Resource_Set
func uniprot_Sequence_Resource_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Sequence(handle)
	op.Resource = uniprot.Resource(C.GoString(val))
}

//export uniprot_Sequence_Version_Get
func uniprot_Sequence_Version_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_uniprot_Sequence(handle)
	return C.longlong(op.Version)
}

//export uniprot_Sequence_Version_Set
func uniprot_Sequence_Version_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_uniprot_Sequence(handle)
	op.Version = int(val)
}

// --- wrapping struct: uniprot.AlternativeName ---
//
//export uniprot_AlternativeName_CTor
func uniprot_AlternativeName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_AlternativeName(&uniprot.AlternativeName{}))
}

//export uniprot_AlternativeName_FullName_Get
func uniprot_AlternativeName_FullName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_uniprot_EvidencedStringType(&op.FullName)
}

//export uniprot_AlternativeName_FullName_Set
func uniprot_AlternativeName_FullName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.FullName = *ptrFromHandle_uniprot_EvidencedStringType(val)
}

//export uniprot_AlternativeName_ShortName_Get
func uniprot_AlternativeName_ShortName_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.ShortName)
}

//export uniprot_AlternativeName_ShortName_Set
func uniprot_AlternativeName_ShortName_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.ShortName = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

//export uniprot_AlternativeName_EcNumber_Get
func uniprot_AlternativeName_EcNumber_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.EcNumber)
}

//export uniprot_AlternativeName_EcNumber_Set
func uniprot_AlternativeName_EcNumber_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_AlternativeName(handle)
	op.EcNumber = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Link ---
//
//export uniprot_Link_CTor
func uniprot_Link_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Link(&uniprot.Link{}))
}

//export uniprot_Link_Uri_Get
func uniprot_Link_Uri_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Link(handle)
	return C.CString(op.Uri)
}

//export uniprot_Link_Uri_Set
func uniprot_Link_Uri_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Link(handle)
	op.Uri = C.GoString(val)
}

// --- wrapping struct: uniprot.PhDependence ---
//
//export uniprot_PhDependence_CTor
func uniprot_PhDependence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PhDependence(&uniprot.PhDependence{}))
}

//export uniprot_PhDependence_Text_Get
func uniprot_PhDependence_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_PhDependence(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_PhDependence_Text_Set
func uniprot_PhDependence_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_PhDependence(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.SourceDataType ---
//
//export uniprot_SourceDataType_CTor
func uniprot_SourceDataType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_SourceDataType(&uniprot.SourceDataType{}))
}

//export uniprot_SourceDataType_Strain_Get
func uniprot_SourceDataType_Strain_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Strain(&op.Strain)
}

//export uniprot_SourceDataType_Strain_Set
func uniprot_SourceDataType_Strain_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Strain = *ptrFromHandle_uniprot_Strain(val)
}

//export uniprot_SourceDataType_Plasmid_Get
func uniprot_SourceDataType_Plasmid_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Plasmid(&op.Plasmid)
}

//export uniprot_SourceDataType_Plasmid_Set
func uniprot_SourceDataType_Plasmid_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Plasmid = *ptrFromHandle_uniprot_Plasmid(val)
}

//export uniprot_SourceDataType_Transposon_Get
func uniprot_SourceDataType_Transposon_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Transposon(&op.Transposon)
}

//export uniprot_SourceDataType_Transposon_Set
func uniprot_SourceDataType_Transposon_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Transposon = *ptrFromHandle_uniprot_Transposon(val)
}

//export uniprot_SourceDataType_Tissue_Get
func uniprot_SourceDataType_Tissue_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	return handleFromPtr_uniprot_Tissue(&op.Tissue)
}

//export uniprot_SourceDataType_Tissue_Set
func uniprot_SourceDataType_Tissue_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_SourceDataType(handle)
	op.Tissue = *ptrFromHandle_uniprot_Tissue(val)
}

// --- wrapping struct: uniprot.Uniprot ---
//
//export uniprot_Uniprot_CTor
func uniprot_Uniprot_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Uniprot(&uniprot.Uniprot{}))
}

//export uniprot_Uniprot_Entry_Get
func uniprot_Uniprot_Entry_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	return handleFromPtr_Slice_string(&op.Entry)
}

//export uniprot_Uniprot_Entry_Set
func uniprot_Uniprot_Entry_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	op.Entry = deptrFromHandle_Slice_string(val)
}

//export uniprot_Uniprot_Copyright_Get
func uniprot_Uniprot_Copyright_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	return C.CString(op.Copyright)
}

//export uniprot_Uniprot_Copyright_Set
func uniprot_Uniprot_Copyright_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Uniprot(handle)
	op.Copyright = C.GoString(val)
}

// --- wrapping struct: uniprot.CitationType ---
//
//export uniprot_CitationType_CTor
func uniprot_CitationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_CitationType(&uniprot.CitationType{}))
}

//export uniprot_CitationType_Title_Get
func uniprot_CitationType_Title_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Title)
}

//export uniprot_CitationType_Title_Set
func uniprot_CitationType_Title_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Title = C.GoString(val)
}

//export uniprot_CitationType_EditorList_Get
func uniprot_CitationType_EditorList_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_uniprot_NameListType(&op.EditorList)
}

//export uniprot_CitationType_EditorList_Set
func uniprot_CitationType_EditorList_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.EditorList = *ptrFromHandle_uniprot_NameListType(val)
}

//export uniprot_CitationType_AuthorList_Get
func uniprot_CitationType_AuthorList_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_uniprot_NameListType(&op.AuthorList)
}

//export uniprot_CitationType_AuthorList_Set
func uniprot_CitationType_AuthorList_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.AuthorList = *ptrFromHandle_uniprot_NameListType(val)
}

//export uniprot_CitationType_Locator_Get
func uniprot_CitationType_Locator_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Locator)
}

//export uniprot_CitationType_Locator_Set
func uniprot_CitationType_Locator_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Locator = C.GoString(val)
}

//export uniprot_CitationType_DbReference_Get
func uniprot_CitationType_DbReference_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return handleFromPtr_Slice_uniprot_DbReferenceType(&op.DbReference)
}

//export uniprot_CitationType_DbReference_Set
func uniprot_CitationType_DbReference_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.DbReference = deptrFromHandle_Slice_uniprot_DbReferenceType(val)
}

//export uniprot_CitationType_Type_Get
func uniprot_CitationType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_CitationType_Type_Set
func uniprot_CitationType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_CitationType_Date_Get
func uniprot_CitationType_Date_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(string(op.Date))
}

//export uniprot_CitationType_Date_Set
func uniprot_CitationType_Date_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Date = uniprot.Date(C.GoString(val))
}

//export uniprot_CitationType_Name_Get
func uniprot_CitationType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Name)
}

//export uniprot_CitationType_Name_Set
func uniprot_CitationType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Name = C.GoString(val)
}

//export uniprot_CitationType_Volume_Get
func uniprot_CitationType_Volume_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Volume)
}

//export uniprot_CitationType_Volume_Set
func uniprot_CitationType_Volume_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Volume = C.GoString(val)
}

//export uniprot_CitationType_First_Get
func uniprot_CitationType_First_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.First)
}

//export uniprot_CitationType_First_Set
func uniprot_CitationType_First_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.First = C.GoString(val)
}

//export uniprot_CitationType_Last_Get
func uniprot_CitationType_Last_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Last)
}

//export uniprot_CitationType_Last_Set
func uniprot_CitationType_Last_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Last = C.GoString(val)
}

//export uniprot_CitationType_Publisher_Get
func uniprot_CitationType_Publisher_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Publisher)
}

//export uniprot_CitationType_Publisher_Set
func uniprot_CitationType_Publisher_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Publisher = C.GoString(val)
}

//export uniprot_CitationType_City_Get
func uniprot_CitationType_City_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.City)
}

//export uniprot_CitationType_City_Set
func uniprot_CitationType_City_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.City = C.GoString(val)
}

//export uniprot_CitationType_Db_Get
func uniprot_CitationType_Db_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Db)
}

//export uniprot_CitationType_Db_Set
func uniprot_CitationType_Db_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Db = C.GoString(val)
}

//export uniprot_CitationType_Number_Get
func uniprot_CitationType_Number_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Number)
}

//export uniprot_CitationType_Number_Set
func uniprot_CitationType_Number_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Number = C.GoString(val)
}

//export uniprot_CitationType_Institute_Get
func uniprot_CitationType_Institute_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Institute)
}

//export uniprot_CitationType_Institute_Set
func uniprot_CitationType_Institute_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Institute = C.GoString(val)
}

//export uniprot_CitationType_Country_Get
func uniprot_CitationType_Country_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_CitationType(handle)
	return C.CString(op.Country)
}

//export uniprot_CitationType_Country_Set
func uniprot_CitationType_Country_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_CitationType(handle)
	op.Country = C.GoString(val)
}

// --- wrapping struct: uniprot.GeneLocationType ---
//
//export uniprot_GeneLocationType_CTor
func uniprot_GeneLocationType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_GeneLocationType(&uniprot.GeneLocationType{}))
}

//export uniprot_GeneLocationType_Name_Get
func uniprot_GeneLocationType_Name_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return handleFromPtr_Slice_uniprot_StatusType(&op.Name)
}

//export uniprot_GeneLocationType_Name_Set
func uniprot_GeneLocationType_Name_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Name = deptrFromHandle_Slice_uniprot_StatusType(val)
}

//export uniprot_GeneLocationType_Type_Get
func uniprot_GeneLocationType_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return C.CString(string(op.Type))
}

//export uniprot_GeneLocationType_Type_Set
func uniprot_GeneLocationType_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Type = uniprot.Type(C.GoString(val))
}

//export uniprot_GeneLocationType_Evidence_Get
func uniprot_GeneLocationType_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_GeneLocationType_Evidence_Set
func uniprot_GeneLocationType_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_GeneLocationType(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// --- wrapping struct: uniprot.PersonType ---
//
//export uniprot_PersonType_CTor
func uniprot_PersonType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_PersonType(&uniprot.PersonType{}))
}

//export uniprot_PersonType_Name_Get
func uniprot_PersonType_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_PersonType(handle)
	return C.CString(op.Name)
}

//export uniprot_PersonType_Name_Set
func uniprot_PersonType_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_PersonType(handle)
	op.Name = C.GoString(val)
}

// --- wrapping struct: uniprot.TemperatureDependence ---
//
//export uniprot_TemperatureDependence_CTor
func uniprot_TemperatureDependence_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_TemperatureDependence(&uniprot.TemperatureDependence{}))
}

//export uniprot_TemperatureDependence_Text_Get
func uniprot_TemperatureDependence_Text_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_TemperatureDependence(handle)
	return handleFromPtr_Slice_uniprot_EvidencedStringType(&op.Text)
}

//export uniprot_TemperatureDependence_Text_Set
func uniprot_TemperatureDependence_Text_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_TemperatureDependence(handle)
	op.Text = deptrFromHandle_Slice_uniprot_EvidencedStringType(val)
}

// --- wrapping struct: uniprot.Tissue ---
//
//export uniprot_Tissue_CTor
func uniprot_Tissue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_Tissue(&uniprot.Tissue{}))
}

//export uniprot_Tissue_Value_Get
func uniprot_Tissue_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_uniprot_Tissue(handle)
	return C.CString(op.Value)
}

//export uniprot_Tissue_Value_Set
func uniprot_Tissue_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_uniprot_Tissue(handle)
	op.Value = C.GoString(val)
}

//export uniprot_Tissue_Evidence_Get
func uniprot_Tissue_Evidence_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_uniprot_Tissue(handle)
	return handleFromPtr_uniprot_IntListType(&op.Evidence)
}

//export uniprot_Tissue_Evidence_Set
func uniprot_Tissue_Evidence_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_uniprot_Tissue(handle)
	op.Evidence = deptrFromHandle_uniprot_IntListType(val)
}

// ---- Slices ---

// --- wrapping slice: uniprot.IntListType ---
//
//export uniprot_IntListType_CTor
func uniprot_IntListType_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uniprot_IntListType(&uniprot.IntListType{}))
}

//export uniprot_IntListType_len
func uniprot_IntListType_len(handle CGoHandle) int {
	return len(deptrFromHandle_uniprot_IntListType(handle))
}

//export uniprot_IntListType_elem
func uniprot_IntListType_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_uniprot_IntListType(handle)
	return C.longlong(s[_idx])
}

//export uniprot_IntListType_subslice
func uniprot_IntListType_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_uniprot_IntListType(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_uniprot_IntListType(&ss))
}

//export uniprot_IntListType_set
func uniprot_IntListType_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_uniprot_IntListType(handle)
	s[_idx] = int(_vl)
}

//export uniprot_IntListType_append
func uniprot_IntListType_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_uniprot_IntListType(handle)
	*s = append(*s, int(_vl))
}

//export uniprot_IntListType_UnmarshalText
func uniprot_IntListType_UnmarshalText(_handle CGoHandle, text CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*uniprot.IntListType")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(*uniprot.IntListType).UnmarshalText(deptrFromHandle_Slice_byte(text))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---
